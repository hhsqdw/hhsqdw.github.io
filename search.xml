<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/10/19/hello-world/</url>
    <content><![CDATA[

Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/24/articles/md%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[插入图片

小点

**加粗
&#x3D;&#x3D;标记&#x3D;&#x3D;
#标签
Tab 

红色的字



表头
表头



单元格
单元格


单元格
单元格


]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/01/12/articles/%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86/</url>
    <content><![CDATA[遇到报错，实在解决不了，就降低版本]]></content>
  </entry>
  <entry>
    <title>Token</title>
    <url>/2025/11/08/articles/AI%E6%99%BA%E8%83%BD%E4%BD%93/Prompt%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[基础提示技巧
明确指定任务和角色
为 AI 提供清晰的任务描述和角色定位，帮助模型理解背景和期望



系统：你是一位经验丰富的 Java 教师，擅长向初学者解释编程概念。用户：请解释 Java 中的列表推导式，包括基本语法和 2-3 个实用示例。


提供详细说明和具体实例
提供足够的上下文信息和期望的输出，减少模型的不确定性



请提供一个[计划]，针对[项目]，计划包括1. ***2. ***   示例格式：1. ***2. ***


使用结构化格式引导思维
通过列表、表格等格式，使指令更容易理解，输出更有条理



分析下面项目的优缺点项目：****请使用表格格式回答，包含下列：- 优势（最少三项）- 对每项优势的具体分析- 劣势（最少三项）- 对每项劣势的具体分析- 对应建议


明确输出格式要求
指定格式，长度，样式，使得输出更符合期望



撰写一篇关于 Java 的学习路线推荐，要求:- 使用通俗易懂的语言，适合非专业阅读- 包含5个小标题，每个标题下2-3段文字- 总字数控制在800字左右- 结尾提供3个可行的个人行动建议

进阶提示技巧
思维链提示法（‌Chain-of-​Thought）
引导模型展示推导过程，逐步思考问题，提高复杂问题的准确性



问题：一个商店售卖T恤，每件15元。如果购买5件以上可以享受8折优惠。小明买了7件T恤，他需要支付多少钱？请一步步思考解决这个问题:1. 首先计算7件T恤的原价2. 确定是否符合折扣条件3. 如果符合，计算折扣后的价格4. 得出最终支付金额


少样本学习（F‌ew-Shot L​earning）
提供几个样本，帮助模型理解任务模式和期望输出



我将给你几个代码，请你按照相同的方式解析错误所在输入：“system.out.print(&quot;hello world&quot;);”输出：“错误所在：system，应该修改为 System，因为是调用 System 库”


分步骤指导（Step-by-Step）
将复杂问题分解为可管理的步骤，确保模型完成的每个环节正确



请帮我创建一个简单的网站落地页设计方案，按照以下步骤:步骤1: 分析目标受众(考虑年龄、职业、需求等因素)步骤2: 确定页面核心信息(主标题、副标题、价值主张)步骤3: 设计页面结构(至少包含哪些区块)步骤4: 制定视觉引导策略(颜色、图像建议)步骤5: 设计行动召唤(CTA)按钮和文案


自我评估和修正
让模型评估自己的输出并进行改进，提高准确性和质量



解决以下概率问题:从一副标准扑克牌中随机抽取两张牌，求抽到至少一张红桃的概率。首先给出你的解答，然后:1. 检查你的推理过程是否存在逻辑错误2. 验证你使用的概率公式是否正确3. 检查计算步骤是否有误4. 如果发现任何问题，提供修正后的解答


知识检索和引用
引导模型检索相关信息并明确引用信息来源，提高可靠性



请讲解 SpringBoot 在执行的时候的启动流程。在回答中:1. 提供 SpringBoot 的官方解释2. 给出分别是哪几个组件3. 描述执行的先后顺序对于任何可能需要具体数据或研究支持的陈述，请明确指出这些信息的来源，并说明这些信息的可靠性。


多视角分析
引导模型从不同角度、立场或专业视角分析问题，提供全面见解



分析&quot;城市应该禁止私家车进入市中心&quot;这一提议:请从以下4个不同角度分析:1. 环保专家视角2. 经济学家视角3. 市中心商户视角4. 通勤居民视角对每个视角:- 提供支持该提议的2个论点- 提供反对该提议的2个论点- 分析可能的折中方案


多模态思维
结合不同表⁠达形式进行思考，如‌文字描述、图表结构​、代码逻辑等



设计一个智能家居系统的基础架构:1. 首先用文字描述系统的主要功能和组件2. 然后创建一个系统架构图(用ASCII或文本形式表示)3. 接着提供用户交互流程4. 最后简述实现这个系统可能面临的技术挑战尝试从不同角度思考:功能性、用户体验、技术实现、安全性等。]]></content>
  </entry>
  <entry>
    <title>RAG</title>
    <url>/2025/11/15/articles/AI%E6%99%BA%E8%83%BD%E4%BD%93/RAG%20%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[RAG 概念什么是 RAGRAG 是一种结合信息检索技术和 AI 内容生成的混合结构，可以解决大模型的知识时效性限制和幻读问题
简单来说就是让模型开卷考，让 AI 回答问题之前先查一下特定的知识库来获取信息，确保回答是基于资料而不是凭空捏造
RAG 和传统 AI 模型的区别



特性
传统大语言模型
RAG 增强模型



知识时效性
受训练数据截止日期限制
可接入最新知识库


领域专业性
泛化知识⁠，专业深度有限
可接入专业领域知识


响应准‌确性
可能产生 “幻觉”
基于检索的事​实依据


可控性
依赖原始训练
可通过知‎识库定制输出


资源消耗
较高（需要大模型参‌数）
模型可更小，结合外部知识


RAG 的工作流程
文档收集和切割
向量转换和存储
文档过滤和检索
检查增强和关联

文档收集和切割文档收集：从各种来源（网页、PDF、数据库等）收集原始文档
文档预处理：清洗、标准化文本格式
文档切割：将长文档分割成适当大小的片段（俗称chunks）

基于固定大小（如1024个 token）
基于语义边界（如段落、文章）
基于递归分割策略（如递归字符 n-gram 切割）

向量转换和存储向量转化：使用 Embedding 模型将文本转换为高纬度向量表示，可以捕获到文本的语义特征
向量存储：将转换的向量和文本存入向量数据库，支持高效相似性搜索
![[Pasted image 20251117195905.png]]
文档过滤和检索查询处理：将用户的问题转换为向量表示
过滤机制：基于元数据、关键词或自定义规则进行过滤
相似度搜索：在向量数据库中查找与问题向量最相似的文档块，常用的相似度搜索算法有余弦相似度、欧式距离等
上下文组装：将检索出来的文档块组装成连贯的上下文
![[Pasted image 20251117200454.png]]
查询增强和关联提示词组装：将检索到的相关文档和用户的问题组合成增强提示词
上下文融合：大模型基于增强提示生成模型
源引用：在回答中添加信息来源引用
后处理：格式化、摘要或其他处理以优化最终输出
RAG 的检索RAG 的本质是 “有依据才回答，没依据坦白”， 所以检索失败的核心处理逻辑是：

先判断是不是真的没有答案：并不是说 “没找到” 就等于 “知识库没有”，可能是检索器没搜对（比如关键词匹配差，embedding 模型不合适）

再给出不编造的响应：明确告诉用户 “当前知识库没有相关内容”，并非强行生成

最后提供 “后续解决方案”： 引导用户补充信息、或者触发知识库更新，完成闭环


具体实行策略：

在给大模型的 Prompt 中明确加入规则，直接告诉用户 “无匹配信息”

规则1：仅基于提供的“检索到的知识库片段”回答问题； 规则2：如果检索到的片段为空、或没有任何与问题相关的信息，直接回复：“抱歉，当前知识库中没有找到与您的问题相关的有效信息，无法提供准确回答。您可以尝试补充问题细节，或咨询其他相关话题。”； 规则3：禁止在没有检索依据的情况下，编造任何来自“知识库”的信息。


结合大模型的 “通用知识”（但必须标注来源）

规则4：如果检索失败（无相关知识库信息），可以基于你自身的通用知识简要回答，但必须在开头注明：“注意：以下回答来自模型的通用知识（非当前知识库），可能存在时效性或准确性问题，仅供参考：”； 规则5：如果通用知识也无法回答，直接执行规则2。

注意：这种方式会牺牲 “绝对时效性”（因为大模型的通用知识截止到训练 cutoff 时间），但能提升用户体验，适合对时效性要求不极端的场景（比如常识类问题）。

引导用户 “补充信息”，提升检索成功率

规则6：如果检索失败，且判断问题可能存在“信息模糊”（比如缺少关键条件、对象不明确），可以回复：“抱歉，当前知识库中没有找到相关信息。为了更准确地为您解答，建议补充以下细节：[举例说明需要补充的信息，如产品型号、时间范围、具体场景等]，我会为您重新查询。”


工程优化细节：避免 “假检索失败”

设置检索阈值
检索器（如 FAISS、Milvus）返回的结果会有 “相关性分数”（比如余弦相似度），设置一个阈值（如 0.7）：分数低于阈值，视为 “无相关信息”；分数高于阈值，才作为有效检索结果。
避免 “为了检索而检索”：比如返回一堆不相关的文档，导致模型基于错误依据回答。


优化检索策略
用「混合检索」（关键词检索 + 向量检索）
关键词扩展
调整 embedding 模型





RAG 使用首先，我们要对自己准备好的知识库文档进行处理，然后保存到向量数据库中。这个过程俗称 ETL（抽取、转换、加载），Spring AI 提供了对 ETL 的支持，参考 官方文档。
ETL 的 3 大核心组件，按照顺序执行：

DocumentReader：读取文档，得到文档列表

DocumentTransformer：转换文档，得到处理后的文档列表

DocumentWriter：将文档列表保存到存储中（可以是向量数据库，也可以是其他存储）

导入依赖


&lt;dependency&gt;    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;    &lt;artifactId&gt;spring-ai-markdown-document-reader&lt;/artifactId&gt;    &lt;version&gt;1.0.0-M6&lt;/version&gt;&lt;/dependency&gt;

本地知识库
编写文档加载器类 DocumentLoader，负责读取所有 Markdown 文档并转换为 Document 列表

@Component  @Slf4j  public class DocumentLoader &#123;        private ResourcePatternResolver resourcePatternResolver;        public LoveAppDocumentLoader(ResourcePatternResolver resourcePatternResolver)&#123;          this.resourcePatternResolver = resourcePatternResolver;      &#125;        public List&lt;Document&gt; loadMarkdowns()&#123;          List&lt;Document&gt; list = new ArrayList&lt;&gt;();          try &#123;              Resource[] resources = resourcePatternResolver.getResources(&quot;classpath:document/*.md&quot;);              // 日志1：打印找到的 MD 文件数量              log.info(&quot;找到 &#123;&#125; 个 Markdown 文档&quot;, resources.length);              for (Resource resource : resources) &#123;                  String filename = resource.getFilename();                  log.info(&quot;正在加载文档：&#123;&#125;&quot;, filename); // 日志2：打印具体文件名                    MarkdownDocumentReaderConfig config = MarkdownDocumentReaderConfig.builder()                          .withHorizontalRuleCreateDocument(true) // 按水平线分割文档（没水平线则整个文档为1个Document）                          .withIncludeCodeBlock(false) // 不包含代码块                          .withIncludeBlockquote(false) // 不包含引用块                          .withAdditionalMetadata(&quot;filename&quot;, filename)                          .build();                  MarkdownDocumentReader reader = new MarkdownDocumentReader(resource, config);                  List&lt;Document&gt; docList = reader.get();                  // 日志3：打印当前文档解析后的 Document 数量和内容                  log.info(&quot;文档 &#123;&#125; 解析出 &#123;&#125; 个 Document&quot;,                          filename, docList.size());                  list.addAll(docList);              &#125;              // 日志4：打印总加载量              log.info(&quot;最终加载 Document 总数：&#123;&#125;&quot;, list.size());          &#125; catch (IOException e) &#123;              log.error(&quot;Markdown 文档加载失败&quot;, e);          &#125;          return list;      &#125;  &#125;


新建 VectorStoreConfig 类，实现初始化向量数据库并且保存文档的方法

@Configuration  public class VectorStoreConfig &#123;        @Resource      private DocumentLoader DocumentLoader;        @Bean      VectorStore VectorStore(EmbeddingModel dashscopeEmbeddingModel)&#123;          SimpleVectorStore simpleVectorStore = SimpleVectorStore.builder(dashscopeEmbeddingModel)                  .build();            List&lt;Document&gt; documents = DocumentLoader.loadMarkdowns();          simpleVectorStore.add(documents);          return simpleVectorStore;      &#125;  &#125;

Spring AI 通过⁠ Advisor 特性提供了开箱即用的 RAG 功‌能。主要是 QuestionAnswerAdv​isor 问答拦截器和 RetrievalAug‎mentationAdvisor 检索增强拦截器‌，前者更简单易用、后者更灵活强大。
查询增强的原理其实很简单⁠。向量数据库存储着 AI 模型本身不知道的数据，当用户问题‌发送给 AI 模型时，QuestionAnswerAd​visor 会查询向量数据库，获取与用户问题相关的文档‎。然后从向量数据库返回的响应会被附加到用户文本中，为 ‌AI 模型提供上下文，帮助其生成回答。
@Resourceprivate VectorStore loveAppVectorStore;public String doChatWithRag(String message, String chatId) &#123;    ChatResponse chatResponse = chatClient            .prompt()            .user(message)            .advisors(spec -&gt; spec.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)                    .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10))                        .advisors(new MyLoggerAdvisor())                        .advisors(new QuestionAnswerAdvisor(loveAppVectorStore))            .call()            .chatResponse();    String content = chatResponse.getResult().getOutput().getText();    log.info(&quot;content: &#123;&#125;&quot;, content);    return content;&#125;

云知识库/*  * 自定义基于阿里云知识库服务的 RAG 增强顾问  * */  @Configuration  @Slf4j  public class LoveAppRagCloudAdvisorConfig &#123;        @Value(&quot;$&#123;spring.ai.dashscope.api-key&#125;&quot;)      private String dashScopeApiKey;        @Bean      public Advisor LoveAppRagCloudAdvisor()&#123;          DashScopeApi dashScopeApi = new DashScopeApi(dashScopeApiKey);          final String KNOWLEDGE_INDEX = &quot;知识库名称&quot;;          DashScopeDocumentRetriever dashScopeDocumentRetriever = new DashScopeDocumentRetriever(dashScopeApi,                  DashScopeDocumentRetrieverOptions.builder()                          .withIndexName(KNOWLEDGE_INDEX)                          .build());          return RetrievalAugmentationAdvisor.builder()                  .documentRetriever(dashScopeDocumentRetriever)                  .build();      &#125;  &#125;

@Resource  private VectorStore loveAppVectorStore;  public String doChatWithRag(String message, String chatId)&#123;  	ChatResponse chatResponse = chatClient  			.prompt()  			.user(message)  			.advisors(spec -&gt; spec.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)  					.param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10))  			.advisors(new MyLoggerAdvisor())  			// RAG 知识库问答（本地知识库）  //                .advisors(new QuestionAnswerAdvisor(loveAppVectorStore))  			// 应用 RAG 检索增强服务（基于云知识库服务）  			.advisors(loveAppRagCloudAdvisor)  			.call()  			.chatResponse();  	String text = chatResponse.getResult().getOutput().getText();  	log.info(&quot;text: &#123;&#125;&quot;,text);  	return text;  &#125;


















]]></content>
  </entry>
  <entry>
    <title>超级智能体</title>
    <url>/2025/11/06/articles/AI%E6%99%BA%E8%83%BD%E4%BD%93/%E8%B6%85%E7%BA%A7%E6%99%BA%E8%83%BD%E4%BD%93/</url>
    <content><![CDATA[后端项目初始化环境准备安装的 JDK 版本必须是 21 以上，最好是 21 ，因为支持使用虚拟线程
**不能使用其他版本
新建项目在 IDEA 中新建项目，选择 Spring Boot 模板，注意需要确保 Server URL 为 https://start.spring.io/
![[Pasted image 20251106194511.png]]
Spring Boot 版本选择 3.4.11，然后再顺手选上 SpringWeb 和 Lombok
![[Pasted image 20251106194721.png]]
整合依赖整合 Huto‎ol 工具库和 Kn‌ife4j
Hutool 工具库参考官方文档引入：https://doc.hutool.cn/pages/index/#%F0%9F%8D%8Amaven
在 Maven 的 pom.xml 中添加依赖：
&lt;dependency&gt;      &lt;groupId&gt;cn.hutool&lt;/groupId&gt;      &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;      &lt;version&gt;5.8.37&lt;/version&gt;  &lt;/dependency&gt;

Knife4j 接口文档参考 官方文档 引入，注意这里使用的是 Spring Boot 3.x，不要引入错版本了：

在 Maven 的 pom.xml 中添加依赖：

&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt;


创建 controller 包存放 API 接口，编写一个健康检查接口用于测试是否能够正常引入：

@RestController  @RequestMapping(&quot;/health&quot;)  public class HealthController &#123;        @GetMapping      public String HealthCheck() &#123;          return &quot;ok&quot;;      &#125;  &#125;


根据官网文档在 application.yml 中追加接口文档配置，并且扫描 controller 包
注意：包扫描那里是 &#x3D;&#x3D;.&#x3D;&#x3D; 不是 &#x3D;&#x3D;&#x2F;&#x3D;&#x3D;



spring:    application:      name: super-ai-agent  server:    port: 8123    servlet:      context-path: /api  # springdoc-openapi项目配置  springdoc:    swagger-ui:      path: /swagger-ui.html      tags-sorter: alpha      operations-sorter: alpha    api-docs:      path: /v3/api-docs    group-configs:      - group: &#x27;default&#x27;        paths-to-match: &#x27;/**&#x27;        packages-to-scan: com.example.superaiagent.controller  # knife4j的增强配置，不需要增强可以不配  knife4j:    enable: true    setting:      language: zh_cn


启动项目，访问 http://localhost:8123/api/doc.html 能够看到接口文档，可以测试调用接口：

![[Pasted image 20251106203306.png]]
]]></content>
  </entry>
  <entry>
    <title>复习智能体搭建</title>
    <url>/2025/11/06/articles/AI%E6%99%BA%E8%83%BD%E4%BD%93/%E5%A4%8D%E4%B9%A0%E6%99%BA%E8%83%BD%E4%BD%93%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[程序调用 AI 大模型SDK 接入首先需要按照官方文档安装 SDK：安装SDK官方指南
在选择 SDK 版本时，建议在 Maven 仓库查看最新的版本号：Maven 中央仓库版本信息

在 pom.xml 中引入依赖：

&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dashscope-sdk-java&lt;/artifactId&gt;    &lt;version&gt;2.19.1&lt;/version&gt;&lt;/dependency&gt;


创建一个接口类​来存储密钥信息（在‎实际生产环境中，应‌使用配置文件或环境变量）
public interface TestApiKey &#123;    String API_KEY = &quot;你的 API Key&quot;;&#125;

复制文档里面的代码进行测试 通过 API 调用通义千问


package com.example.superaiagent.demo.invoke;// 建议dashscope SDK的版本 &gt;= 2.12.0import java.util.Arrays;  import java.lang.System;  import com.alibaba.dashscope.aigc.generation.Generation;  import com.alibaba.dashscope.aigc.generation.GenerationParam;  import com.alibaba.dashscope.aigc.generation.GenerationResult;  import com.alibaba.dashscope.common.Message;  import com.alibaba.dashscope.common.Role;  import com.alibaba.dashscope.exception.ApiException;  import com.alibaba.dashscope.exception.InputRequiredException;  import com.alibaba.dashscope.exception.NoApiKeyException;  import com.alibaba.dashscope.utils.JsonUtils;    /*  * 阿里云灵积 AI SDK 调用  * */  public class SdkAiInvoke &#123;      public static GenerationResult callWithMessage() throws ApiException, NoApiKeyException, InputRequiredException &#123;          Generation gen = new Generation();          Message systemMsg = Message.builder()                  .role(Role.SYSTEM.getValue())                  .content(&quot;You are a helpful assistant.&quot;)                  .build();          Message userMsg = Message.builder()                  .role(Role.USER.getValue())                  .content(&quot;你是谁？&quot;)                  .build();          GenerationParam param = GenerationParam.builder()                  // 若没有配置环境变量，请用百炼API Key将下行替换为：.apiKey(&quot;sk-xxx&quot;)                  .apiKey(TestApiKey.API_KEY)                  // 此处以qwen-plus为例，可按需更换模型名称。模型列表：https://help.aliyun.com/zh/model-studio/getting-started/models                  .model(&quot;qwen-plus&quot;)                  .messages(Arrays.asList(systemMsg, userMsg))                  .resultFormat(GenerationParam.ResultFormat.MESSAGE)                  .build();          return gen.call(param);      &#125;      public static void main(String[] args) &#123;          try &#123;              GenerationResult result = callWithMessage();              System.out.println(JsonUtils.toJson(result));          &#125; catch (ApiException | NoApiKeyException | InputRequiredException e) &#123;              // 使用日志框架记录异常信息              System.err.println(&quot;An error occurred while calling the generation service: &quot; + e.getMessage());          &#125;          System.exit(0);      &#125;  &#125;

HTTP 接入
对于 SD⁠K 不支持的编程语言‌或需要更灵活控制的场​景，可以直接使用 H‎TTP 请求调用 A‌I 大模型的 API
一⁠般来说，如果有官方 SDK 支持，优‌先使用 SDK；只有在不支持 SDK​ 的情况下，再考虑直接 HTTP 调用‎
HTTP 调用的详细说明可参考官方文档：通过 API 调用通义千问

package com.example.superaiagent.demo.invoke;    import cn.hutool.http.HttpRequest;  import cn.hutool.http.HttpResponse;  import cn.hutool.json.JSONArray;  import cn.hutool.json.JSONObject;    /*   * 阿里云灵积 AI Http 调用   * */public class HttpAiInvoke &#123;        public static void main(String[] args) &#123;          // 替换为您的API密钥          String apiKey = TestApiKey.API_KEY;            // 构建请求URL          String url = &quot;https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions&quot;;            // 构建请求体          JSONObject requestBody = new JSONObject();          requestBody.put(&quot;model&quot;, &quot;qwen-plus&quot;);                    // 构建messages数组          JSONArray messages = new JSONArray();                    // system消息          JSONObject systemMessage = new JSONObject();          systemMessage.put(&quot;role&quot;, &quot;system&quot;);          systemMessage.put(&quot;content&quot;, &quot;You are a helpful assistant.&quot;);          messages.add(systemMessage);                    // user消息          JSONObject userMessage = new JSONObject();          userMessage.put(&quot;role&quot;, &quot;user&quot;);          userMessage.put(&quot;content&quot;, &quot;你是谁？&quot;);          messages.add(userMessage);                    requestBody.put(&quot;messages&quot;, messages);            try &#123;              // 发送POST请求              HttpResponse response = HttpRequest.post(url)                      .header(&quot;Authorization&quot;, &quot;Bearer &quot; + apiKey)                      .header(&quot;Content-Type&quot;, &quot;application/json&quot;)                      .body(requestBody.toString())                      .execute();                // 打印响应结果              System.out.println(&quot;响应状态码: &quot; + response.getStatus());              System.out.println(&quot;响应内容: &quot; + response.body());            &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;

Spring A‌I
Spring AI 默认没有支持所有的大模型（尤其是国产的），更多的是支持兼容 OpenAI API 的大模型的集成

理论上来说只要兼容 OpenAI API 的大模型都能在这里使用

推荐直接使用阿里自主封装的 Spring AI Alibaba 框架，它不仅能直接继承阿里系大模型，用起来更方便，而且与标准的 Spring AI 保持兼容

引入依赖：

如果只是想使用 ChatClient 开发一个简单的单智能体或者聊天助手，则只需要加入 spring-ai-alibaba-starter-dashscope 依赖
如果需要使用工作流或多智能体，则需要加入 spring-ai-alibaba-graph-core 依赖。



&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud.ai&lt;/groupId&gt;    &lt;artifactId&gt;spring-ai-alibaba-starter&lt;/artifactId&gt;    &lt;version&gt;1.0.0.2&lt;/version&gt;&lt;/dependency&gt;


编写配置

spring:  application:    name: spring-ai-alibaba-qwq-chat-client-example  ai:    dashscope:      api-key: $&#123;AI_DASHSCOPE_API_KEY&#125;      chat:        options:          model: qwen-plus


运行代码

@Component  public class SpringAiAiInvoke implements CommandLineRunner &#123;        @Resource      private ChatModel chatModel;        @Override      public void run(String... args) throws Exception &#123;          String text = chatModel.call(new Prompt(&quot;你好，我是呵帅&quot;))                  .getResult()                  .getOutput()                  .getText();          System.out.println(text);      &#125;  &#125; 







]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/14/articles/JavaScript/text/</url>
    <content><![CDATA[JavaScript概述JavaScript是一门世界上流行的脚本编程语言，用来实现网页上的交互，实时更新内容等。
JavaScript的创建者因不喜欢Java，只想应付公司的任务，因此只花了十天时间就把JavaScript创建出来了。
Hello World每个语言都有其独特之处，身边人也经常会开玩笑的说“我们精通各种语言的Hello World”。
JavaScript和CSS一样，都可以直接在HTML文件里面搭个标签，在标签里面写语言。
方法一：内标签写与Java相同，在写JavaScript时不要忘记每一行命令后的分号。注释也和Java中使用的一样。
方法二：外部引用首先，先创建一个JavaScript文件，里面只需写需要的JavaScript语句，然后再在HTML文件中引入进来即可。注意，使用script标签必须成对出现，尽量不要用自闭合。
运行结果：
基础语法JavaScript和一门弱类型语言，跟python或者其他解释型语言一样，无需强调其变量类型。

JavaScript语法与Java基本吻合，也是严格区分大小写，但JavaScript不强制限定语句末一定要使用分号，如果有两条语句，其中没有分号，则视为一条语句，一般使用上省略一两个分号对代码没有太大影响，但依然建议写上分号。
浏览器调试在浏览器上打开文件后，可以点击F12打开审查元素，在源代码那里可以看到自己的代码并进行调试。

简单数据类型变量JS和Java的命名规则一样，用字母数字下划线和$组成的变量名，不可以用数字开头，可以用中文。
var 变量名 = 值

numberjs不区分整数和小数
123      //整数123.4    //小数-1.234   //负数1.23e4   //科学计数法除此之外还有NaN      //Not a numberInfinity //表示无穷大，数据太大JavaScript处理不来
比较运算符=      //赋值==     //等于(类型不一样，值一样，判断为true)===    //绝对等于(类型一样，值一样，判断为true)一般情况下尽量使用绝对等于
上面提到的NaN与所有数值都不相等，包括自己，只能通过isNaN来判断NaN才为true
尽量避免使用浮点数进行运算，存在精度丢失问题
console.log((1/3) === (1-2/3))答案为false但我们可以使用绝对值来比较Math.abs(1/3 - (1-2/3)) &lt; 0.000000000001

Null和undefinednull     //空undefined//未定义

数组一般在Java中数组每个元素的类型必须一致，但在JS中可以不用
var a = [1,2,3,4,&#x27;Hello&#x27;,null,false];
数组越界会显示undefined
对象在Java中对象是new出来的，但在JS中生成或定义基本上都是使用var，每个属性之间使用逗号隔开，最后一个属性后不需要加逗号。
对象是大括号，数组是中括号。

严格检查模式在我们书写代码时，会发现有时候不严谨的写法依然不会报错而导致无法运行。
例如在代码中直接写上 i = 1 如同python一样，但这时候i定义成是全局变量，以至于在其他JS文件中依然可以调用到这个变量，因此我们得想办法约束一下自己代码书写的严谨性。
我们在第一行写上 &quot;use strict&quot; (引号不能丢) __严格检查模式__，开启后如果出现以上 i = 1 的写法会直接报错，提升了代码的严谨性。
严格检查模式 一般写在JS文件 (或者标签内) 的第一行写上，在其他地方写上在运行文件的时发现错误会报错，但在浏览器里调试中不会发生报错。
字符串JS字符串可以用 单引号 或者 双引号 包裹，如果想输出引号，我们可以使用 ‘ \ ‘ 转义符来进行转义引号。
常用的转义符:\&#x27;\&quot;\t      # 等效于tab键\u4e2d  # &#x27;中&#x27;，Unicode字符，一般为\u####\x41    # &#x27;A&#x27;，ASCLL字符

多行字符串编写如果希望进行多行字符串编写，我们可以使用两个 `  包裹起来
var 变量名 = `        内容        内容        .....`
或者我们在希望换行的位置打上换行符 \n 进行换行
字符串拼接在JS里，字符串拼接最常见有两种方式
var a = &quot;abc&quot;;var b = &quot;cba&quot;;方式一：    用加号来拼接字符串    console.log(&quot;abc&quot;+&quot;cba&quot;);    # abccba    console.log(a+b);            # abccba方式二：    在字符串中穿插 &#x27;$&#123;变量名&#125;&#x27;    console.log(`早上好！$&#123;a&#125;`)   # 早上好！abc                                  # 注意，括号内使用的是 ` 号

字符串长度var a = &quot;abc&quot;;console.log(abc.length);   # 3

字符串的可变性var a = &quot;abcdef&quot;;console.log(a[1]);         # ba[1] = &#x27;b&#x27;;                # 这里尝试把&#x27;b&#x27;赋值给a[1]                           # 没有显示报错，赋值完成console.log(a[1])          # a                           # 发现虽然赋值完成，但值没有改变，赋值失败

字符串截取var a = &quot;abcdef&quot;;console.log(a.subString(1))      # bcdef   从下标1开始一直到最后console.log(a.subString(1,3))    # bc      从下标1开始，到下标3结束(不包括下标3)字符串截取是&#x27;[)&#x27;包左不包右注意，当 &#x27;.&#x27;后面有括号说明是方法而不是属性

数组数组Array可以包含任意的数据类型
var arr01 = [1,2,3,4,5,6,7,8,9]; # 可以通过数组下标进行取值和赋值 console.log(arr01);              # [1, 2, 3, 4, 5, 6, 7, 8, 9]arr01[0] = 0;console.log(arr01);              # 0, 2, 3, 4, 5, 6, 7, 8, 9]

长度arr01.length
注意，我们可以给arr01.length进行赋值，赋值后会改变数组的长度，如果赋的值大于原来，则以empty补全，如果赋的值小于原来，则超过的下标元素丢失，一般不建议去修改数组长度。
indexof()我们可以用indexof()通过元素获得第一个元素出现的下标
arr01.indexof(1)
注意：字符串1和数字1是不一样的
slice()slice()用来截取数组的一部分，返回一个新的数组
数组名.slice(3)     # 从下标3开始到最后数组名.slice(1,3)   # 从下表1开始到下标3结束，不包括下标3，类似于String中的subString()

push()、pop()尾部push()   压入到尾部pop()    从尾部弹出一个元素

unshift()、shift()头部unshift()   压入到头部、shift()    从头部弹出一个元素

排序sort()[&#x27;B&#x27;,&#x27;A&#x27;,&#x27;C&#x27;];arr.sort();[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]

元素反转reverse()[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];arr.reverse();[&#x27;C&#x27;,&#x27;B&#x27;,&#x27;A&#x27;]

数组拼接concat()# [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];arr.concat([1,2,3]);# [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,1,2,3];console.log(arr);# [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]
注意：concat()并没有修改数组，而是返回一个新的数组
连接符join()[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];arr.join(&#x27;-&#x27;);&quot;A-B-C&quot;

对象定义对象在JS中，对象就是由若干个键值对组成的JS中所有的键都是字符串，值可以是任意类型！
var 类名 = &#123;    属性名:值,    属性名:值,    属性名:值,    属性名:值&#125;
定义对象中每个属性用逗号隔开，最后一个属性不加逗号
对象赋值对象名.属性名 = 值;
注意，使用一个不存在的属性不会报错
动态的删减属性通过delete删除对象的属性
delete 对象名.属性名

动态的添加属性直接给想要添加的属性名赋值即可
对象名.属性名 = 值

判断属性值是否在这个对象中属性名 in 对象名
注意：JS中属性名都为字符串，判断时要加上引号
我们在Java中对象一般都会设一个toString方法，在JS检查属性值时会发现，toString也在本对象中，这是因为继承性，JS和Java一样，对象都是默认继承object，属性也会一同继承下来。
hasOwnProperty()如果我们只想看本对象中，不想看到继承下来的属性，我们可以使用hasOwnProperty()
对象名.hasOwnProperty(属性名)

流程控制个人认为本质上和Java的流程判断没区别
if判断var age = 18;if(age &gt; 18)&#123;    console.log(&quot;成年了&quot;);&#125;else if(age === 18)&#123;    console.log(&quot;刚成年&quot;);&#125;else &#123;    console.log(&quot;未成年&quot;);&#125;

while判断var a = 0;while(a &lt; 100)&#123;    a = a + 1;    console.log(a);&#125;var b = 0;do&#123;    b = b + 1;    console.log(b);&#125;while(b &lt; 100)

for循环for(let i = 0; i &lt; 100; i++)&#123;    console.log(i);&#125;

for in 循环var arr = [1,2,3,4,5,6,7,8,9];# for(var 下标 in 容器)for(var num in arr)&#123;    console.log(arr[num]);&#125;

for of 循环for of和上面的for in 相似，for in产生的变量是下标，for of产生的变量是数值但是for of不会遍历出手动添加的值，但for in会
for(var num of arr)&#123;    console.log(num);&#125;

forEach循环var age = [1,23,4,5,6,7,8];age.forEach(function (value)&#123;    console.log(value);&#125;)

Map 和 SetMapJS里和Java里Map使用方法一样，键是唯一的，值不是唯一的
var map = new Map([[&quot;tom&quot;,99],[&quot;jerry&quot;,98],[&quot;alice&quot;,95],[&quot;bob&quot;,96]]);// get方法通过键来找到值console.log(map.get(&quot;tom&quot;));// set方法添加或者修改键值对map.set(&quot;hhhhh&quot;,100);// delete方法删除键值对map.delete(&quot;tom&quot;);
个人感觉JS里面Map和上面提到的对象很相似，都是多对键值对，但不同处在于对象的键只能是字符串，而Map的键可以是任意类型
可以通过for of来遍历
var map = new Map([[&quot;tom&quot;,99],[&quot;jerry&quot;,98],[&quot;alice&quot;,95],[&quot;bob&quot;,96]]);for(var x of map)&#123;    console.log(x);&#125;
SetSet：无序不重复的集合无序并不是说没有顺序，而是说没有像数组一样的索引
var set = new Set([1,2,3,3,3,3,3,3]) set.add(2);                          //添加元素set.delete(1);                       //删除元素set.has(3);                          //判断是否包含
Set也可以通过for of来遍历
var set = new Set([1,2,3,3,3,3,3,3]) for(var x of set)&#123;    console.log(x);&#125;

函数函数的定义__方式__：
function MyAbs(x)&#123;    if(x &gt;= 0)&#123;        return x;    &#125;else&#123;        return -x;    &#125;&#125;
跟其他语言一样，执行到 return 即代表函数结束，无法运行 return 后面的代码如果没有执行 return ，函数执行完也会返回结果 undefined
__方式二__：
var MyAdd = function(a,b)&#123;    return a+b;&#125;
function(a,b){…}是一个匿名函数。可以把结果赋值，通过被赋值名来调用函数
方式一和方式二等价
调用函数函数名(参数1,参数2,参数3....)
在调用函数的时候会发现一件事，你可以传任意多个参数，不会报错
如果我们只想接收一个参数，传多个参数就是非法调用，这种情况我们可以使用 arguments 
例如：
var MyAdd = function(a,b)&#123;    if(arguments.length !== 2)&#123;        throw &quot;Not a Number&quot;    &#125;    return a+b;&#125;
arguments 是参数接收值的数组，每个方法内都有，用来存储每个方法的接收值
可变参数rest用数组来接收函数体已经定义的参数之外的参数例如：
function abbb(a,b,...rest)&#123;    函数体.....&#125;abbb(1,2,3,4,5,6,7,8)       # 调用函数，传参                         # a === 1                         # b === 2                         rest = [3,4,5,6,7,8]
rest参数只能写在参数最后，前面必须要有...表示
变量的作用域thisJS里，如果我们在函数外和函数内都定义了一个同名的变量，我们将如何区分
首先，JS和Java一样，遇到相同的变量名时会优先调用最近的(最近原则)，在函数里面调用，则会优先调用到函数里面的变量，如果希望调用函数外的，我们可以用关键字this
var a = 10;function test() &#123;    var a = 20;    console.log(this.a);    console.log(a);    console.log(&quot;====================&quot;);&#125;console.log(a);test();a = 30;console.log(a);test();

var和let在之前写代码时会发现，我们无论在变量或者是函数前，都会加一个var或者let，var和let有什么区别呢？
一开始我也分不清楚，后来查资料也懵懵懂懂，后来多写几行代码就有更深一点的领悟。
var 一般是用在全局作用域，而let用在局部作用域，什么是作用域，个人见解，每一个 &#123;&#125; 花括号括起来就是一个作用域比如上面的this中的代码，我们在函数外部和函数内部都定义一个全局变量a，我们在函数内是能通过this或者window来调用到函数外的a注：window只能调用全局变量，无法调用局部变量但是如果我们用的是let定义的局部变量，我们会发现在函数内也无法调用到函数外的a
let a = 10;function test() &#123;    let a = 20;    console.log(window.a);    console.log(a);    console.log(&quot;====================&quot;);&#125;console.log(a);test();a = 30;console.log(a);test();

常量const有变量肯定也有常量，我们在编写代码的时候也希望有些值不允许被改变
const 变量名 = 值
用const修饰后的变量名是不允许被修改的
方法函数定义在对象外就是函数，定义在对象内就是方法
var hh = &#123;       name : &quot;hs&quot;,       ahe : 18,       birth : 2005,       // 方法       age : function()&#123;           return new Date().getFullYear() - this.birth;       &#125;&#125;// 属性hh.name;// 方法hh.age();

applyapply感觉像是Java里的反射，在JS中任何方法都用apply的属性
方法名.apply(对象名,参数)      # 参数用数组装，没有参数就传[]
例如
function getAge()&#123;    return new Date().getFullYear() - this.birth;&#125;var hh = &#123;    name : &quot;hs&quot;,    ahe : 18,    birth : 2005,    age : getAge&#125;
我们可以用 hh.age()，也可以用 getAge.apply(hh,[])
JSONJSON是什么JSON（JavaScript Object Notation，JavaScript对象表示法）JSON是一种常用的数据格式，在电子数据交换中有多种用途，包括与服务器之间的Web应用程序的数据交换。其简洁和清晰的层次结构有效地提升了网络传输效率，使其成为理想的数据交换语言。其文件通常使用扩展名.json。
JSON字符串和JS对象的转换格式：
对象和方法用  &#123;&#125;数组用       []键值对用     key:value
var person = &#123;            name: &quot;John&quot;,            age: 30,            city: &quot;New York&quot;        &#125;        // 对象转换为JSON字符串        var json = JSON.stringify(person);        console.log(json)        // JSON字符串转换为对象        var obj =JSON.parse(json);        console.log(obj)        // 也可以用 JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#x27;)

面向对象在其他语言中，说起对象就想起类，类是模板，对象是实体，继承等等在之前JS里还没有继承，但是有这个概念，于是出现了原型
A对象.__proto__ = B对象A对象的原型是B对象于是乎A对象就能使用B对象里面的属性

class在ES6版本后，加入了一个新的关键字class跟Java的区别在于构造器，在JS的class里，构造器是 constructor 
class person01 &#123;    constructor(name, age)&#123;    this.name = name;    this.age = age;    &#125;    run() &#123;        console.log(this.name + &quot; is running&quot;);    &#125;&#125;var xiaoming = new person01(&quot;xiaoming&quot;, 25);var xiaohong = new person01(&quot;xiaohong&quot;, 20);
而且，在类里面构建的方法不需要在方法名前面加var
继承class 子类名 extend 父类名&#123;    constructor(参数)&#123;        super()    &#125;&#125;
例如：
class person02 extends person01 &#123;    constructor(name, age, sex) &#123;        super(name, age);        this.sex = sex;    &#125;    sayHello() &#123;        console.log(&quot;Hello, my name is &quot; + this.name + &quot; and I am a &quot; + this.sex);    &#125;&#125;
我们可以在浏览器调试中看到其实所谓的继承还是原型，我们能看到原型链，原型的尽头还是object
操作BOM对象BOM：Browser Object Model（浏览器对象模型）类似的还有一个叫 DOM : 是将HTML文档中的各个元素封装成一个对象，而 BOM 则是将一个浏览器的各个组成部分封装成对象供调用使用。
JavaScript诞生的目的就是为了能够在浏览器上运行
windowwindow对象代表着浏览器窗口
window.alert(1)undefinedwindow.innerHeight358window.innerWidth1659window.outerWidth1707window.outerWidth1707

navigatornavigator对象代表浏览器的信息
appName    # 浏览器的官方名称。通常是&quot;Netscape&quot;，           # 这是因为Netscape是第一个支持JavaScript的浏览器。appVersion # 提供了浏览器版本信息userAgent  # 浏览器的用户代理字符串platform   # 运行浏览器的操作系统平台
一般不建议使用 navigator 对象，因为里面的信息会被人为修改
screenscreen代表屏幕尺寸
screen.width1707 pxscreen.height960 px

locationlocation代表当前网页的URL信息
host: &quot;ntp.msn.cn&quot;protocol: &quot;https:&quot;reload: ƒ reload()    // 刷新网页

documentdocument代表当前的页面，HTML，DOC文档树
document.title&#x27;新建标签页&#x27;document.title = &#x27;呵帅&#x27;&#x27;呵帅&#x27;
cookie劫持原理，引了一个含有获取cookie的文件
// 获取cookiedocument.cookie

historyhistory代表浏览器的历史记录
// 后退history.back()// 前进history.forward()

操作DOM对象DOM：文档对象模型
浏览器网页就是一个DOM树形结构，我们只需要做1、更新：更新DOM节点2、遍历：遍历每个DOM节点3、删除：删除DOM节点4、增加：增加DOM节点
乍一看像前端版的增删改查
获取DOM节点&lt;div id=&quot;father&quot;&gt;    &lt;h1&gt;标题&lt;/h1&gt;    &lt;p id=&quot;p1&quot;&gt;段落&lt;/p&gt;    &lt;p class=&quot;p2&quot;&gt;段落&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    //对应CSS选择器    var h1 =document.getElementsByName(&#x27;h1&#x27;);    var p = document.getElementsByName(&#x27;p&#x27;);    var div = document.getElementsByName(&#x27;div&#x27;);    var father = document.getElementById(&#x27;father&#x27;);    var p2 = document.getElementsByClassName(&#x27;p2&#x27;);    var p1 =document.getElementsByTagName(&#x27;p1&#x27;)&lt;/script&gt;
可以用 getElementsByName 通过属性名，或者 getElementById 通过选择器
更新节点&lt;div id = &#x27;id1&#x27;&gt;&lt;/div&gt;&lt;script&gt;    var id1 = documents.getElementById(&#x27;id1&#x27;);&lt;/script&gt;
操作文本
id1.innerText=&#x27;123456&#x27;;id1.innerHTML=&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;innerText和innerHTML的区别：innerText修改文本的值innerHTML可以解析HTML语句
操作JS
id1.style.color = &#x27;red&#x27;&#x27;red&#x27;id1.style.fontSize = &#x27;20px&#x27;&#x27;20px&#x27;id1.style.padding = &#x27;30px&#x27;&#x27;30px&#x27;

删除节点删除节点得先获取父节点，然后通过父节点删除
方法一
&lt;div id=&quot;father&quot;&gt;    &lt;h1&gt;标题&lt;/h1&gt;    &lt;p id=&quot;p1&quot;&gt;段落&lt;/p&gt;    &lt;p class=&quot;p2&quot;&gt;段落&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var p1 = documents.getElementById(&#x27;p1&#x27;);    var father = p1.parentElement;    father.removeChild(p1)&lt;/script&gt;
方法二
&lt;div id=&quot;father&quot;&gt;    &lt;h1&gt;标题&lt;/h1&gt;    &lt;p id=&quot;p1&quot;&gt;段落&lt;/p&gt;    &lt;p class=&quot;p2&quot;&gt;段落&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    father.removeChild(father.children[0]);    father.removeChild(father.children[0]);    father.removeChild(father.children[0]);&lt;/script&gt;
注意：每次删除的时候，children都是在变化的
表单获取表单的值表单有很多种：文本框、下拉框、选项框、密码框、隐藏框等等
&lt;p&gt;    &lt;span&gt;输入内容:&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;&lt;/p&gt;&lt;p&gt;    &lt;span&gt;性别:&lt;/span&gt;    &lt;input type=&quot;radio&quot; value=&quot;man&quot; name=&quot;sex&quot; id=&quot;boy&quot;&gt; 男    &lt;input type=&quot;radio&quot; value=&quot;woman&quot; name=&quot;sex&quot; id=&quot;girl&quot;&gt; 女&lt;/p&gt;&lt;script&gt;    var input_text = document.getElementById(&#x27;input&#x27;);    var boy_radio = document.getElementById(&#x27;boy&#x27;);    var girl_radio = document.getElementById(&#x27;girl&#x27;);&lt;/script&gt;
文本框我们会取其document然后用.value获得值如果是选项框一般则会用 .check来判断是否被选择
input_text.value&#x27;123456&#x27;input_text.value = 456789456789boy_radio.value&#x27;man&#x27;girl_radio.value&#x27;woman&#x27;boy_radio.checkedtruegirl_radio.checkedfalse

表单提交验证及加密在button中我们可以自定义按下按钮的触发效果
&lt;p&gt;    请输入用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/p&gt;&lt;p&gt;    请输入密码 ：&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/p&gt;&lt;!--绑定事件 onclick--&gt;&lt;button type=&quot;button&quot; onclick=&quot;submit()&quot;&gt;提交&lt;/button&gt;&lt;script&gt;    function submit() &#123;        var username = document.getElementById(&quot;username&quot;);        var password = document.getElementById(&quot;password&quot;);        console.log(username.value);        console.log(password.value);    &#125;&lt;/script&gt;
在平时使用的时候都是输入完按下提交按钮，数据就会被提交到数据库上面，但这样还是有一点隐患，非常容易被抓包，导致数据都被明文曝光，我们可以使用MD5加密
document名.value = md5(document名.value)
世上没有不透风的强，再怎么加密依然有曝光的风险，平时项目中建议在后端进行加密，不要在前端做加密
jQueryjQuery下载目前jQuery官网直接打开不是文件而是原码我们在官网上点开 download点击 download jQuery然后我们会发现一整个网页都是字符，不要怀疑自己，这就是官网方法一：我们在项目的位置新建一个 .txt 文件，把网页的内容 Ctrl+a 全部复制到txt文件内，修改后缀为 .js 然后倒入进项目里
方法二：右键另存为，就是一个 .js 文件了
或者，我们在网上查找jQuery的CDN，直接搜索就行，引入在线CND，就不需要去官网下载了
导入&lt;script scr=&quot;lib/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
直接在head最下面插入导入语句
实践在网页上画一个小块，当鼠标在块中时可以显示鼠标在块内的坐标
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        #div1 &#123;            width: 500px;            height:500px;            border: 1px solid red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;    &lt;div id=&quot;div1&quot;&gt;        移动区域    &lt;/div&gt;    &lt;script&gt;        $(document).ready(function ()&#123;            $(&quot;#div1&quot;).mousemove(function (e)&#123;                $(&quot;#span1&quot;).text(&quot;x&quot;+e.pageX+&quot;y&quot;+e.pageY);            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
效果：
]]></content>
  </entry>
  <entry>
    <title>快速上手LangChain4j</title>
    <url>/2025/07/04/articles/AI/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BLangChain4j/</url>
    <content><![CDATA[LangChain4j入门创建一个Maven项目创建空项目并且导入依赖&lt;properties&gt;      &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;      &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;      &lt;spring-boot.version&gt;3.2.6&lt;/spring-boot.version&gt;      &lt;knife4j.version&gt;4.3.0&lt;/knife4j.version&gt;      &lt;mybatis-plus.version&gt;3.5.11&lt;/mybatis-plus.version&gt;      &lt;langchain4j.version&gt;1.0.0-beta3&lt;/langchain4j.version&gt;  &lt;/properties&gt;&lt;dependencies&gt;	&lt;!-- web应用程序核心依赖 --&gt;	&lt;dependency&gt;		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;	&lt;/dependency&gt;	&lt;!-- 编写和运行测试用例 --&gt;	&lt;dependency&gt;		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;		&lt;scope&gt;test&lt;/scope&gt;	&lt;/dependency&gt;	&lt;!-- 前后端分离中的后端接口测试工具 --&gt;	&lt;dependency&gt;		&lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;		&lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;		&lt;version&gt;$&#123;knife4j.version&#125;&lt;/version&gt;	&lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;	&lt;dependencies&gt;		&lt;!--引入SpringBoot依赖管理清单--&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;			&lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;			&lt;type&gt;pom&lt;/type&gt;			&lt;scope&gt;import&lt;/scope&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;&lt;/dependencyManagement&gt;

配置文件先随便写点，写个端口让他跑起来先
application.properties
# web 服务端口  server.port=8080


启动类注意写 @SpringBootApplication
@SpringBootApplication  public class Main &#123;      public static void main(String[] args) &#123;          SpringApplication.run(Main.class, args);      &#125;  &#125;

启动启动类访问 http://localhost:8080/doc.html 查看程序能否成功运行
接入大模型参考文档： https://docs.langchain4j.dev/get-started
导入依赖&lt;!-- 基于open-ai的langchain4j接口：ChatGPT、deepseek都是open-ai标准下的大模型 --&gt;  &lt;dependency&gt;      &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;      &lt;artifactId&gt;langchain4j-open-ai&lt;/artifactId&gt;      &lt;version&gt;1.1.0&lt;/version&gt;  &lt;/dependency&gt; &lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;!--引入langchain4j依赖管理清单--&gt;        &lt;dependency&gt;            &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;            &lt;artifactId&gt;langchain4j-bom&lt;/artifactId&gt;            &lt;version&gt;$&#123;langchain4j.version&#125;&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt; &lt;/dependencyManagement&gt;

创建测试用例@SpringBootTest  public class LangChain4jTest &#123;        @Test      public void testGPTDemo() &#123;          OpenAiChatModel model = OpenAiChatModel.builder()                  .baseUrl(&quot;http://langchain4j.dev/demo/openai/v1&quot;)                  .apiKey(&quot;demo&quot;)                  .modelName(&quot;gpt-4o-mini&quot;)                  .build();            String answer = model.chat(&quot;你是谁呀&quot;);          System.out.println(answer);      &#125;  &#125;

SpringBoot整合参考文档： https://docs.langchain4j.dev/tutorials/spring-boot-integration
替换依赖连接Springboot依赖是 langchain4j-&#123;integration-name&#125;-spring-boot-starter
我们这将原来的 langchain4j-open-ai 替换成 langchain4j-open-ai-spring-boot-starter
&lt;!-- 基于open-ai的langchain4j接口：ChatGPT、deepseek都是open-ai标准下的大模型 --&gt;  &lt;dependency&gt;      &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;      &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt;

编写配置文件# web 端口  server.port=8080    langchain4j.open-ai.chat-model.base-url=http://langchain4j.dev/demo/openai/v1  langchain4j.open-ai.chat-model.api-key=demo  langchain4j.open-ai.chat-model.model-name=gpt-4o-mini  # 应用程序发送给大模型的请求日志和响应日志  langchain4j.open-ai.chat-model.log-requests=true  langchain4j.open-ai.chat-model.log-responses=true  # 设置系统日志为debug级别  logging.level.root=debug

创建测试用例@Autowired  private OpenAiChatModel openAiChatModel;    @Test  public void testSpringBoot() &#123;      String answer = openAiChatModel.chat(&quot;我是谁？&quot;);      System.out.println(answer);  &#125;


介入其他大模型大模型排行榜 https://superclueai.com/
LangChain4j支持接入的大模型 https://docs.langchain4j.dev/integrations/language-models/
注：deepseek和openAI使用的都是同一套标准，所以后续deepseek使用的是openAI的接口
接入DeepSeek获取开发参数
访问官网： https://www.deepseek.com/ 右上角有个API 开放平台注册账号，注册后获取base_url（在接口文档找到）和api_key

* deepseek-chat 模型指向 DeepSeek-V3-0324， 通过指定 model=&#39;deepseek-chat&#39; 调用。
* deepseek-reasoner 模型指向 DeepSeek-R1-0528， 通过指定 model=&#39;deepseek-reasoner&#39; 调用。
修改配置文件# web 端口  server.port=8080    langchain4j.open-ai.chat-model.base-url=https://api.deepseek.com  langchain4j.open-ai.chat-model.api-key=[API key]langchain4j.open-ai.chat-model.model-name=deepseek-chat  # 应用程序发送给大模型的请求日志和响应日志  langchain4j.open-ai.chat-model.log-requests=true  langchain4j.open-ai.chat-model.log-responses=true  # 设置系统日志为debug级别  logging.level.root=debug

接入ollama在ollama上部署DeepSeek官网：https://ollama.com/

下载并安装ollama： OllamaSetup.exe
查看模型列表，选择要部署的模型，模型列表： https://ollama.com/search
执行命令：ollama run deepseek-r1:1.5b 运行大模型

引入依赖&lt;!-- 接入ollama --&gt; &lt;dependency&gt;	 &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;	 &lt;artifactId&gt;langchain4j-ollama-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;

修改配置文件langchain4j.ollama.chat-model.base-url=http://localhost:11434  langchain4j.ollama.chat-model.model-name=deepseek-r1:1.5b  langchain4j.ollama.chat-model.log-requests=true  langchain4j.ollama.chat-model.log-responses=true
创建测试用例@Autowired  private OllamaChatModel ollamaChatModel;    @Test  public void testOllama() &#123;      String answer = ollamaChatModel.chat(&quot;你是谁？&quot;);      System.out.println(answer);  &#125;

接入阿里百炼
支持接入的模型列表： https://help.aliyun.com/zh/model-studio/models 
模型广场： https://bailian.console.aliyun.com/?productCode=p_efm#/model-market

导入依赖LangChain4j参考文档： https://docs.langchain4j.dev/integrations/language-models/dashscope#plain-java
&lt;!-- 接入阿里云百炼平台 --&gt;  &lt;dependency&gt;      &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;      &lt;artifactId&gt;langchain4j-community-dashscope-spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt;		&lt;!--引入百炼依赖管理清单--&gt;		&lt;dependency&gt;			&lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;			&lt;artifactId&gt;langchain4j-community-bom&lt;/artifactId&gt;			&lt;version&gt;$&#123;langchain4j.version&#125;&lt;/version&gt;			&lt;type&gt;pom&lt;/type&gt;			&lt;scope&gt;import&lt;/scope&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;&lt;/dependencyManagement&gt;

修改配置文件#阿里百炼平台langchain4j.community.dashscope.chat-model.api-key=API_KEYlangchain4j.community.dashscope.chat-model.model-name=qwen-max

测试通义千问@Autowired  private QwenChatModel qwenChatModel;    @Test  public void testDashScopeQwen() &#123;      String chat = qwenChatModel.chat(&quot;你是谁&quot;);      System.out.println(chat);  &#125;

测试通义万象@Test  public void testDashScopeWanx() &#123;      WanxImageModel model = WanxImageModel.builder()              .modelName(&quot;wanx2.1-t2i-plus&quot;)              .apiKey(&quot;sk-ab194af7f1a9411396d4510c14f6cc45&quot;)              .build();      Response&lt;Image&gt; generate = model.generate(&quot;学院二本的java程序员找不到实习工作而苦恼，&quot; +              &quot;而985、211的java程序员却找到了实习工作而在欢呼雀跃&quot;);      URI url = generate.content().url();      System.out.println(url);  &#125;

测试deepseek配置文件
#集成百炼-deepseek  langchain4j.open-ai.chat-model.base-url=https://dashscope.aliyuncs.com/compatible-mode/v1  langchain4j.open-ai.chat-model.api-key=$&#123;DASH_SCOPE_API_KEY&#125;  langchain4j.open-ai.chat-model.model-name=deepseek-v3  #温度系数：取值范围通常在 0 到 1 之间。值越高，模型的输出越随机、富有创造性；  # 值越低，输出越确定、保守。这里设置为 0.9，意味着模型会有一定的随机性，生成的回复可能会比较多样化。  langchain4j.open-ai.chat-model.temperature=0.9

人工智能服务AIService
为大语言模型格式化输入内容
解析大语言模型的输出结果
聊天记忆 Chat memory

创建AIService导入依赖&lt;!--langchain4j高级功能--&gt;  &lt;dependency&gt;      &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;      &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt;

创建接口public interface Assistant &#123;      String chat(String userMessage);  &#125;

测试用例@Autowired  private QwenChatModel qwenChatModel;    @Test  public void testChat() &#123;      Assistant assistant = AiServices.create(Assistant.class, qwenChatModel);      String answer = assistant.chat(&quot;你是谁？&quot;);      System.out.println(answer);  &#125;

@AiService
使用注解开发

接口改成
@AiService(wiringMode = EXPLICIT, chatModel = &quot;qwenChatModel&quot;)  public interface Assistant &#123;      String chat(String userMessage);  &#125;


测试用例@Autowired  private Assistant assistant;    @Test  public void testAssistant() &#123;      String answer = assistant.chat(&quot;我是谁？&quot;);      System.out.println(answer);  &#125;

聊天记忆 Chat memory聊天记忆的简单实现
就是把每一次的问问题都把上一次问的再问一遍

@Autowiredprivate QwenChatModel qwenChatModel;@Testpublic void testChatMemory2() &#123;	//第一轮对话	UserMessage userMessage1 = UserMessage.userMessage(&quot;我是环环&quot;);	ChatResponse chatResponse1 = qwenChatModel.chat(userMessage1);	AiMessage aiMessage1 = chatResponse1.aiMessage();	//输出大语言模型的回复	System.out.println(aiMessage1.text());	//第二轮对话	UserMessage userMessage2 = UserMessage.userMessage(&quot;你知道我是谁吗&quot;);	ChatResponse chatResponse2 = qwenChatModel.chat(Arrays.asList(userMessage1, 	aiMessage1, userMessage2));	AiMessage aiMessage2 = chatResponse2.aiMessage();	//输出大语言模型的回复	System.out.println(aiMessage2.text());&#125;

使用ChatMemory实现聊天记忆@Test  public void testChatMemory() &#123;        MessageWindowChatMemory messageWindowChatMemory = MessageWindowChatMemory.withMaxMessages(10);        Assistant build = AiServices              .builder(Assistant.class)              .chatLanguageModel(qwenChatModel)              .chatMemory(messageWindowChatMemory)              .build();        String answer1 = build.chat(&quot;我是呵帅&quot;);      System.out.println(answer1);      String answer2 = build.chat(&quot;我是谁？&quot;);      System.out.println(answer2);  &#125;

使用AIService实现聊天记忆编写接口
跟之前差不多，就是多了个 chatMemory，这个 chatMemory 需要我们注册成 bean

@AiService(          wiringMode = EXPLICIT,          chatModel = &quot;qwenChatModel&quot;,          chatMemory = &quot;chatMemory&quot;)  public interface MemoryChatAssistant &#123;      String chat(String input);  &#125;

配置ChatMemory@Configuration  public class MemoryChatAssistantConfig &#123;      @Bean      MessageWindowChatMemory chatMemory() &#123;          return MessageWindowChatMemory.withMaxMessages(10);      &#125;  &#125;

测试用例@Autowired  private MemoryChatAssistant memoryChatAssistant;    @Test  public void testChatMemory3() &#123;      String answer = memoryChatAssistant.chat(&quot;我是呵帅&quot;);      System.out.println(answer);      String answer2 = memoryChatAssistant.chat(&quot;我是谁？&quot;);      System.out.println(answer2);    &#125;

隔离聊天记忆
在多并发情况下，聊天记录会混乱，因此我们需要为每个用户的新聊天或者不同的用户区分聊天记忆

编写接口@AiService(chatModel = &quot;qwenChatModel&quot;,          wiringMode = EXPLICIT,          chatMemoryProvider = &quot;chatMemoryProvider&quot;)  public interface SeparateChatAssistant &#123;      String chat(@MemoryId int memoryId, @UserMessage String userMessage);  &#125;
注册bean因为 ChatMemoryProvider 是一个函数式接口，memoryId 是在 ChatMemoryProvider 里的方法参数
@Bean  ChatMemoryProvider chatMemoryProvider() &#123;      return memoryId -&gt; MessageWindowChatMemory.builder().id(memoryId).maxMessages(10).build();  &#125;
测试用例@Autowired  private SeparateChatAssistant separateChatAssistant;    @Test  public void testSeparateChat() &#123;      String answer = separateChatAssistant.chat(1, &quot;我是呵帅&quot;);      System.out.println(answer);      String answer2 = separateChatAssistant.chat(2,&quot;我是谁？&quot;);      System.out.println(answer2);      String answer3 = separateChatAssistant.chat(1,&quot;我是谁？&quot;);      System.out.println(answer3);  &#125;


持久化聊天记忆 PersistenceMongoDB安装
服务器： mongodb-windows-x86_64-8.0.6-signed.msi https://www.mongodb.com/try/download/community 
命令行客户端 ： mongosh-2.5.0-win32-x64.zip https://www.mongodb.com/try/download/shell 
图形客户端： mongodb-compass-1.39.3-win32-x64.exe https://www.mongodb.com/try/download/compass

整合SpringBoot导入依赖&lt;!-- Spring Boot Starter Data MongoDB --&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;

添加配置#MongoDB连接配置spring.data.mongodb.uri=mongodb://localhost:27017/chat_memory_db

创建实体类@Data  @AllArgsConstructor  @NoArgsConstructor  @Document(&quot;chat_messages&quot;)  public class ChatMessages &#123;      //唯一标识，映射到 MongoDB 文档的 _id 字段      @Id      private ObjectId messageId;        private String content; //存储当前聊天记录列表的json字符串  &#125;

CRUD@SpringBootTest  public class MongoCrudTest &#123;        @Autowired      private MongoTemplate mongoTemplate;        @Test      public void testInsert() &#123;          ChatMessages chatMessages = new ChatMessages();          chatMessages.setContent(&quot;Hello World!&quot;);          mongoTemplate.insert(chatMessages);      &#125;        @Test      public void testFindById() &#123;          ChatMessages byId = mongoTemplate.findById(&quot;686a34609919e078f94e57d6&quot;, ChatMessages.class);          System.out.println(byId);      &#125;        @Test      public void testUpdate() &#123;          Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;686a34609919e078f94e57d6&quot;);          Query query = Query.query(criteria);          Update update = new Update();          update.set(&quot;content&quot;, &quot;New Hello World!&quot;);            // 修改或新增          mongoTemplate.updateFirst(query, update, ChatMessages.class);      &#125;        @Test      public void testRemove() &#123;          Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;686a34609919e078f94e57d6&quot;);          Query query = new Query(criteria);          mongoTemplate.remove(query, ChatMessages.class);      &#125;  &#125;

持久化聊天更改实体类@Data  @AllArgsConstructor  @NoArgsConstructor  @Document(&quot;chat_messages&quot;)  public class ChatMessages &#123;      //唯一标识，映射到 MongoDB 文档的 _id 字段      @Id      private ObjectId messageId;        private String memoryId;        private String content; //存储当前聊天记录列表的json字符串  &#125;

创建持久化类
创建一个类实现ChatMemoryStore接口

@Component  public class MongoChatMemoryStore implements ChatMemoryStore &#123;     @Autowired      private MongoTemplate mongoTemplate;          @Override      public List&lt;ChatMessage&gt; getMessages(Object memoryId) &#123;          Criteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);          Query query = new Query(criteria);          ChatMessages chatMessages = mongoTemplate.findOne(query, ChatMessages.class);          if(chatMessages == null) return new LinkedList&lt;&gt;();          return ChatMessageDeserializer.messagesFromJson(chatMessages.getContent());      &#125;          @Override      public void updateMessages(Object memoryId, List&lt;ChatMessage&gt; messages) &#123;          Criteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);          Query query = new Query(criteria);          Update update = new Update();          update.set(&quot;content&quot;, ChatMessageSerializer.messagesToJson(messages));          //根据query条件能查询出文档，则修改文档；否则新增文档          mongoTemplate.upsert(query, update, ChatMessages.class);      &#125;          @Override      public void deleteMessages(Object memoryId) &#123;          Criteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);          Query query = new Query(criteria);          mongoTemplate.remove(query, ChatMessages.class);      &#125;  &#125;

修改配置类添加MongoChatMemoryStore对象的配置
@Autowired  private MongoChatMemoryStore mongoChatMemoryStore;    @Bean  ChatMemoryProvider chatMemoryProvider() &#123;      return memoryId -&gt; MessageWindowChatMemory              .builder()              .id(memoryId)              .maxMessages(10)              .chatMemoryStore(mongoChatMemoryStore)              .build();  &#125;

提示词 Prompt系统提示词
@SystemMessage 设定角色，塑造AI助手的专业身份，明确助手的能力范围

@SystemMessage在SeparateChatAssistant类的chat方法上添加@SystemMessage注解
@SystemMessage(&quot;你是我的好朋友，请用东北话回答问题。&quot;)//系统消息提示词String chat(@MemoryId int memoryId, @UserMessage String userMessage);


@SystemMessage 的内容将在后台转换为 SystemMessage 对象，并与 UserMessage 一起发送给大语言模型（LLM）。
SystemMessaged 的内容只会发送给大模型一次，如果你修改了 SystemMessage 的内容，新的SystemMessage 会被发送给大模型，之前的聊天记忆会失效。
如果要显示今天的日期，我们需要在提示词中添加当前日期的占位符

@SystemMessage(&quot;你是我的好朋友，请用粤语回答问题。今天是&#123;&#123;current_date&#125;&#125;&quot;)//系统消息提示词 String chat(@MemoryId int memoryId, @UserMessage String userMessage);

从资源中加载提示模板
@SystemMessage 注解还可以从资源中加载提示模板：
@SystemMessage(fromResource = &quot;my-prompt-template.txt&quot;) String chat(@MemoryId int memoryId, @UserMessage String userMessage);

my-prompt-template.txt
你是我的好朋友，请用粤语回答问题，回答问题的时候适当添加表情符号。  今天是 &#123;&#123;current_date&#125;&#125;。

用户提示词
@UserMessage：获取用户输入

@UserMessage
在 MemoryChatAssistant 的 chat 方法中添加注解
每次都会将问题作为提示词@UserMessage(&quot;你是我的好朋友，请用上海话回答问题，并且添加一些表情符号。 &#123;&#123;it&#125;&#125;&quot;) //&#123;&#123;it&#125;&#125;表示这里String chat(String input);

测试@Autowired  private MemoryChatAssistant memoryChatAssistant;    @Test  public void testChatMemory3() &#123;      String answer = memoryChatAssistant.chat(&quot;我是呵帅&quot;);      System.out.println(answer);      String answer2 = memoryChatAssistant.chat(&quot;我18岁&quot;);      System.out.println(answer2);      String answer3 = memoryChatAssistant.chat(&quot;你知道我是谁吗&quot;);      System.out.println(answer3);  &#125;

指定参数名称配置@V
@V 明确指定传递的参数名称

@UserMessage(&quot;你是我的好朋友，请用上海话回答问题，并且添加一些表情符号。&#123;&#123;message&#125;&#125;&quot;) String chat(@V(&quot;message&quot;) String userMessage);

多个参数的情况
如果有两个或两个以上的参数，我们必须要用@V

在 SeparateChatAssistant 中定义方法 chat2
@UserMessage(&quot;你是我的好朋友，请用粤语跟我交谈，并且添加一些表情符号。 &#123;&#123;message&#125;&#125;&quot;)String chat2(@MemoryId int memoryId, @V(&quot;message&quot;) String input);

@UserMessage 中的内容每次都会被和用户问题组织在一起发送给大模型
@Test  public void testSeparateChat() &#123;      String answer = separateChatAssistant.chat2(4, &quot;我是呵帅&quot;);      System.out.println(answer);      String answer2 = separateChatAssistant.chat2(5,&quot;我是谁？&quot;);      System.out.println(answer2);      String answer3 = separateChatAssistant.chat2(4,&quot;我是谁？&quot;);      System.out.println(answer3);  &#125;

@SystemMessage和@V
可以将 @SystemMessage 和 @V 结合使用

在 SeparateChatAssistant 中添加方法 chat3
@SystemMessage(fromResource = &quot;my-prompt-template2.txt&quot;)  String chat3(          @MemoryId int memoryId,          @UserMessage String userMessage,          @V(&quot;username&quot;) String username,          @V(&quot;age&quot;) int age);

创建提示词模板my-prompt-template2.txt，添加占位符
你是我的好帮手，我是&#123;&#123;username&#125;&#125;，我的年龄是&#123;&#123;age&#125;&#125;，请用粤语回答问题，回答问题的时候适当添加表情符号，或者文字表情。  今天是 &#123;&#123;current_date&#125;&#125;。

测试
@Test  public void testUserInfo() &#123;      String answer = separateChatAssistant.chat3(6, &quot;我是谁，我多大了&quot;, &quot;小明&quot;, 18);      System.out.println(answer);  &#125;

Function Calling 函数调用
Function Calling 函数调用 也叫 Tools 工具

快速入门创建工具类@Component  public class CalculatorTools &#123;        @Tool      double sum(double a, double b) &#123;          System.out.println(&quot;调用加法运算&quot;);          return a + b;      &#125;      @Tool      double squareRoot(double x) &#123;          System.out.println(&quot;调用平方根运算&quot;);          return Math.sqrt(x);      &#125;  &#125;

在接口配值工具类@AiService(chatModel = &quot;qwenChatModel&quot;,          wiringMode = EXPLICIT,          chatMemoryProvider = &quot;chatMemoryProvider&quot;,          tools = &quot;calculatorTools&quot;)

@Tool 注解的可选字段@Tool 注解有两个可选字段：

name（工具名称）：工具的名称。如果未提供该字段，方法名会作为工具的名称。
value（工具描述）：工具的描述信息。

根据工具的不同，即使没有任何描述，大语言模型可能也能很好地理解它（例如， add(a, b) 就很直 观），但通常最好提供清晰且有意义的名称和描述。这样，大语言模型就能获得更多信息，以决定是否 调用给定的工具以及如何调用。
@P 注解方法参数可以选择使用 @P 注解进行标注，有两个字段：

value：参数的描述信息。
required：表示该参数是否为必需项，默认值为 true 。

@ToolMemoryId
如果你的AIService方法中有一个参数使用 @MemoryId 注解，那么你也可以使用 @ToolMemoryId 注解 @Tool 方法中的一个参数。
简单来说就是就是在 @Tools 方法中获取 @MemoryId 的

检索增强生成 RAG让大模型回答专业领域的知识微调大模型
在现有大模型的基础上，使用小规模的特定任务数据进行再次训练，调整模型参数，让模型更精确地处 理特定领域或任务的数据。更新需重新训练，计算资源和时间成本高。

应用场景：适合知识库稳定、对生成内容准确性和风格要求高的场景，如对上下文理解和语言生成 质量要求高的文学创作、专业文档生成等。
RAG
Retrieval-Augmented Generation 检索增强生成

将原始问题以及提示词信息发送给大语言模型之前，先通过外部知识库检索相关信息，然后将检索结果 和原始问题一起发送给大模型，大模型依据外部知识库再结合自身的训练数据，组织自然语言回答问 题。通过这种方式，大语言模型可以获取到特定领域的相关信息，并能够利用这些信息进行回复。


应用场景：适用于知识库规模大且频繁更新的场景，如企业客服、实时新闻查询、法律和医疗领域 的最新知识问答等。
RAG常用方法
全文（关键词）搜索。这种方法通过将问题和提示词中的关键词与知识库文档数据库进行匹配来搜 索文档。根据这些关键词在每个文档中的出现频率和相关性对搜索结果进行排序。
向量搜索，也被称为 “语义搜索”。文本通过 嵌入模型 被转换为 数字向量。然后，它根据查询向量 与文档向量之间的余弦相似度或其他相似性 &#x2F; 距离度量来查找和排序文档，从而捕捉更深层次的语 义含义。
混合搜索。结合多种搜索方法（例如，全文搜索 + 向量搜索）通常可以提高搜索的效果。

向量搜索 vector search向量Vectors：

可以将向量理解为从空间中的一个点到另一个点的移动。例如，在下图中，我们可以看到一些二维空间中的向量

维度 Dimensions：

每个数值向量都有 x 和 y 坐标（或者在多维系统中是 x、y、z，…）。x、y、z… 是这个向量 空间的轴，称为维度。对于我们想要表示为向量的一些非数值实体，我们首先需要决定这些维度，并为 每个实体在每个维度上分配一个值
向量的每个维度代表数据的不同特性，维度越多对事务的描述越精确

相似度 Similarity：

如果用户搜索 “轿车Car” ，你希望能够返回所有与 结果。向量搜索就是实现这个目标的一种方法。
每个向量都有一个长度和方向。
由于向量通常用于描述语义意义，仅仅看长度通常无法满足需求。大多数相似度测量要么仅依赖于方 向，要么同时考虑方向和大小。

文档加载器 Document Loader测试用例@SpringBootTestpublic class RAGTest &#123;	@Test	public void testReadDocument() &#123;		//使用FileSystemDocumentLoader读取指定目录下的知识库文档		//并使用默认的文档解析器TextDocumentParser对文档进行解析		Document document = FileSystemDocumentLoader.loadDocument(&quot;E:/knowledge/测试.txt&quot;);		System.out.println(document.text());	&#125;&#125;

// 加载单个文档Document document = FileSystemDocumentLoader.loadDocument(&quot;E:/knowledge/file.txt&quot;, new TextDocumentParser()); // 从一个目录中加载所有文档List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(&quot;E:/knowledge&quot;, new TextDocumentParser()); // 从一个目录中加载所有的.txt文档PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(&quot;glob:*.txt&quot;); List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(&quot;E:/knowledge&quot;, pathMatcher, new TextDocumentParser()); // 从一个目录及其子目录中加载所有文档List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocumentsRecursively(&quot;E:/knowledge&quot;, new TextDocumentParser());

文档解析器 Document Parser文档可以是各种格式的文件，比如 PDF、DOC、TXT 等等。为了解析这些不同格式的文件，有一个 “文档 解析器”（DocumentParser）接口，并且我们的库中包含了该接口的几种实现方式：
导入依赖&lt;!--解析pdf文档--&gt;&lt;dependency&gt;	&lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;	&lt;artifactId&gt;langchain4j-document-parser-apache-pdfbox&lt;/artifactId&gt;&lt;/dependency&gt;

测试用例@Testpublic void testParsePDF() &#123;	Document document = FileSystemDocumentLoader.loadDocument(&quot;E:/knowledge/医院信息.pdf&quot;,new ApachePdfBoxDocumentParser());	System.out.println(document);&#125;

文档分割器 Document Splitter测试向量转换和向量存储
Embedding (Vector) Stores 常见的意思是 “嵌入（向量）存储” 。
在机器学习和自然语言处理领域， Embedding 指的是将数据（如文本、图像等）转换为低维稠密向量表示的过程，这些向量能够保留数据 的关键特征。
而 Stores 表示存储，即用于存储这些嵌入向量的系统或工具。它们可以高效地存储和检索 向量数据，支持向量相似性搜索，在文本检索、推荐系统、图像识别等任务中发挥着重要作用。

Langchain4j支持的向量存储：https://docs.langchain4j.dev/integrations/embedding-stores/
导入依赖
&lt;!--简单的rag实现--&gt;&lt;dependency&gt;	&lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;	&lt;artifactId&gt;langchain4j-easy-rag&lt;/artifactId&gt;&lt;/dependency&gt;


@Test  public void testDocumentSplitter() &#123;      // 读取文档      Document document = FileSystemDocumentLoader.loadDocument(&quot;D:/BaiduNetdiskDownload/资料(2)/knowledge/人工智能.md&quot;);      // 创建内存中的向量存储      InMemoryEmbeddingStore&lt;TextSegment&gt; embeddingStore = new InMemoryEmbeddingStore&lt;&gt;();        DocumentByParagraphSplitter documentSplitter = new DocumentByParagraphSplitter(              300,              30,              //token分词器：按token计算              new HuggingFaceTokenizer());        // 处理文档并存储      EmbeddingStoreIngestor              .builder()              .embeddingStore(embeddingStore)              .documentSplitter(documentSplitter)              .build()              .ingest(document);            System.out.println(embeddingStore);  &#125;

处理文档并存储里有三个子步骤：

分割文档
将长文档拆分成多个小片段（默认每个片段不超过 300 个单词，相邻片段重叠 30 个单词）。


文本向量化
将每个文本片段转换为数学向量（类似用坐标表示位置）。


存储向量
将每个文本片段和对应的向量存入内存数据库embeddingStore。



token和token计算@Test  public void testTokenCount() &#123;  	String text = &quot;这是一个示例文本，用于测试 token 长度的计算。&quot;;  	UserMessage userMessage = UserMessage.userMessage(text);  	//计算 token 长度  //QwenTokenizer tokenizer = new QwenTokenizer(System.getenv(&quot;DASH_SCOPE_API_KEY&quot;),&quot;qwen-max&quot;);  	HuggingFaceTokenizer tokenizer = new HuggingFaceTokenizer();  	int count = tokenizer.estimateTokenCountInMessage(userMessage);  	System.out.println(&quot;token长度：&quot; + count);  &#125;


]]></content>
  </entry>
  <entry>
    <title>JDBC学习笔记</title>
    <url>/2024/09/05/articles/JDBC/JDBC/</url>
    <content><![CDATA[了解一下JDBCJDBC（Java Database Connectivity）是Java语言中用来规范客户端程序如何访问数据库的应用程序接口，它定义了一系列的接口，为各种数据库的访问提供了统一的操作方式。
为什么我们会用到JDBC？一般来说，数据库与应用程序无法直接链接，我们需要一个驱动，作为应用和数据库直接的桥梁，但是每个厂商之间的驱动是不相同的，MySQL有MySQL的驱动，Oracle有Oracle的驱动，我们不可能每使用一种数据库就去安装他的驱动，太过麻烦。JDBC是让Java应用程序连接到不同的数据库管理系统(如MySQL、Oracle等)，执行SQL查询和更新，以及处理结果集。驱动的安装就不需要我们亲自去做了，我们只需要掌握JDBC的语法，即可在Java中使用数据库了。
使用JDBC之前的工作首先，在使用JDBC之前，我们需要先去下载jar包，我是去Maven仓库下载的Maven仓库下载地址：https://mvnrepository.com/artifact/mysql/mysql-connector-java下载后，我们需要导入驱动jar包我们在项目内新建一个文件夹，用来存放jar包，后面需要添加的jar包也可以存放在内，把下载的jar包复制进文件内，打开IntelliJ IDEA我们在项目内可以看到我们复制进来的jar包，但此时不算导入成功，我们需要右键，点击Add as Library，点击ok，可以展开的话就是导入成功了
第一个JDBC程序查询数据库JDBC有六个步骤，我们随后在Java程序里写编程的时候按照这六步来写即可
1、加载驱动2、用户信息和url3、创造链接4、执行sql语句的对象5、执行sql语句，并查看返回的结果6、释放链接
我们先准备一份有内容的数据库
CREATE DATABASE jdbcStudy;USE jdbcStudy;CREATE TABLE `users`(	id INT PRIMARY KEY,	NAME VARCHAR(40),	PASSWORD VARCHAR(40),	email VARCHAR(60),	birthday DATE);INSERT INTO `users`(id,NAME,PASSWORD,email,birthday)VALUES(1,&#x27;zhansan&#x27;,&#x27;123456&#x27;,&#x27;zs@qq.com&#x27;,&#x27;2000-1-1&#x27;),(2,&#x27;lisi&#x27;,&#x27;123456&#x27;,&#x27;lisi@qq.com&#x27;,&#x27;2001-1-1&#x27;),(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;,&#x27;wangwu@qq.com&#x27;,&#x27;2002-1-1&#x27;)
然后，我们再打开IntelliJ IDEA，新建一个Java程序代码如下
package JDBC;import java.sql.*;public class JDBCtest &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //JDBC        //1、加载驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //模板格式        //2、用户信息和url        String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy;        String user = &quot;root&quot;;        String password = &quot;123456&quot;;        //3、创造链接        Connection connection = DriverManager.getConnection(url, user, password);//这里返回的connection对象代表数据库        //4、执行sql语句的对象        Statement statement = connection.createStatement();        //5、执行sql语句，并查看返回的结果        String sql = &quot;SELECT * FROM users&quot;;        ResultSet resultSet = statement.executeQuery(sql);//返回的结果集        while (resultSet.next())&#123;            System.out.print(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));            System.out.print(&quot; name=&quot;+resultSet.getObject(&quot;NAME&quot;));            System.out.print(&quot; password=&quot;+resultSet.getObject(&quot;PASSWORD&quot;));            System.out.print(&quot; email=&quot;+resultSet.getObject(&quot;email&quot;));            System.out.println(&quot; birth=&quot;+resultSet.getObject(&quot;birthday&quot;));        &#125;                //6、释放链接        resultSet.close();        statement.close();        connection.close();    &#125;&#125;
运行结果如下，虽然有红色小字，但不影响程序的运行
修改信息|增加信息|删除信息我们使用executeUpdate(String sql)来完成添加|删除信息添加信息
Statement statement = connection.createStatement();String sql = &quot;insert into user(...)values(...)&quot;;int num = statement.executeUpdate(sql);if (num &gt; 0)&#123;    System.out.println(&quot;插入成功！&quot;);&#125;
删除信息
Statement statement = connection.createStatement();String sql = &quot;delete from user where ...&quot;;int num = statement.executeUpdate(sql);if (num &gt; 0)&#123;    System.out.println(&quot;删除成功！&quot;);&#125;
修改信息同上，只需要改变sql里面的语句即可
简化步骤上面的方法看着很简便，但如果数据一多就特别麻烦，所以我们需要把方法提取出来首先，我们构建一个文件db.properties用来保留登录信息，在文件中写入
driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudyusername=rootpassword=123456
然后再构建一个java文件，用来存放方法
package JDBCtest2;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class test2 &#123;    private static String driver = null;    private static String url = null;    private static String user = null;    private static String password = null;static &#123;    try &#123;        InputStream in = test2.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);        Properties properties = new Properties();        properties.load(in);        driver = properties.getProperty(&quot;driver&quot;);        url = properties.getProperty(&quot;url&quot;);        user = properties.getProperty(&quot;username&quot;);        password = properties.getProperty(&quot;password&quot;);        //1、驱动只需要加载一次        Class.forName(driver);    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;//获取链接public static Connection getConnection() throws SQLException &#123;    return DriverManager.getConnection(url, user, password);&#125;//释放资源public static void release(Connection conn, Statement st, ResultSet rs) &#123;    if (rs!= null) &#123;        try &#123;            rs.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    if (st!= null) &#123;        try &#123;            st.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    if (conn != null) &#123;        try &#123;            conn.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;&#125;
方法就提取出来了，我们实验一下运行结果，成功插入
PreparedStatement对象PreparedStatement对象可以有效防止SQL注入，并且运行时效率更高。防止SQL注入的原理：把转递进来的参数当作字符，假设其中存在转义字符，会被直接转义，比如说&quot;会被认为是引号，而不是其他。代码如下
import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Date;public class insertTest &#123;    public static void main(String[] args) &#123;        Connection conn = null;        PreparedStatement pst = null;        try &#123;            conn = test2.getConnection();            // 与之前的区别：            // 使用？占位符来代替参数            String sql = &quot;insert into users(id, NAME, PASSWORD, email, birthday) values(?, ?, ?, ?, ?)&quot;;            pst = conn.prepareStatement(sql);//预编译sql语句，但不执行            //手动给参数赋值，            // 第一个参数代表着第几个问号，第二个参数代表着参数值            pst.setInt(1, 5);            pst.setString(2, &quot;John&quot;);            pst.setString(3, &quot;123456&quot;);            pst.setString(4, &quot;john@qq.com&quot;);            // java.sql.Date是数据库的日期类型，需要用java.util.Date转换            //         new Date().getTime()获取时间戳            pst.setDate(5, new java.sql.Date(new Date().getTime()));            int i = pst.executeUpdate();            if (i &gt; 0) &#123;                System.out.println(&quot;Insert success!&quot;);            &#125;        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;
成功插入其余删改查和这个差不多，删和改只需要把sql语句和参数变一下，查就把sql语句和executeUpdate变成executeQuery即可
]]></content>
  </entry>
  <entry>
    <title>快速上手SpringAI</title>
    <url>/2025/07/13/articles/AI/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringAI%20%201.0/</url>
    <content><![CDATA[快速入门导入依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springAi_deepseek&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;        &lt;!-- 明确指定Spring Boot和Spring AI版本 --&gt;        &lt;spring-boot.version&gt;3.2.0&lt;/spring-boot.version&gt;        &lt;spring-ai.version&gt;1.0.0-M5&lt;/spring-ai.version&gt;    &lt;/properties&gt;    &lt;!-- 仓库配置：确保依赖可下载 --&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;maven-central&lt;/id&gt;            &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;        &lt;/repository&gt;        &lt;repository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;dependencies&gt;        &lt;!-- Spring Boot Web Starter（版本由下方BOM管理） --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 复用OpenAI Starter兼容DeepSeek（版本由Spring AI BOM管理） --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;            &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Spring Boot Test Starter（版本由下方BOM管理） --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 关键：手动导入Spring Boot和Spring AI的BOM管理版本 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!-- Spring Boot的BOM，管理所有starter的版本 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- Spring AI的BOM，管理AI相关依赖版本 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;

配置文件server.port=8899  spring.application.name=spring-ai-deepseek-demo    spring.ai.openai.api-key=sk-43745c46cd5a4d80821e998030******  spring.ai.openai.base-url=https://api.deepseek.com  spring.ai.openai.chat.options.model=deepseek-chat  spring.ai.openai.chat.options.temperature=0.7



temperature参数用于控制生成文本的多样性。具体来说：
‌值越高‌，生成的文本越多样化，但也可能包含更多的随机性和不可预测的内容。 ‌值越低‌，生成的文本越接近于确定性的结果，即生成的文本会更加一致和可预测。




启动类@SpringBootApplication  public class SpringAiDemoApplication &#123;      public static void main(String[] args) &#123;          SpringApplication.run(SpringAiDemoApplication.class, args);      &#125;  &#125;

controller@RestController  public class ChatDeepSeekController &#123;        @Autowired      private OpenAiChatModel openAiChatModel;        @GetMapping(&quot;/hello&quot;)      public String generate(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;hello&quot;) String message)&#123;          String call = openAiChatModel.call(message);          System.out.println(&quot;call: &quot; + call);          return call;      &#125;  &#125;


Spring AI的聊天模型ChatClient接口
ChatClient 是一个接口，定义了与聊天服务交互的客户端。这个接口主要用于创建聊天客户端对象，设置请求规范，以及发起聊天请求。

实现简单的对话
用户输入设置用户消息的内容，通过SpringBoot AI封装的方法向 AI 模型发送请求，以字符串形式返回 AI 模型的响应。

@RestController  public class ChatDeepSeekController &#123;        private final ChatClient chatClient;        public ChatDeepSeekController(ChatClient.Builder chatClientBuilder) &#123;          chatClient = chatClientBuilder.build();      &#125;        @GetMapping(&quot;/chat&quot;)      public String chat(@RequestParam(value = &quot;msg&quot;, defaultValue = &quot;hello&quot;) String message) &#123;          return chatClient                  .prompt()            // 提示词                  .user(message)       // 用户输入                  .call()              // 调用大模型                  .content();          // 返回文本      &#125;  &#125;


实现角色预设
配置默认角色
@Configuration  public class AiConfig &#123;        @Bean      public ChatClient chatClient(ChatClient.Builder builder) &#123;          return builder                  .defaultSystem(&quot;你是一个已经毕业多年，有丰富工作经验的Java工程师，你的名字是呵帅&quot;)                  .build();      &#125;  &#125;

编写controller
@RestController  public class ChatDeepSeekController &#123;        @Autowired      private ChatClient chatClient;        @GetMapping(&quot;chatai&quot;)      public String chatAi(@RequestParam(&quot;msg&quot;) String msg) &#123;          return chatClient                  .prompt()                  .user(msg)                  .call()                  .content();      &#125;  &#125;

实现流式响应
非流式输出 call：等待大模型把回答结果全部生成后输出给用户；

流式输出stream：逐个字符输出，一方面符合大模型生成方式的本质，另一方面当模型推理效率不是很高时，流式输出比起全部生成后再输出大大提高用户体验。



controller&#x3D;@GetMapping(value = &quot;chatAiStream&quot;, produces = &quot;text/html;charset=UTF-8&quot;)  public Flux&lt;String&gt; chatAiStream(@RequestParam(&quot;msg&quot;) String msg)&#123;      return chatClient              .prompt()              .user(msg)              .stream()              .content();  &#125;

ChatModel接口
在ChatModel接口中，带有String参数的call()方法简化了实际的使用，避免了更复杂的Prompt和 ChatResponse类的复杂性。

实现简单的对话@RestController  public class ChatModelController &#123;        @Autowired      private ChatModel chatModel;        @GetMapping(&quot;/chatModel01&quot;)      public String chatModel01(@RequestParam(&quot;msg&quot;) String msg) &#123;          return chatModel.call(msg);      &#125;        @GetMapping(&quot;/chatModel02&quot;)      public String chatModel02(@RequestParam(&quot;msg&quot;) String msg)&#123;          ChatResponse chatResponse = chatModel.call(                  new Prompt(                          msg,                          ChatOptions.                                  builder()                                  .model(&quot;deepseek-chat&quot;)                                  .temperature(0.8)                                  .build()                  )          );          return chatResponse.getResult().getOutput().getContent();      &#125;  &#125;

提示词评价：难用，不如langchain4j
@GetMapping(&quot;/chatModel03&quot;)  public String chatModel03(@RequestParam(&quot;name&quot;) String name,                            @RequestParam(&quot;voice&quot;) String voice) &#123;      String userText = &quot;给我推荐三个Java的框架&quot;;      UserMessage userMessage = new UserMessage(userText);      String systemText = &quot;你是一个Java高手，在Java行业已经工作多年，你非常喜欢帮助别人来了解这个行业相关的内容，你的名字是&#123;name&#125;，推荐框架的难度是&#123;voice&#125;。&quot;;      SystemPromptTemplate systemPromptTemplate = new SystemPromptTemplate(systemText);      Message message = systemPromptTemplate.createMessage(Map.of(&quot;name&quot;, name, &quot;voice&quot;, voice));      Prompt prompt = new Prompt(userMessage, message);      ChatResponse chatResponse = chatModel.call(prompt);      List&lt;Generation&gt; results = chatResponse.getResults();      return results.stream().map(x-&gt;x.getOutput().getContent()).collect(Collectors.joining(&quot;&quot;));    &#125;

Function Calling函数调用
函数调用功能允许大语言模型在生成回答时触发预定义的外部函数，从而实现动态数据获取或业务逻辑操作（如查询数据库、调用 API 等）

自定义Function@Configuration  public class CalculatorService &#123;      public record addOperation(int a, int b) &#123;        &#125;        public record subtractOperation(int n, int m) &#123;        &#125;        @Bean      @Description(&quot;加法运算&quot;)      public Function&lt;addOperation, Integer&gt; addOperation() &#123;          return op -&gt; &#123;              return op.a + op.b;          &#125;;      &#125;        @Bean      @Description(&quot;乘法运算&quot;)      public Function&lt;subtractOperation, Integer&gt; subtractOperation() &#123;          return op -&gt; &#123;              return op.n * op.m;          &#125;;      &#125;  &#125;

































]]></content>
  </entry>
  <entry>
    <title>SpringFramework学习笔记</title>
    <url>/2024/12/20/articles/Spring/SpringLeaning/</url>
    <content><![CDATA[所需基本依赖&lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;6.1.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;6.1.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
配置文件注册bean配置文件基础模板&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         https://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt;


使用配置文件注册一个bean最简单的方式，参数为 null
&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;/&gt;  

如果 bean 需要传入参数，并且希望是通过有参构造来创建
&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;&gt;      &lt;constructor-arg name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;

如果bean需要传入参数，并且希望是通过无参构造来创建

property 里的参数同上
&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;&gt;      &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;

关于配置文件注册bean
赋值的原理是通过类中的set注入
id 相当于一个变量名，class 是类文件路径来源，还可以加个 name 作为 别名，注意 &#x3D;&#x3D;id 开头小写&#x3D;&#x3D;
有参构造和无参构造中的 name 是参数名， value 是默认传入的值
&#x3D;&#x3D;constructor-arg通过有参构造创建，创建对象的同时赋值&#x3D;&#x3D;  
&#x3D;&#x3D;property通过无参构造创建，创建对象后，再通过set方法赋值&#x3D;&#x3D;

导入其他配置文件里的内容&lt;import resource=&quot;其他Spring配置文件.xml&quot;/&gt;
导入的配置文件和本身共有注册 bean，优先用自己的
赋值方法1、下标赋值&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;&gt;      &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;

2、通过类型赋值&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;&gt;      &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;
缺陷：
3、通过参数名赋值&lt;bean id=&quot;hello&quot; class=&quot;org.example.pojo.HelloWorld&quot;&gt;      &lt;constructor-arg name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;

获取beanApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring配置文件.xml&quot;);类 变量名 = context.getBean(&quot;beanID&quot;, 类.class);

Autowired自动装填@Autowired 先判断byType，再判断byName
public class People &#123;      // 等价于@Nullable，对象可以为null      @Autowired(required = false)      private Cat cat;      @Autowired      // @Autowired 先判断byType，再判断byName      @Qualifier(value = &quot;dog&quot;)      // 如果自动装配的环境比较复杂，无法通过一个@Autowired完成时，就要使用@Qualifer(value = &quot;***&quot;)指定bean名      private Dog dog;      private String name;  &#125;

按照原本的配置方式&lt;bean id=&quot;people&quot; class=&quot;org.example.pojo.People&quot;&gt;        &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;呵帅&quot;/&gt;    &lt;/bean&gt;

使用Autowired自动装配开启注解的支持&lt;context:annotation-config/&gt;

注册bean&lt;bean id=&quot;people&quot; class=&quot;org.example.pojo.People&quot; autowire=&quot;byName&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;呵帅&quot;/&gt;  &lt;/bean&gt;

我们使用完Autowired自动装配后，就可以不在配置文件里面配置参数对象但是有几点需要注意：

byName:按照属性名自动装配，和对象中set注入方法中的属性名一致  
byType:按照属性类型自动装配，和对象中的set方法里的属性类型一致
使用byType必须保证类型全局唯一，否则会报错  
使用byName必须保证属性名全局唯一，否则会报错

修改自动装配方式&lt;bean id=&quot;people&quot; class=&quot;org.example.pojo.People&quot; autowire=&quot;byName&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;呵帅&quot;/&gt;  &lt;/bean&gt;
把 autowire 里面的参数修改成 byName 或者 byType 即可，默认为 byType
依赖注入DI（Dependecy Injection）
依赖注入是从应用程序的角度在描述，应用程序依赖容器创建并注入它所需要的外部资源

注入方式
**第一种，普通值注入，value
&lt;property name=&quot;name&quot; value=&quot;John&quot;/&gt;

**第二种，引用注入，ref
&lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;

**第三种，数组注入，array
&lt;property name=&quot;friends&quot; &gt;     &lt;array&gt;        &lt;value&gt;Jane&lt;/value&gt;        &lt;value&gt;Tom&lt;/value&gt;        &lt;value&gt;Mary&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;

**第四种，键值对，map
&lt;property name=&quot;cards&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;身份证&quot; value=&quot;123456789012345678&quot;/&gt;    &lt;entry key=&quot;银行卡&quot; value=&quot;987654321098765432&quot;/&gt;	    &lt;entry key=&quot;信用卡&quot; value=&quot;54444&quot;/&gt;	&lt;/map&gt;&lt;/property&gt;

**第五种，list注入，list


&lt;property name=&quot;courses&quot;&gt;            &lt;list&gt;                &lt;value&gt;Java&lt;/value&gt;                &lt;value&gt;Python&lt;/value&gt;                &lt;value&gt;C++&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;


**第六种，set注入，set

&lt;property name=&quot;interests&quot;&gt;            &lt;set&gt;                &lt;value&gt;篮球&lt;/value&gt;                &lt;value&gt;足球&lt;/value&gt;                &lt;value&gt;乒乓球&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;

命名空间P 命名空间
**spring中的p命名空间就是为了更加方便的使用set方法注入属性内容，可以直接注入属性值，property
首先我们需要引入对应这个p命名空间的xml约束xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

举个例子
public class User &#123;    private String name;    private int age;        public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;

按照我们原来的写法应该是这么写
&lt;bean id=&quot;User&quot; class=&quot;org.example.pojo.User&quot;&gt;	&lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;	&lt;property name=&quot;name&quot; value=&quot;呵帅&quot;&gt;&lt;/bean&gt;

改用P命名空间后是这样
&lt;bean id=&quot;user&quot; class=&quot;org.example.pojo.User&quot; p:name=&quot;呵帅&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt;

设置代理模式：scope，默认scope是singleton单例模式
单例模式只允许创建一个实例，后续通过id获取的都是同一个实例
原型模式prototype，允许创建多个实例，每次获取都是新的实例

C 命名空间
**spring中的c命名空间就是为了更加方便的使用有参构造方法注入，通过构造器注入，constructor-arg

c命名空间注入，通过构造器注入，constructor-arg

首先我们需要引入对应这个p命名空间的xml约束
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;

**通过使用名称的方式
&lt;bean id=&quot;user2&quot; class=&quot;org.example.pojo.User&quot; c:name=&quot;呵帅2&quot; c:age=&quot;18&quot; scope=&quot;prototype&quot;/&gt;

**通过使用索引的方式
&lt;bean id=&quot;user2&quot; class=&quot;org.example.pojo.User&quot; c:_0=&quot;呵帅2&quot; c:_1=&quot;18&quot; scope=&quot;prototype&quot;/&gt;

mybatis
DataSource：使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid这是使用Spring提供的JDBC：org.springframework.jdbc.datasourceDataSource
使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid这是使用Spring提供的JDBC：org.springframework.jdbc.datasource

添加maven&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.13.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.27&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.7&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.1.13.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Spring操作数据库还需要一个spring-jdbc的依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.1.13.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;3.0.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.36&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

配置文件mybatis需要使用的文件
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;        &lt;!--DataSource：使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid    这是使用Spring提供的JDBC：org.springframework.jdbc.datasource      --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;          &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_lean&quot;/&gt;          &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;          &lt;property name=&quot;password&quot; value=&quot;Abc123&quot;/&gt;      &lt;/bean&gt;      &lt;!--sqlSessionFactory--&gt;      &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;          &lt;!--绑定mybatis配置文件--&gt;          &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;          &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:org/example/mapper/*.xml&quot;/&gt;      &lt;/bean&gt;      &lt;!--SqlSessionTemplate：就是我们之前使用的sqlSession   Template：模板--&gt;      &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;          &lt;!--只能使用构造器注入，这是因为没有set方法--&gt;          &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;      &lt;/bean&gt;  &lt;/beans&gt;

resource&#x2F;applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;        &lt;import resource=&quot;spring-dao.xml&quot;/&gt;        &lt;bean id=&quot;userMapper&quot; class=&quot;org.example.mapper.UserMapperImpl&quot;&gt;          &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;      &lt;/bean&gt;      &lt;bean id=&quot;userMapper2&quot; class=&quot;org.example.mapper.UserMapperImpl2&quot;&gt;          &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;      &lt;/bean&gt;&lt;/beans&gt;

org&#x2F;example&#x2F;mapper&#x2F;UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE mapper          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  &lt;mapper namespace=&quot;org.example.mapper.UserMapper&quot;&gt;        &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt;          SELECT * FROM mybatis_lean.user;      &lt;/select&gt;        &lt;insert id=&quot;addUser&quot; parameterType=&quot;user&quot;&gt;          insert into mybatis_lean.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);      &lt;/insert&gt;      &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;          delete from mybatis_lean.user where id = #&#123;id&#125;;      &lt;/delete&gt;    &lt;/mapper&gt;

注解开发mybatis需要使用的文件

可以清晰的看出，少了很多不必要的文件
用类 MyConfiguration.class 文件代替配置文件 
package org.example;    import org.apache.ibatis.datasource.pooled.PooledDataSource;  import org.mybatis.spring.SqlSessionFactoryBean;  import org.mybatis.spring.annotation.MapperScan;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.ComponentScan;  import org.springframework.context.annotation.Configuration;    import javax.sql.DataSource;    @Configuration  @ComponentScan(&quot;org.example.service&quot;)  @MapperScan(&quot;org.example.mapper&quot;)  public class MyConfiguration &#123;        @Bean      public DataSource dataSource() &#123;          return new PooledDataSource(&quot;com.mysql.cj.jdbc.Driver&quot;, &quot;jdbc:mysql://localhost:3306/mybatis_lean&quot;, &quot;root&quot;, &quot;Abc123&quot;);        &#125;        @Bean      public SqlSessionFactoryBean sqlSessionFactoryBean() &#123;          SqlSessionFactoryBean bean = new SqlSessionFactoryBean();          bean.setDataSource(dataSource());          return bean;      &#125;    &#125;

mapper 层接口
package org.example.mapper;    import org.apache.ibatis.annotations.Delete;  import org.apache.ibatis.annotations.Insert;  import org.apache.ibatis.annotations.Select;  import org.example.User;    import java.util.List;    public interface UserMapper &#123;      @Select(&quot;select * from user&quot;)      public List&lt;User&gt; selectUser();      @Insert(&quot;insert into user(id, name, pwd) VALUES(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)&quot;)      public int addUser(User user);      @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)      public int deleteUser(int id);  &#125;

service 层接口
package org.example.service;    import org.example.User;    import java.util.List;    public interface UserService &#123;      public List&lt;User&gt; selectUser();      public int addUser(User user);      public int deleteUser(int id);  &#125;

service 层实现类
package org.example.service;    import org.example.User;  import org.example.mapper.UserMapper;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;    import java.util.List;    @Service  public class UserServiceImpl implements UserService&#123;        @Autowired      UserMapper mapper;        @Override      public List&lt;User&gt; selectUser() &#123;          return mapper.selectUser();      &#125;        @Override      public int addUser(User user) &#123;          return mapper.addUser(user);      &#125;        @Override      public int deleteUser(int id) &#123;          return mapper.deleteUser(id);      &#125;  &#125;

AOP简单来说就是就是在运行期间加些事件进去
方式一：使用原生的Spring API接口
**配置aop：需要导入aop的命名空间

&lt;aop:config&gt;      &lt;!--配置切入点  expression：表达式，execution(要执行的位置 修饰词 返回值，列名 方法名 参数)--&gt;      &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* org.example.service..userServiceImpl.*(..))&quot;/&gt;        &lt;!--执行环绕增强--&gt;      &lt;!--相当于将log这个类切入到pointcut上--&gt;      &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;      &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;  &lt;/aop:config&gt;

实现 AfterReturningAdvice

在方法执行后运行package org.example.Log;    import org.springframework.aop.AfterReturningAdvice;    import java.lang.reflect.Method;    public class AfterLog implements AfterReturningAdvice &#123;      @Override      public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;          System.out.println(&quot;执行力&quot; + method.getName() + &quot;方法后，返回值为：&quot; + returnValue);      &#125;  &#125;

实现 MethodBeforeAdvice

在方法执行前运行package org.example.Log;    import org.springframework.aop.MethodBeforeAdvice;    import java.lang.reflect.Method;    public class log implements MethodBeforeAdvice &#123;      @Override      // method：要执行的目标对象的方法      // args：目标对象方法的参数      // target：目标对象      public void before(Method method, Object[] args, Object target) throws Throwable &#123;          System.out.println(target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;被执行了&quot;);        &#125;  &#125;

方式二：自定义类&lt;bean id=&quot;diy&quot; class=&quot;org.example.diy.DiyPointCut&quot;/&gt;&lt;aop:config&gt;      &lt;!--自定义切面，ref 要引用的类--&gt;      &lt;aop:aspect ref=&quot;diy&quot;&gt;          &lt;!--切入点--&gt;          &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* org.example.service.userServiceImpl.*(..))&quot;/&gt;          &lt;!--通知--&gt;          &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot;/&gt;          &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt;        &lt;/aop:aspect&gt;  &lt;/aop:config&gt;

自定义的类
package org.example.diy;    public class DiyPointCut &#123;        public void before() &#123;          System.out.println(&quot;==========方法执行前===========&quot;);      &#125;        public void after() &#123;          System.out.println(&quot;==========方法执行后===========&quot;);        &#125;  &#125;

方式三：使用注解开发
开启注解支持  JDK（默认 expose-proxy&#x3D;”false”）  cglib（expose-proxy&#x3D;”true”）

&lt;aop:aspectj-autoproxy expose-proxy=&quot;false&quot;/&gt;

package org.example.diy;    import org.aspectj.lang.ProceedingJoinPoint;  import org.aspectj.lang.annotation.After;  import org.aspectj.lang.annotation.Around;  import org.aspectj.lang.annotation.Aspect;  import org.aspectj.lang.annotation.Before;    //使用注解方式实现AOP    @Aspect // 标注这个类是一个切面  public class AnnotationPointCut &#123;      @Before(&quot;execution(* org.example.service.userServiceImpl.*(..))&quot;)      public void before() &#123;          System.out.println(&quot;====方法执行前====&quot;);      &#125;        @After(&quot;execution(* org.example.service.userServiceImpl.*(..))&quot;)      public void after() &#123;          System.out.println(&quot;====方法执行后====&quot;);      &#125;        @Around(&quot;execution(* org.example.service.userServiceImpl.*(..))&quot;)      public void around(ProceedingJoinPoint pj) throws Throwable &#123;          System.out.println(&quot;方法执行前&quot;);            // 执行方法          pj.proceed();            System.out.println(&quot;方法执行后&quot;);      &#125;  &#125;

调用运行import org.example.service.userService;  import org.example.service.userServiceImpl;  import org.springframework.context.ApplicationContext;  import org.springframework.context.support.ClassPathXmlApplicationContext;    public class MyTest &#123;      public static void main(String[] args) &#123;          ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);          //动态代理代理的是接口          userService userService = context.getBean(&quot;userService&quot;, userService.class);            userService.add();          userService.select();      &#125;  &#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/11/articles/MySQL/MySQL/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mybatis学习记录</title>
    <url>/2024/09/20/articles/Mybatis/Mybatis/</url>
    <content><![CDATA[Mybatis简介Mybatis是一个持久层的框架，支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。可以使用XML或注解来配置和映射原始类型、接口和Java对象作为数据库中的记录。
下载帮助文档
https://mybatis.org/mybatis-3/zh_CN/index.html
1、maven仓库
&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.16&lt;/version&gt;&lt;/dependency&gt;
2、GitHub
https://github.com/mybatis/mybatis-3/releases

搭建环境搭建好一个环境特别麻烦，做错一步就搭建失败报错跟着官方文档一步步来：https://mybatis.org/mybatis-3/zh_CN/getting-started.html
1、搭建数据库create database mybatis_lean;use mybatis_lean;create table user(    id int not null primary key,    name varchar(20) default null,    pwd varchar(20) default null)engine=INNODB default charset=utf8;insert into user values(1,&#x27;zhangsan&#x27;,&#x27;123456&#x27;),(2,&#x27;lisi&#x27;,&#x27;123456&#x27;),(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;);
2、新建一个maven项目
导入依赖在pom.xml文件中导入所需要的依赖以及配置resource来防止资源导出失败
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;MybatisStudy&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;modules&gt;        &lt;module&gt;mybatisStudy-01&lt;/module&gt;    &lt;/modules&gt;    &lt;!--    导入依赖--&gt;    &lt;dependencies&gt;&lt;!--        mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        mybatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.2&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        junit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;build&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                    &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                    &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;
注意，在.xml文件中尽量不要使用中文注释
3、在原项目下新建一个maven项目父级项目下创建一个子项目，子项目的.xml就不需要再配置了，方便我们以后使用
创建resource下的文件在子项目下的resource文件下创建一个mybatis-config.xml文件(叫什么无所谓，但但是尽量统一方便查看)配置文件：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;
把上面的 $&#123;driver&#125;、$&#123;url&#125;、$&#123;username&#125;、$&#123;password&#125; 都做修改
driver配置驱动，一般为：com.mysql.jdbc.Driverurl数据库的url，在idea里面打开已经配置好的数据库查看username：数据库的用户名password：数据库的密码
新建一个包新建三个包，包名分别为dao、utils、pojo
utils包https://mybatis.org/mybatis-3/zh_CN/getting-started.html原文档的话：每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration实例来构建出 SqlSessionFactory 实例。
在包内新建一个名为 MybatisUtils 的java类，用来获取SqlSessionFactory
package org.example.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;        //获取sqlSessionFactory对象    static &#123;        try &#123;            // 没有解析，背就行了            // 死代码            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 获取SqlSession    public static SqlSession getSqlSession() &#123;        return sqlSessionFactory.openSession();    &#125;&#125;
pojo包编写一个实体类的对象user
package org.example.pojo;public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;
dao包在dao包下新建一个接口UserDao
package org.example.Dao;import org.example.pojo.User;import java.util.List;public interface UserDao &#123;    List&lt;User&gt; getUserList();&#125;
在dao包下新建一个UserMapper.xml配置User的Mapper
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.example.Dao.UserDao&quot;&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;org.example.pojo.User&quot;&gt;        select * from mybatis_lean.user    &lt;/select&gt;&lt;/mapper&gt;

运行搭建完以上步骤后，在test文件夹下新建一个 UserDaoTest Java类文件
package org.example.dao;import org.apache.ibatis.session.SqlSession;import org.example.Dao.UserDao;import org.example.pojo.User;import org.example.utils.MybatisUtils;import org.junit.Test;import java.util.List;public class UserDaoTest &#123;    @Test    public void test() &#123;        // 获得sqlSession对象        SqlSession sqlSession = MybatisUtils.getSqlSession();        UserDao mapper = sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = mapper.getUserList();        for (User user : userList) &#123;            System.out.println(user);        &#125;        sqlSession.close();    &#125;&#125;
运行结果：target文件夹是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。运行成功后查看左边的target文件下的classes文件夹，里面的内容与你项目的内容一致
增删改查添加增删改查就在我们搭建的环境基础下改几个地方就行
首先来看Dao下的配置文件UserMapper.xml
在mapper标签里面有这么几个参数:    namespace：指的是方法所在的接口包名    id：所调用的方法名    resultType：方法返回的类型    parameterType：方法参数的类型
用select标签标起来的就是我们所需要的sql命令添加新的sql命令时，我们先需要在UserDao接口上新增方法，然后在配置文件里面的mapper标签里使用select标签，id换成新的方法名，resultType换成返回的参数，parameterType设置成方法参数的类型如果没有参数和返回值resultType和parameterType可以不写
样例：查首先在接口文件上填上方法
User getUserById(int id);
然后新增配置文件xml可以识别数据库里面的字段名，如果有参数我们使用#&#123;字段名&#125;
&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.pojo.User&quot;&gt;        select * from mybatis_lean.user where id = #&#123;id&#125;    &lt;/select&gt;
最后就可以在Test测试了，步骤和之前一样先用MybatisUtils.getSqlSession获取SqlSession，然后在获得接口getMapper，在mapper里面调用方法即可
public void updateUser()&#123;        SqlSession sqlSession = MybatisUtils.getSqlSession();        UserDao mapper = sqlSession.getMapper(UserDao.class);        mapper.updateUser(new User(3, &quot;tom&quot;, &quot;123123&quot;));        sqlSession.commit();        sqlSession.close();    &#125;

增删改查代码查：getUserById增：insertUser删：deleteUser改：updateUser
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.example.Dao.UserDao&quot;&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;org.example.pojo.User&quot;&gt;        select * from mybatis_lean.user    &lt;/select&gt;    &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.pojo.User&quot;&gt;        select * from mybatis_lean.user where id = #&#123;id&#125;    &lt;/select&gt;    &lt;select id=&quot;insertUser&quot; parameterType=&quot;org.example.pojo.User&quot;&gt;        insert into mybatis_lean.user values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)    &lt;/select&gt;    &lt;select id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from mybatis_lean.user where id = #&#123;id&#125;    &lt;/select&gt;    &lt;select id=&quot;updateUser&quot; parameterType=&quot;org.example.pojo.User&quot;&gt;        update mybatis_lean.user set name = #&#123;name&#125;, pwd = #&#123;pwd&#125; where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;
注意：配置文件里面不要用中文
接口文件：
package org.example.Dao;import org.example.pojo.User;import java.util.List;public interface UserDao &#123;    List&lt;User&gt; getUserList();    User getUserById(int id);    void insertUser(User user);    void deleteUser(int id);    void updateUser(User user);&#125;

模糊匹配我们使用数据库大多数指令都是查询，但有时候我们会忘记我们查询目标的全称，这时候我们就可以使用模糊比配首先，模糊匹配有两种常用的通配符”%“和”_“
&quot;%&quot; 百分号通配符: 表示任何字符出现0次或者多次例如：%李%        # 查找带有&quot;李&quot;的字符串，无论&quot;李&quot;出现在字符串的哪里&quot;_&quot; 下划线通配符:表示只能匹配单个字符。当然，也可以使用多个&quot;_&quot;例如：李__        # 查找开头是&quot;李&quot;，长度为3的字符串
使用关键字like即为模糊匹配
User getUserLikeName(String value);
&lt;select id=&quot;getUserLikeName&quot; parameterType=&quot;String&quot; resultType=&quot;org.example.pojo.User&quot;&gt;        select * from mybatis_lean.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt;
使用模糊匹配时要注意防范SQL注入
配置解析核心配置文件一般用到mybatis的配置文件官方都建议命名为mybatis-config.xml，当然也可以不接受这个建议
配置文件里面有一下几个组成部分
configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）
先后顺序是：properties，settings，typeAliases，typeHandlers，objectfactory，objectwrapperfactory，reflectorFactory，plugins，environments，databaseldProvider，mappers
事务管理器 transactionManager在 MyBatis 中有两种类型的事务管理器：JDBC 和 MANAGED(基本不用)Mybatis 默认的事务管理器是 JDBC
JDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交
MANAGED - 等价于 EJB (Enterprise Java Beans)， 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）
数据源 dataSourcedataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种内建的数据源类型：UNPOOLED、POOLED 和 JNDIMybatis默认数据源是POOLED
POOLED 可以理解成数据池，可以理解成 new 了一块空间出来，用完可以回收，即使数据传输完毕，这块空间也不会解散，只有等到代码跑完了才会自动解散。JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用
属性我们可以通过 properties 属性来实现引用配置文件这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。
我们在 resource 文件夹下新建一个 dp.properties 文件，里面写入替换的值例如：
driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis_lean?allowPublicKeyRetrieval=true&amp;useSSL=false&amp;useUnicode=true&amp;characteEncoding=UTF8username=rootpassword=123456
然后回到 mybatis-config.xml 文件，编写 properties 标签
&lt;properties resource=&quot;dp.properties&quot;/&gt;
然后修改 environment 
&lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;
注意：properties 标签必须在 configuration 里的最上面，先解释 properties 标签
当然，我们也可以在 mybatis-config.xml 里面改变值，但如果内部文件和外部文件都有动态配置的属性值，先运行内部的，后运行的外部会覆盖内部
&lt;properties resource=&quot;dp.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/properties&gt;

类型别名 typeAliases类型别名可为 Java 类型设置一个缩写名字。它仅用于 XML 配置，意在降低冗余的全限定类名书写。在 configuration 的书写顺序为第三位例如：
&lt;typeAliases&gt;        &lt;typeAlias alias=&quot;User&quot; type=&quot;org.example.pojo.User&quot;/&gt;&lt;/typeAliases&gt;上面这种配置可以让 org.example.pojo.User 替换成 User也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean&lt;typeAliases&gt;        &lt;package name=&quot;org.example.pojo&quot;/&gt;&lt;/typeAliases&gt;如果我们指定的包名 org.example.pojo 中的 JavaBean 没有注释，会使用类名的首字母小写作为别名我们也可以作注释@Alias(&quot;hhhh&quot;)public class User &#123;    ...&#125;如上， hhhh 则作为此 JavaBean的类型别名

映射器 mappers方式一：&lt;mappers&gt;    &lt;mapper resource=&quot;org/example/Dao/UserMapper.xml&quot;/&lt;/mappers&gt;方式二：&lt;mappers&gt;    &lt;mapper class=&quot;org.example.Dao.UserMapper&quot;/&gt;&lt;/mappers&gt;方式三：&lt;mappers&gt;    &lt;package name=&quot;org.example.Dao&quot;/&gt;&lt;/mappers&gt;

作用域和生命周期SqlSessionFactoryBuilderSqlSessionFactory 创建完 SqlSessionFactory 就不再需要它了。 因此最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。
SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。因此 SqlSessionFactory 的最佳作用域是应用作用域。可以把 SqlSessionFactory 看作一个资源池，一直都存在，只需要创建 SqlSession 和回收 SqlSession。
SqlSessionSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。可以看作资源池里面的资源，每次用完都要被回收，以便于下次使用。
结果映射 resultMapresultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作
让我们想象一个场景，多个人做一个项目，当做 JavaBean 的人与做数据库的不是同一个人，在起名上有一定的不同，我们无法做到将 JavaBean 或者数据库的字段名修改，这时我们就可以使用 resultMap
例如，我们数据库上有三个字段：”id”,”name”,”pwd”；JavaBean 中有三个参数：”id”,”name”,”password”，这时我们就不能用上面的 resultType我们在 mapper 标签里面加上：
&lt;resultMap id=&quot;UserMap&quot; type=&quot;org.example.pojo.User2&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;    &lt;result property=&quot;password&quot; column=&quot;pwd&quot;/&gt;&lt;/resultMap&gt;
column 是数据库里面的字段名，property 是 JavaBean 里面的参数名，如果参数名和字段名相同时可以省略不写然后把 resultType 修改成 resultMap
&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt;    select * from mybatis_lean.user where id = #&#123;id&#125;&lt;/select&gt;

日志日志工厂日志在我们平时运维或者查找报错中非常实用，我们只需要在日志中查看是哪部分出问题
在官方文档中，我们可以查看到如何开启日志，以及日志的种类SLF4JLOG4J（3.5.9 起废弃）LOG4J2JDK_LOGGINGCOMMONS_LOGGINGSTDOUT_LOGGINGNO_LOGGING
STDOUT_LOGGINGSTDOUT_LOGGING 是标准日志输出，不需要再注入其他依赖，直接就能跑起来
在 setting 标签里面配置（注意 setting 的位置）
&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;
配置好后运行代码
Log4jLog4j 在2021年12月8号被爆出堪称 史诗级核弹 漏洞，学习 Log4j 的原因很简单，因为使用的人多，例如 Apache Struts2、Apache Solr、Apache Druid、Apache Flink等，都用了 Log4j 或者 Log4j2
Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，我们可以控制每条日志的输出格式；只需要通过一个配置文件就可以灵活的配置，而不需要修改任何代码
第一步，先得导入 Log4j 的依赖https://mvnrepository.com/artifact/log4j/log4j/1.2.17
&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;

第二步，创建 Log4j 的配置文件
log4j.rootLogger=DEBUG,console,filelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%nlog4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/StudyLog4j.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%nlog4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG

第三步，生成 日志对象Logger，参数为当前类的 class 对象
static Logger logger = Logger.getLogger(UserMapperTest.class);

第四步，使用 Log4j
三个级别，info、debug 和 error
logger.info(&quot;info:测试使用Log4j记录日志&quot;);logger.debug(&quot;debug:测试使用Log4j记录日志&quot;);logger.error(&quot;error:测试使用Log4j记录日志&quot;);

结果：
分页limit 实现分页语法：select * from 表名 limit startIndex,pageSize;

与之前的一样，在 UserMapper 接口里面声明新方法
List&lt;User&gt; getUserByLimit(Map&lt;String, Integer&gt; map);
然后再 UserMapper.xml 里定义
&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultType=&quot;org.example.pojo.User&quot;&gt;    select * from mybatis_lean.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;

最后就可以测试了
SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;startIndex&quot;, 0);map.put(&quot;pageSize&quot;, 2);List&lt;User&gt; userByLimit = mapper.getUserByLimit(map);for (User user : userByLimit) &#123;    System.out.println(user);&#125;sqlSession.close();

RowBounds 实现分页limit 分页是物理分页，Rowbounds 分页是逻辑分页，Rowbounds 因为要把全部数据都跑一遍，效率比较慢，不推荐使用。
Rowbounds 可以通过 java 代码来实现
第一步，在接口里声明
List&lt;User&gt; getUserByRowBounds();
第二部，在 xml 文件里定义
&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;org.example.pojo.User&quot;&gt;    select * from mybatis_lean.user&lt;/select&gt;
第三步，使用
@Testpublic void getUserByRowBounds()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    RowBounds rowBounds = new RowBounds(1, 2);    List&lt;User&gt; User = sqlSession.selectList(&quot;org.example.Dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);    for (org.example.pojo.User user : User) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;
创建一个 RowBounds 对象时，两个参数分别为初始索引和长度
插件实现分页https://pagehelper.github.io/#:~:text=MyBatis%20%E5%88%86%E9%A1%B5我们可以使用第三方插件进行分页，例如：PageHelper，这里不做过多的介绍，用到再了解。
使用注解开发ok，前面的配置文件编写已经特别熟练了但是，通通白学，接下来是特别简单，步骤没有这么繁琐的注解开发
我们可以把配置文件删了，只需要一个接口文件，在接口文件里面声明的方法的头上写上注解
@Select(&quot;select * from user&quot;)List&lt;User&gt; getUser();
然后在类像之前一样里面正常使用，不需要搞配置文件
@Testpublic void testSelect() &#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    List&lt;User&gt; user = mapper.getUser();    for (User user1 : user) &#123;        System.out.println(user1);    &#125;    sqlSession.close();&#125;
使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。
用注解开发做增删改查只需要变动接口文件 UserMapper ，配置文件 UserMapper.xml 可以删去
@Select(&quot;select * from user&quot;)List&lt;User&gt; getUser();@Select(&quot;insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)void insertUser(User user);@Select(&quot;delete from user where id=#&#123;id&#125;&quot;)void deleteUser(@Param(&quot;id&quot;) int id);@Select(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&quot;)void updateUser(User user);@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)User getUserById(int id);
我们在删除方法 deleteUser 的参数框里写了一个 @Param(“id”) ，当我们使用注解开发时，如果有基本类型参数，尽量在每一个参数前加上 @Param(“”)
以 deleteUser(@Param(“id”) int id) 为例，如果我们把后面的 id 改成其他比如 id2 ，代码正常运行，但如果我们改 @Param(“id”) 改成 为  @Param(“id2”) 则会报错，这时因为我们在SQL中引用的就是 @Param(“”) 中定义的属性名，外面的 id 变成一个形参，形参叫什么都无所谓
如果把 @Select 改成其他，例如 @Update 代码，则需要手动提交或者我们在 MybatisUtils 类里面把
openSession里的参数填 truereturn sqlSessionFactory.openSession(true)public static SqlSession getSqlSession() &#123;        return sqlSessionFactory.openSession();&#125;

联合查询多对一假设环境，我们希望查询所有学生的信息，包括学生元素下的老师信息（学生的老师）1、创建表
CREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO student VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO student VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO student VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO student VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);
2、创建接口在 Dao 包下创建接口文件
package org.example.Dao;import org.example.pojo.Student;import java.util.List;public interface StudentMapper &#123;    List&lt;Student&gt; getStudent();&#125;


3、配置文件在 resource 下创建一个文件，路径与接口文件路径一致
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.example.Dao.StudentMapper&quot;&gt;    &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;        select * from mybatis_lean.student    &lt;/select&gt;        &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;org.example.pojo.Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;        &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;org.example.pojo.Teacher&quot; select=&quot;getTeacher&quot;/&gt;    &lt;/resultMap&gt;        &lt;select id=&quot;getTeacher&quot; resultType=&quot;org.example.pojo.Teacher&quot;&gt;        select * from mybatis_lean.teacher where id = #&#123;tid&#125;    &lt;/select&gt;&lt;/mapper&gt;
resultMap 是用来定义数据库查询结果到Java对象的映射关系如上：在 resultMap 里association的作用是通过 getTeacher 来筛选出老师，然后进行匹配
运行结果：
一对多假设环境，我们希望查询所老师的信息，包括老师元素下的学生信息
按照结果嵌套List&lt;Teacher&gt; getTeachers(@Param(&quot;tid&quot;) int id);
&lt;select id=&quot;getTeachers&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select s.id sid, s.name sname, t.name tname, t.id tid    from mybatis_lean.student s, mybatis_lean.teacher t    where s.tid = t.id    and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;org.example.pojo.Teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;org.example.pojo.Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;

按照查询嵌套&lt;select id=&quot;getTeachers&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select * from mybatis_lean.teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;org.example.pojo.Teacher&quot;&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot;     ofType=&quot;org.example.pojo.Student&quot; select=&quot;getStudentByTId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTId&quot; resultType=&quot;org.example.pojo.Student&quot;&gt;    select * from mybatis_lean.student where id = #&#123;tid&#125;&lt;/select&gt;

动态SQL动态SQL是指根据不同条件生成不同的SQL语句
创建环境这里主要展示表格和 JavaBean 实体类
CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8;
public Blog(String id, String title, String author, Date createTime, int views) &#123;    this.id = id;    this.title = title;    this.author = author;    this.createTime = createTime;    this.views = views;&#125;
IF假设条件，以上面为例，我们需要用一条 SQL 语句来实现，如果我们传的参数有 title 或者 author ，则返回含有参数的数据，如果参数没有，则返回全部数据
这时候，就体现到动态规划的好处了首先，我们先编写接口方法，我们需要拿一个 map 来装数据
List&lt;Blog&gt; queryBlog(Map map);
然后就是最重要的配置文件了
&lt;select id=&quot;queryBlog&quot; resultType=&quot;org.example.pojo.Blog&quot; parameterType=&quot;map&quot; &gt;    select * from mybatis_lean.blog where 1=1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;
如上所示，想要完成开头提到的需求，那我们必不可少的需要判断来处理 &lt;if test=&quot;&quot;&gt; 这个当成固定格式就行了，因为那你每次使用 IF 的时候都少不了 test=&quot;&quot;test 里面装的就是我们的判断条件了，当然，我们也可以嵌套判断
为什么 where 后面要跟一个 1=1 呢，其实不跟也可以，但是我们需要在每一个 IF 判断里面的开头写上 where 那就显得太麻烦了，加上一个 1=1 也丝毫不会影响原来的语句
where或者，我们也可以使用 &lt;where&gt; 标签， &lt;where&gt; 标签可以自动检查后面跟随的子语句前有没有 AND 或者 OR，例如： 
&lt;select id=&quot;queryBlog&quot; resultType=&quot;org.example.pojo.Blog&quot; parameterType=&quot;map&quot; &gt;    select * from mybatis_lean.blog where     &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            and author = #&#123;author&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;
如上，最理想的情况是第一个和第二个都满足，程序继续运行，但是，如果只满足第二个而不满足第一个，我们会发现 where 后面直接跟 and ，这怎么看都是错的，我们的 &lt;where&gt; 标签就可以判断后面的子语句前是否有 AND 或 OR ，如果发现及删去，如果 IF 一个都不满足，后面没有跟子语句了， &lt;where&gt; 标签就会把 where 删去
setset 标签和 where 标签差不多，但是可以每一个条件都满足， set 标签是用于 update 语句里面的，例如：
&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update mybatis_lean.blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;,        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;                author = #&#123;author&#125;,        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;
我们需要更新当 id 等于我们所传的 id ，这时我们唯一一个需要确定的条件，标签里面的两个条件 title 和 author 不输入也不会报错set 标签主要的功能是如果有子语句，那么将会在最前面加上（或删除） set ，然后在每一个需要子语句加逗号的子语句后面加上（或删除）逗号
choosechoose 的选择是互斥的，满足了第一个就不会去看后面的判断
choose 与 when 和 otherwise 搭配当 when 条件满足时进入 when 里的子语句，如果有多个 when 都满足条件，只进入第一个，otherwise 是当所有 when 条件都没有满足时则进入，相当于是 Java 里 if 的 else
假设，我们现在需要一个方法，当我们传的参数有 title 并且不为空，则从表格里查找出所在一行；如果没有传 title 而是传了 author ，我们也需要找出 author ；如果都没有传，我们需要把表格所有内容返回
&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;org.example.pojo.Blog&quot;&gt;    select * from mybatis_lean.blog where    &lt;choose&gt;        &lt;when test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;        &lt;/when&gt;        &lt;when test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;        &lt;/when&gt;        &lt;otherwise&gt;            1=1        &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;

sql上面的配置文件里面，我们会发现有很多地方的有杂糅，每个标签里面都有相同的地方，为了减少代码杂糅，我们可以使用 sql 标签，把相同的地方提出来以上面为例，我们会发现 if 标签里面的 title 和 author ，我们使用的频率很大，那么我们就可以使用 sql 标签提出来 
&lt;sql id=&quot;if-title-author&quot;&gt;    &lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;
提取后需要用 include 标签来使用
&lt;select id=&quot;queryBlog&quot; resultType=&quot;org.example.pojo.Blog&quot; parameterType=&quot;map&quot; &gt;    select * from mybatis_lean.blog    &lt;where&gt;        &lt;include refid=&quot;if-title-author&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;

foreach动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）
案例：我们现在需要一个方法，需要返回我们传的 ID 所对应的信息
&lt;select id=&quot;queryBlogById&quot; resultType=&quot;org.example.pojo.Blog&quot; parameterType=&quot;map&quot;&gt;    select * from mybatis_lean.blog    &lt;where&gt;        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;            id = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;

缓存mybatis 为了提高数据库性能和减少数据压力提供一级缓存和二级缓存
一级缓存一级缓存是 SqlSession 级别的缓存，作用域是同一个 SqlSession ，在同一个 sqlSession 中连续两次执行相同的sql语句，第一次执行完毕会将数据写到缓存，第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。
Mybatis默认开启一级缓存
一级缓存只是相对于同一个 SqlSession 而言。所以在参数和 SQL 完全一样的情况下，我们使用同一个 SqlSession 对象调用一个 Mapper 方法，往往只执行一次 SQL ，因为使用 SelSession 第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。
例如：
// 通过ID来查询User selectById(@Param(&quot;id&quot;) int id);// 更新数据int updateUser(User user);
SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.selectById(1);System.out.println(user);System.out.println(&quot;==============================&quot;);User user2 = mapper.selectById(1);System.out.println(user2);sqlSession.close();
我们会发现，明明查询语句跑了两遍，但日志里面却只跑了一边，第二次进行查询语句的时候并没有想第一次一样在数据库中查找，而是第一次跑完的记录存在缓存里面，第二次直接在缓存里面读取
样例二：我们在两次查询语句中插入一条修改语句，缓存是否还能够使用
SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.selectById(1);System.out.println(user);System.out.println(&quot;==============================&quot;);mapper.updateUser(new User(5, &quot;Lily&quot;, &quot;202020&quot;));System.out.println(&quot;==============================&quot;);User user2 = mapper.selectById(1);System.out.println(user2);sqlSession.close();
运行结果：
通过日志我们可得知，三条语句都进入了数据库中查找
二级缓存二级缓存也叫全局缓存，二级缓存是基于 namespace ，一个命名空间对应着一个二级缓存开启二级缓存后，释放完一个 sqlsession 后，一级缓存将会存入二级缓存内，重新开启一个相同 mapper 将会读取二级缓存 
1、开启全局缓存
在 mybatis-config.xml 下的 setting 标签内加入
&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;

2、在 Mapper 文件里面开启
&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;
注：FIFO (first in first out)
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/06/articles/Mybatis/test2/</url>
    <content><![CDATA[Mybatis的小笔记association 与 collectionassociation用于一对一或多对一，当一个对象包含另一个对象作为其属性时，可以使用association例如：一个User类有一个Address类的属性，表示用户有一个地址
collection用于一对多，当一个对象包含多个相同类型的对象作为其属性时，可以使用collection例如：一个User类有一个Order列表的属性，表示一个用户可以有多个订单
javaType 与 ofType在MyBatis的映射文件中，javaType和ofType是两个经常与association和collection元素一起使用的属性，它们用于指定映射的目标类型，但它们的使用场景和含义有所不同。
javaType：用来指定实体类（JavaBean）中属性的类型ofType：用来指定映射容器里面实体类（JavaBean）中的类型，泛型中的约束类型
]]></content>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/2025/01/25/articles/SpringBoot/SpringBoot/</url>
    <content><![CDATA[体验SpringBoot创建项目所有的SpringBoot依赖都是以starter的形式命名的，之后我们需要导入其他模块也是导入 spring boot-starter-xxxx 这种名称格式的依赖。
SpringBoot为我们提供了包含内置Tomcat服务器的Web模块，我们只需要导入依赖就能直接运行服务器把原来的
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt;
换成
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;
点击启动后可以看到已经启动了内置的 tomcat
在浏览器上打开 localhost:8080 可以访问可以看到成功响应了404页面，相比之前的大量配置，可以说方便了很多，我们到目前为止仅仅是导入了一个依赖，就可以做到直接启动我们的Web服务器并正常访问
SpringBoot支持自动包妇描，我们不需要编写任何配置，直接在任意路径(但是不能跑到主类所在包外面去了)下创建的组件(如Controller、Service、Component、Configuration等)都可以生效
比如创建一个Controller
package com.example.demo.controller;    import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.ResponseBody;    @Controller  public class TestController &#123;        @ResponseBody      @GetMapping(&quot;/&quot;)      public String index() &#123;          return &quot;Hello World!&quot;;      &#125;  &#125;

然后我们不需要扫描，直接启动
包括一个对象现在也可以直接以JSON形式返回给客户端，无需任何配置，如果启动不成功或者页面没有显示，请检查Lombok是否有正确启动（我用的时候就是没有找到构造方法和getter&#x2F;setter，推测原因是Lombok）
@Controller  public class TestController &#123;        @ResponseBody      @GetMapping(&quot;/&quot;)      public Student index() &#123;          return new Student(1, &quot;呵帅&quot;, &quot;男&quot;);      &#125;  &#125;


常用模块整合spring-boot-starter-web包含了以下依赖
&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;6.2.2&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;6.2.2&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;

里面包含了以下内容

spring-boot-starter 基础依赖starter
spring-boot-starter-json 配置JSON转换的starter
spring-boot-starter-tomcat 内置Tomcat服务器
spring-web、spring-webmvc 之前mvc的内容

如果需要像之前一样添加WebMvc配置类，方法是一样的，直接创建
package com.example.demo.config;    import jakarta.servlet.http.HttpServletRequest;  import jakarta.servlet.http.HttpServletResponse;  import org.springframework.context.annotation.Configuration;  import org.springframework.web.servlet.HandlerInterceptor;  import org.springframework.web.servlet.config.annotation.InterceptorRegistry;  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;    //只需要添加Configuration用于注册配置类，不需要其他任何注解，已经自动配置好了  @Configuration  public class WebConfiguration implements WebMvcConfigurer &#123;      @Override      public void addInterceptors(InterceptorRegistry registry) &#123;          registry.addInterceptor(new HandlerInterceptor() &#123;              @Override              public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;                  System.out.println(&quot;请求被拦截&quot;);                  return HandlerInterceptor.super.preHandle(request, response, handler);              &#125;          &#125;);      &#125;  &#125;

同样security也是一样的，首先添加依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;  &lt;/dependency&gt;

导入完依赖直接启动
我们没有进行任何配置，而是对应的Starter帮助我们完成了默认的配置，并且在启动时，就已经帮助我们配置了一个随机密码的用户可以直接登录使用（Username是user）
如果需要额外进行配置，只需要添加配置类即可
package com.example.demo.config;    import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.security.config.annotation.web.builders.HttpSecurity;  import org.springframework.security.web.SecurityFilterChain;    @Configuration  public class SecurityConfiguration &#123;        @Bean      public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;          return http                  .authorizeHttpRequests(auth -&gt; &#123;                      auth.anyRequest().authenticated();                  &#125;)                  .formLogin(conf -&gt; &#123;                      conf.loginPage(&quot;/login&quot;);                      conf.loginProcessingUrl(&quot;/doLogin&quot;);                      conf.defaultSuccessUrl(&quot;/&quot;);                      conf.permitAll();                  &#125;)                  .build();      &#125;  &#125;

同样的，我们也可以快速整合之前使用的模版引擎，比如Thymeleaf框架，直接上对应的Starter即可
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;  &lt;/dependency&gt;

自定义运行器在项目中，可能会遇到这样一个问题:我们需要在项目启动完成之后，紧接着执行一段代码，我们可以编写自定义的ApplicationRunner，会在项目启动完成后执行
@Component  public class TestRunner implements ApplicationRunner &#123;      @Override      public void run(ApplicationArguments args) throws Exception &#123;          System.out.println(&quot;自定义执行&quot;);      &#125;  &#125;

当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行
配置文件虽然SpringBoot快捷开发确实很方便，不过我们发现有些东西还是需要我们自己来编写配置才可以，不然SpringBoot项目无法正常启动。我们可以直接在application.properties 中进行配置编写，它是整个SpringBoot的配置文件，比如要修改服务器的默认端口:

这些配置其实都是各种Starter提供的，部分配置在Starter中具有默认值，我们即使不配置也会使用默认值，比如这里的8080就是我们服务器的默认端口，我们也可以手动修改它，来变成我们需要的。
除了配置已经存在的选项，我们也可以添加自定义的配置，来方便我们程序中使用，比如我们这里创建一个测试数据:
test.hello=8080

@Controller  public class TestController &#123;        @Value(&quot;$&#123;test.hello&#125;&quot;)      String hello;        @GetMapping(&quot;/login&quot;)      public String login() &#123;          System.out.println(hello);          return &quot;login&quot;;      &#125;  &#125;

配置文件除了使用 properties 格式以外，还有一种叫做 yaml 格式，它的语法如下
一级目录:	二级目录:		三级目录1:值		三级目录2:值		三级目录List:	- 元素1	- 元素2	- 元素3
我们可以看到，每一级目录都是通过缩进(不能使用Tab，只能使用空格)区分，并且键和值之间需要添加冒号+空格来表示
例如:
server:    port: 8080  Spring:    datasource:      url: jdbc:mysql://localhost:3306/test      username: root      password: Abc123      driver-class-name: com.mysql.cj.jdbc.Driver

注意如果你的数据库密码是以0开头或者0x开头会被默认转义为八进制和十六进制,要用引号把密码引起来
常见的配置项SpringSecurity和SpringBootMvc配置
spring:    # Spring Mvc相关配置    mvc:      static-path-pattern: /static/**  # 静态资源访问路径    # Spring Security相关配置    security:      filter:        order: -100  # 过滤优先级，数字越小优先级越高      user:        name: &#x27;admin&#x27;  # 登录用户名        password: &#x27;123456&#x27;  # 登录密码        roles:   # 登录用户角色          - admin          - user

mybatis整合Mybatis需要把本身的驱动加上
&lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;3.0.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;  &lt;/dependency&gt;

server:    port: 8080  Spring:    datasource:      url: jdbc:mysql://localhost:3306/test      username: root      password: Abc123      driver-class-name: com.mysql.cj.jdbc.Driver

这里我们接续来测试一下MyBatis的配置，想要在SpringBoot中使用Mybatis也很简单，不需要进行任何配置，我们直接编写Mapper即可直接为需要注册为Mapper的接口添加 @Mapper 注解，来表示这个接口作为Mapper使用
@Mapper  public interface UserMapper &#123;      @Select(&quot;select * from test where id = #&#123;id&#125;&quot;)      User findUserById(int id);  &#125;

测试：
@Resource  UserMapper mapper;@ResponseBody  @GetMapping(&quot;/test&quot;)  public User test() &#123;      return mapper.findUserById(1);  &#125;

注：如果运行失败，检查是否是maven依赖版本不兼容
打包运行我们可以使用maven工具

然后在当前目录下的命令行中输入：java -jar 包名.jar
GraalVM我们SpringBoot项目除了打包为传统的Jar包基于JVM运行之外，我们也可以将其直接编译为操作系统原生的程序来进行使用(这样会大幅提升程序的运行效率，但是由于编译为操作系统原生程序，这将无法支持跨平台)
具体内容：十分钟带你了解 Oracle 最新的 JVM 技術——GraalVM - 知乎
还未广泛运用，了解为主
日志系统我们在之前学习SSM时，如果不配置日志，就会报错，但是到了SpringBoot阶段之后日志打印得也非常统一，不会出现这个问题
日志门面和日志实现日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有lqg4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。
SpringBoot为了统一日志框架的使用，做了这些事情

直接将其他依赖以前的日志框架剔除
导入对应日志框架的Slf4i中间包
导入自己官方指定的日志实现，并作为Slf4j的日志实现层

日志级别从低到高分为TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL， SpringBoot默认只会打印INFO以上级别的信息
如果想要输出日志信息像之前JUL一样就行了
@Slf4j  @Controller  public class TestController &#123;  @PostConstruct      public void init() &#123;          log.info(&quot;日志信息&quot;);      &#125;  &#125;

配置 logback日志和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Profile功能，它的内容类似于这样:logback-spring.xml
最外层由 configuration 包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。在org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;defaults.xml 中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的appender 即可:
&lt;configuration&gt;      &lt;!--  导入其他配置文件，作为预设  --&gt;      &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;        &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#125;&#125;)&#123;faint&#125; %clr([%X&#123;reqId&#125;])&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;)&#123;&#125; %clr($&#123;PID:-&#125;)&#123;magenta&#125; %clr(--- %esb()&#123;APPLICATION_NAME&#125;%esb&#123;APPLICATION_GROUP&#125;[%15.15t] $&#123;LOG_CORRELATION_PATTERN:-&#125;)&#123;faint&#125;%clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&quot;/&gt;        &lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;      &lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;      &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;          &lt;encoder&gt;            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt;              &lt;charset&gt;$&#123;CONSOLE_LOG_CHARSET&#125;&lt;/charset&gt;          &lt;/encoder&gt;    &lt;/appender&gt;      &lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;      &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;          &lt;encoder&gt;            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;              &lt;charset&gt;$&#123;FILE_LOG_CHARSET&#125;&lt;/charset&gt;          &lt;/encoder&gt;        &lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;          &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;              &lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;              &lt;FileNamePattern&gt;log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log&lt;/FileNamePattern&gt;              &lt;!--  到期自动清理日志文件  --&gt;              &lt;cleanHistoryOnStart&gt;true&lt;/cleanHistoryOnStart&gt;              &lt;!--  最大日志保留时间  --&gt;              &lt;maxHistory&gt;7&lt;/maxHistory&gt;              &lt;!--  最大单个日志文件大小  --&gt;              &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;          &lt;/rollingPolicy&gt;    &lt;/appender&gt;      &lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;      &lt;root level=&quot;INFO&quot;&gt;          &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;          &lt;appender-ref ref=&quot;FILE&quot;/&gt;      &lt;/root&gt;&lt;/configuration&gt;

配置完，运行就会生成一个日志文件
比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制“Mapped Diagnostic Context”（映射诊断上下文）：
@Slf4j  @Controller  public class TestController &#123;        @GetMapping(&quot;/&quot;)      @ResponseBody      public String hello(HttpSession session) &#123;          MDC.put(&quot;reqId&quot;, session.getId());          log.info(&quot;访问了一次测试接口&quot;);          return &quot;Hello World&quot;;      &#125;  &#125;

自定义Banner展示可以直接来配置文件所在目录下创建一个名为banner.txt的文本文档，内容随便
$&#123;AnsiColor.yellow&#125;  //                          _ooOoo_                               //  //                         o8888888o                              //  //                         88&quot; . &quot;88                              //  //                         (| ^_^ |)                              //  //                         O\  =  /O                              //  //                      ____/`---&#x27;\____                           //  //                    .&#x27;  \\|     |//  `.                         //  //                   /  \\|||  :  |||//  \                        //  //                  /  _||||| -:- |||||-  \                       //  //                  |   | \\\  -  /// |   |                       //  //                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //  //                  \  .-\__  `-`  ___/-. /                       //  //                ___`. .&#x27;  /--.--\  `. . ___                     //  //              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //  //            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //  //            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //  //      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //  //                           `=---=&#x27;                              //  //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //  //             佛祖保佑          永无BUG         永不修改             //  $&#123;AnsiColor.black&#125;

可以使用在线生成网站进行生成自己的个性Banner：https://www.bootschool.net/ascii
切换颜色
$&#123;AnsiColor.BRIGHT_GREEN&#125; //绿色

常用配置
$&#123;AnsiColor.YELLOW&#125; 当前 Spring Boot 版本：$&#123;spring-boot.version&#125;

多环境配置在日常开发中，我们项目会有多个环境。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。
SpringBoot给我们提供了一种方式，在 application.yml下，我们可以通过配置文件指定
spring:  profiles:    active: dev

我们分别创建两个环境的配置文件，application-dev.yml和application-prod.yml分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：
server: port: 8080

server: port: 8888

SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：
&lt;springProfile name=&quot;dev&quot;&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;    &lt;/root&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;prod&quot;&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;    &lt;/root&gt;&lt;/springProfile&gt;

我们希望生产环境中不要打包开发环境下的配置文件呢，打包的问题就只能找Maven解决了，Maven也可以设置多环境：在 pom.xml 中 project 里任意位置
&lt;!--分别设置开发，生产环境--&gt;&lt;profiles&gt;    &lt;!-- 开发环境 --&gt;    &lt;profile&gt;        &lt;id&gt;dev&lt;/id&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;        &lt;/activation&gt;        &lt;properties&gt;            &lt;environment&gt;dev&lt;/environment&gt;        &lt;/properties&gt;    &lt;/profile&gt;    &lt;!-- 生产环境 --&gt;    &lt;profile&gt;        &lt;id&gt;prod&lt;/id&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;        &lt;/activation&gt;        &lt;properties&gt;            &lt;environment&gt;prod&lt;/environment&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;

在 pom.xml 中的 build 中
&lt;resources&gt;&lt;!--排除配置文件--&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;!--先排除所有的配置文件--&gt;        &lt;excludes&gt;            &lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;            &lt;exclude&gt;application*.yml&lt;/exclude&gt;        &lt;/excludes&gt;    &lt;/resource&gt;    &lt;!--根据激活条件引入打包所需的配置和文件--&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;!--引入所需环境的配置文件--&gt;        &lt;filtering&gt;true&lt;/filtering&gt;        &lt;includes&gt;            &lt;include&gt;application.yml&lt;/include&gt;            &lt;!--根据maven选择环境导入配置文件--&gt;            &lt;include&gt;application-$&#123;environment&#125;.yml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;

接着，我们可以直接将Maven中的environment属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：
spring:  profiles:    active: &#x27;@environment@&#x27;  #注意YAML配置文件需要加单引号，否则会报错

注意切换环境之后要重新加载一下Maven项目，不然不会生效！
常用框架邮件发送模块&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;

比较常用的协议有两种：

SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）
POP3协议（主要用于接收邮件 Post Office Protocol 3）

spring:    mail:      host: 去百度搜索该邮箱的smtp    username: 邮箱      password: 密码（并非账号的密码）

@SpringBootTest  class Demo1ApplicationTests &#123;        @Autowired      JavaMailSender sender;        @Test      void contextLoads() &#123;          //SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容          SimpleMailMessage message = new SimpleMailMessage();          //设置邮件标题          message.setSubject(&quot;【广东白云学院教务处】关于近期学校对您的处分决定&quot;);          //设置邮件内容          message.setText(&quot;同学您好，完美校园数据显示您在本学期以来在本校食堂消费超过503次，积累消费金额超过3000元，您已被评为“校园大饭桶”，特此通知予以嘉奖。奖品将在3月1日西校区一品堂门口发放，感谢您对学校餐厅工作的支持！&quot;);          //设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱          message.setTo(&quot;邮箱@qq.com&quot;);          //邮件发送者，这里要与配置文件中的保持一致          message.setFrom(&quot;发送的邮箱@qq.cn&quot;);                    sender.send(message);      &#125;  &#125;

如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成
@Testvoid contextLoads() throws MessagingException &#123;      //创建一个MimeMessage    MimeMessage message = sender.createMimeMessage();      //使用MimeMessageHelper来帮我们修改MimeMessage中的信息    MimeMessageHelper helper = new MimeMessageHelper(message, true);    helper.setSubject(&quot;Test&quot;);    helper.setText(&quot;lbwnb&quot;);    helper.setTo(&quot;你的QQ号@qq.com&quot;);    helper.setFrom(&quot;发送的邮箱@163.com&quot;);      //发送修改好的MimeMessage    sender.send(message);&#125;

接口规则校验所需依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;

如下面代码所示，我们要将接收到的字符串作切割，但是如果接收的字符串长度不满足切割条件时，或者说用户没有按照我们所设想来传参，那么就会直接报错
@ResponseBody@PostMapping(&quot;/submit&quot;)public String submit(String username,                     String password)&#123;    System.out.println(username.substring(3));    System.out.println(password.substring(2, 10));    return &quot;请求成功!&quot;;&#125;

这是最简单的解决方法是做个判断：
@ResponseBody@PostMapping(&quot;/submit&quot;)public String submit(String username,                     String password)&#123;    if(username.length() &gt; 3 &amp;&amp; password.length() &gt; 10) &#123;        System.out.println(username.substring(3));        System.out.println(password.substring(2, 10));        return &quot;请求成功!&quot;;    &#125; else &#123;        return &quot;请求失败&quot;;    &#125;&#125;

虽然这样就能直接解决问题，但是如果我们的每一个接口都需要这样去进行配置就太麻烦了，Springboot 为我们提供了很方便的接口校验框架，我们可以使用注解开发完成全部接口的校验：
@Slf4j@Validated   //首先在Controller上开启接口校验@Controllerpublic class TestController &#123;    ...    @ResponseBody    @PostMapping(&quot;/submit&quot;)    public String submit(@Length(min = 3) String username,  //使用@Length注解一步到位                         @Length(min = 10) String password)&#123;        System.out.println(username.substring(3));        System.out.println(password.substring(2, 10));        return &quot;请求成功!&quot;;    &#125;&#125;

不过这样依然会抛出一个异常，我们可以稍微处理一下，这里我们可以直接使用之前在SSM阶段中学习的异常处理Controller来自行处理这类异常：
@ControllerAdvicepublic class ValidationController &#123;    @ResponseBody    @ExceptionHandler(ConstraintViolationException.class)    public String error(ValidationException e)&#123;        return e.getMessage();   //出现异常直接返回消息    &#125;&#125;




验证注解
验证的数据类型
说明



@AssertFalse
Boolean,boolean
值必须是false


@AssertTrue
Boolean,boolean
值必须是true


@NotNull
任意类型
值不能是null


@Null
任意类型
值必须是null


@Min
BigDecimal、BigInteger、byte、short、int、long、double 以及任何Number或CharSequence子类型
大于等于@Min指定的值


@Max
同上
小于等于@Max指定的值


@DecimalMin
同上
大于等于@DecimalMin指定的值（超高精度）


@DecimalMax
同上
小于等于@DecimalMax指定的值（超高精度）


@Digits
同上
限制整数位数和小数位数上限


@Size
字符串、Collection、Map、数组等
长度在指定区间之内，如字符串长度、集合大小等


@Past
如 java.util.Date, java.util.Calendar 等日期类型
值必须比当前时间早


@Future
同上
值必须比当前时间晚


@NotBlank
CharSequence及其子类
值不为空，在比较时会去除字符串的首位空格


@Length
CharSequence及其子类
字符串长度在指定区间内


@NotEmpty
CharSequence及其子类、Collection、Map、数组
值不为null且长度不为空（字符串长度不为0，集合大小不为0）


@Range
BigDecimal、BigInteger、CharSequence、byte、short、int、long 以及原子类型和包装类型
值在指定区间内


@Email
CharSequence及其子类
值必须是邮件格式


@Pattern
CharSequence及其子类
值需要与指定的正则表达式匹配


@Valid
任何非原子类型
用于验证对象属性


此时接口是以对象形式接收前端发送的表单数据的，这个时候就没办法向上面一样编写对应的校验规则了
@Datapublic class Account &#123;    @Length(min = 3)   //只需要在对应的字段上添加校验的注解即可    String username;    @Length(min = 10)    String password;&#125;

@ResponseBody@PostMapping(&quot;/submit&quot;)  //在参数上添加@Valid注解表示需要验证public String submit(@Valid Account account)&#123;    System.out.println(account.getUsername().substring(3));    System.out.println(account.getPassword().substring(2, 10));    return &quot;请求成功!&quot;;&#125;

然后修改之前的错误处理，对于实体类接收参数的验证，会抛出MethodArgumentNotValidException 异常也加进去
@ResponseBody@ExceptionHandler(&#123;ConstraintViolationException.class, MethodArgumentNotValidException.class&#125;)public String error(Exception e)&#123;    if(e instanceof ConstraintViolationException exception) &#123;        return exception.getMessage();    &#125; else if(e instanceof MethodArgumentNotValidException exception)&#123;        if (exception.getFieldError() == null) return &quot;未知错误&quot;;        return exception.getFieldError().getDefaultMessage();    &#125;    return &quot;未知错误&quot;;&#125;

接口文档生成（肥肠豪用）所需依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;    &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;

Swagger的主要功能如下：

支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。
提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。

结合Spring框架（Spring-doc，官网：https://springdoc.org/Swagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。
项目启动之后，我们可以直接访问：http://localhost:8080/swagger-ui/index.html 就可以看到开发文档了
修改Swagger的UI界面
@Configurationpublic class SwaggerConfiguration &#123;    @Bean    public OpenAPI springDocOpenAPI() &#123;        return new OpenAPI().info(new Info()                .title(&quot;图书管理系统 - 在线API接口文档&quot;)   //设置API文档网站标题                .description(&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;) //网站介绍                .version(&quot;2.0&quot;)   //当前API版本                .license(new License().name(&quot;我的B站个人主页&quot;)  //遵循的协议，这里拿来写其他的也行                        .url(&quot;https://space.bilibili.com/288205652&quot;)));    &#125;&#125;

为Controller编写API描述信息
//使用@Tag注解来添加Controller描述信息@Tag(name = &quot;账户验证相关&quot;, description = &quot;包括用户登录、注册、验证码请求等操作。&quot;)public class TestController &#123;	...&#125;

我们可以直接在类名称上面添加@Tag注解，并填写相关信息，来为当前的Controller设置描述信息。接着我们可以为所有的请求映射配置描述信息：
@ApiResponses(&#123;       @ApiResponse(responseCode = &quot;200&quot;, description = &quot;测试成功&quot;),       @ApiResponse(responseCode = &quot;500&quot;, description = &quot;测试失败&quot;)   //不同返回状态码描述&#125;)@Operation(summary = &quot;请求用户数据测试接口&quot;)   //接口功能描述@ResponseBody@GetMapping(&quot;/hello&quot;)//请求参数描述和样例public String hello(@Parameter(description = &quot;测试文本数据&quot;, example = &quot;KFCvivo50&quot;) @RequestParam String text) &#123;    return &quot;Hello World&quot;;&#125;

对于那些不需要展示在文档中的接口，我们也可以将其忽略掉：
@Hidden@ResponseBody@GetMapping(&quot;/hello&quot;)public String hello() &#123;    return &quot;Hello World&quot;;&#125;

对于实体类，我们也可以编写对应的API接口文档：
@Data@Schema(description = &quot;用户信息实体类&quot;)public class User &#123;    @Schema(description = &quot;用户编号&quot;)    int id;    @Schema(description = &quot;用户名称&quot;)    String name;    @Schema(description = &quot;用户邮箱&quot;)    String email;    @Schema(description = &quot;用户密码&quot;)    String password;&#125;

不过，这种文档只适合在开发环境下生成，如果是生产环境，我们需要关闭文档：
springdoc:  api-docs:    enabled: false


数据交互JDBC交互框架所需依赖
&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&lt;/dependency&gt;

spring:    datasource:      url: jdbc:mysql://localhost:3306/test      username: root      password: Abc123      driver-class-name: com.mysql.cj.jdbc.Driver

spring-jdbc 把所有的增删改查都加入到一个模板类里，并且已经注册好了
@Resource  JdbcTemplate template;

通过 template 调用已经封装好的方法，现在我们可以只写 SQL 语句了，相当于省略掉了 mapper
@Testvoid contextLoads() &#123;	int id = 1;    Map&lt;String, Object&gt; map = template.queryForMap(&quot;select * from user where id = ?&quot;, id);    System.out.println(map);&#125;

也可以自定义
@Data@AllArgsConstructorpublic class User &#123;    int id;    String name;    String email;    String password;&#125;

@Testvoid contextLoads() &#123;    User user = template.queryForObject(&quot;select * from user where id = ?&quot;,        (r, i) -&gt; new User(r.getInt(1), r.getString(2), r.getString(3), r.getString(4)), 1);    System.out.println(user);&#125;

简单封装对于一些插入操作，Spring JDBC为我们提供了更方便的SimpleJdbcInsert工具，比如我们的表是采用自增的ID，那么它支持插入后返回自动生成的ID
@Configurationpublic class WebConfiguration &#123;    @Resource    DataSource source;    @Test    void contextLoads() &#123;      	//这个类需要自己创建对象        SimpleJdbcInsert simple = new SimpleJdbcInsert(source)                .withTableName(&quot;user&quot;)   //设置要操作的表名称                .usingGeneratedKeyColumns(&quot;id&quot;);    //设置自增主键列        Map&lt;String, Object&gt; user = new HashMap&lt;&gt;(2);  //插入操作需要传入一个Map作为数据        user.put(&quot;name&quot;, &quot;bob&quot;);        user.put(&quot;email&quot;, &quot;112233@qq.com&quot;);        user.put(&quot;password&quot;, &quot;123456&quot;);        Number number = simple.executeAndReturnKey(user);   //最后得到的Numver就是得到的自增主键        System.out.println(number);    &#125;&#125;


JPA框架官网：https://spring.io/projects/spring-data-jpa
而实现JPA规范的框架一般最常用的就是Hibernate
所需依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;

&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&lt;/dependency&gt;

使用JPA快速上手我们通过注解形式，在属性上添加数据库映射关系
@Data@Entity   //表示这个类是一个实体类@Table(name = &quot;account&quot;)    //对应的数据库中表名称public class Account &#123;    @GeneratedValue(strategy = GenerationType.IDENTITY)   //生成策略，这里配置为自增    @Column(name = &quot;id&quot;)    //对应表中id这一列    @Id     //此属性为主键    int id;    @Column(name = &quot;username&quot;)   //对应表中username这一列    String username;    @Column(name = &quot;password&quot;)   //对应表中password这一列    String password;&#125;

修改配置文件，把日志打印打开
spring:  jpa:    #开启SQL语句执行日志信息    show-sql: true    hibernate:      #配置为检查数据库表结构，没有时会自动创建      ddl-auto: update

ddl-auto属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有以下几种：

none: 不执行任何操作，数据库表结构需要手动创建。
create: 框架在每次运行时都会删除所有表，并重新创建。
create-drop: 框架在每次运行时都会删除所有表，然后再创建，但在程序结束时会再次删除所有表。
update: 框架会检查数据库表结构，如果与实体类定义不匹配，则会做相应的修改，以保持它们的一致性。
validate: 框架会检查数据库表结构与实体类定义是否匹配，如果不匹配，则会抛出异常。

创建一个Repository接口来继承 JpaRepository 泛型，第一个参数是实体类，第二个是主键的类型 
@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;&#125;

直接调用方法即可
@ResourceAccountRepository repository;@Testvoid contextLoads() &#123;    Account account = new Account();    account.setUsername(&quot;小红&quot;);    account.setPassword(&quot;1234567&quot;);    System.out.println(repository.save(account).getId());   //使用save来快速插入数据，并且会返回插入的对象，如果存在自增ID，对象的自增id属性会自动被赋值，这就很方便了&#125;


方法名称拼接自定义SQL超级帅，只需要在我们创建 AccountRepository 上通过方法名称的拼接来实现条件判断



关键字
方法名称示例
执行的语句



Distinct
findDistinctByLastnameAndFirstname
select distinct … where x.lastname = ?1 and x.firstname = ?2


And
findByLastnameAndFirstname
… where x.lastname = ?1 and x.firstname = ?2


Or
findByLastnameOrFirstname
… where x.lastname = ?1 or x.firstname = ?2


Is，Equals
findByFirstname, findByFirstnameIs, findByFirstnameEquals
… where x.firstname = ?1


Between
findByStartDateBetween
… where x.startDate between ?1 and ?2


LessThan
findByAgeLessThan
… where x.age &lt; ?1


LessThanEqual
findByAgeLessThanEqual
… where x.age &lt;= ?1


GreaterThan
findByAgeGreaterThan
… where x.age &gt; ?1


GreaterThanEqual
findByAgeGreaterThanEqual
… where x.age &gt;= ?1


After
findByStartDateAfter
… where x.startDate &gt; ?1


Before
findByStartDateBefore
… where x.startDate &lt; ?1


IsNull，Null
findByAge(Is)Null
… where x.age is null


IsNotNull，NotNull
findByAge(Is)NotNull
… where x.age not null


Like
findByFirstnameLike
… where x.firstname like ?1


NotLike
findByFirstnameNotLike
… where x.firstname not like ?1


StartingWith
findByFirstnameStartingWith
… where x.firstname like ?1（参数与附加%绑定）


EndingWith
findByFirstnameEndingWith
… where x.firstname like ?1（参数与前缀%绑定）


Containing
findByFirstnameContaining
… where x.firstname like ?1（参数绑定以%包装）


OrderBy
findByAgeOrderByLastnameDesc
… where x.age = ?1 order by x.lastname desc


Not
findByLastnameNot
… where x.lastname &lt;&gt; ?1


In
findByAgeIn(Collection ages)
… where x.age in ?1


NotIn
findByAgeNotIn(Collection ages)
… where x.age not in ?1


True
findByActiveTrue
… where x.active = true


False
findByActiveFalse
… where x.active = false


IgnoreCase
findByFirstnameIgnoreCase
… where UPPER(x.firstname) = UPPER(?1)


比如我们想要实现根据用户名模糊匹配查找用户、根据大于这个ID并且降序查询、通过用户名和ID查询、判断数据库中是否存在某个ID的用户：
@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;    Account findAccountByUsernameLike(String str);    List&lt;Account&gt; findAccountsByIdGreaterThanOrderByIdDesc(int id);    Account findAccountByUsernameAndId(String username, int id);    boolean existsAccountById(int id);&#125;

@SpringBootTestclass Demo2ApplicationTests &#123;    @Resource    AccountRepository repository;    @Test    void contextLoads() &#123;        System.out.println(repository.findAccountByUsernameLike(&quot;%es%&quot;));        System.out.println(&quot;======================================&quot;);        System.out.println(repository.findAccountsByIdGreaterThanOrderByIdDesc(0));        System.out.println(&quot;======================================&quot;);        System.out.println(repository.findAccountByUsernameAndId(&quot;test&quot;, 1));        System.out.println(&quot;======================================&quot;);        System.out.println(repository.existsAccountById(1));        System.out.println(repository.existsAccountById(10));        System.out.println(&quot;======================================&quot;);    &#125;&#125;

注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：
Caused by: org.springframework.data.repository.query.QueryCreationException: Could not create query for public abstract  ...

关联查询一对一@Data@Entity@Table(name = &quot;users_detail&quot;)public class AccountDetail &#123;    @Column(name = &quot;id&quot;)    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Id    int id;    @Column(name = &quot;address&quot;)    String address;    @Column(name = &quot;email&quot;)    String email;    @Column(name = &quot;phone&quot;)    String phone;    @Column(name = &quot;real_name&quot;)    String realName;&#125;

@Data@Entity@Table(name = &quot;users&quot;)public class Account &#123;    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = &quot;id&quot;)    @Id    int id;    @Column(name = &quot;username&quot;)    String username;    @Column(name = &quot;password&quot;)    String password;    @JoinColumn(name = &quot;detail_id&quot;)   //指定存储外键的字段名称    @OneToOne    //声明为一对一关系    AccountDetail detail;&#125;


添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据
@JoinColumn(name = &quot;detail_id&quot;)@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL) //设置关联操作为ALLAccountDetail detail;


ALL：所有操作都进行关联操作
PERSIST：插入操作时才进行关联操作
REMOVE：删除操作时才进行关联操作
MERGE：修改操作时才进行关联操作

@Testvoid addAccount()&#123;    Account account = new Account();    account.setUsername(&quot;Nike&quot;);    account.setPassword(&quot;123456&quot;);    AccountDetail detail = new AccountDetail();    detail.setAddress(&quot;翻斗大街&quot;);    detail.setPhone(&quot;1234567890&quot;);    detail.setEmail(&quot;123456@qq.com&quot;);    detail.setRealName(&quot;张三&quot;);  	account.setDetail(detail);    account = repository.save(account);    System.out.println(&quot;插入时，自动生成的主键ID为：&quot;+account.getId()+&quot;，外键ID为：&quot;+account.getDetail().getId());&#125;

一对多@Data@Entity@Table(name = &quot;users_score&quot;)   //成绩表，注意只存成绩，不存学科信息，学科信息id做外键public class Score &#123;    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = &quot;id&quot;)    @Id    int id;    @OneToOne   //一对一对应到学科上    @JoinColumn(name = &quot;cid&quot;)    Subject subject;    @Column(name = &quot;socre&quot;)    double score;    @Column(name = &quot;uid&quot;)    int uid;&#125;

@Data@Entity@Table(name = &quot;subjects&quot;)   //学科信息表public class Subject &#123;    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = &quot;cid&quot;)    @Id    int cid;    @Column(name = &quot;name&quot;)    String name;    @Column(name = &quot;teacher&quot;)    String teacher;    @Column(name = &quot;time&quot;)    int time;&#125;

@Data@Entity@Table(name = &quot;account&quot;)public class Account &#123;    @Id    @Column(name = &quot;id&quot;)    @GeneratedValue(strategy = GenerationType.IDENTITY)    Integer id;    @Column(name = &quot;username&quot;)    String username;    @Column(name = &quot;password&quot;)    String password;    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;detail_id&quot;)    AccountDetail detail;    @JoinColumn(name = &quot;uid&quot;)  //注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)   //在移除Account时，一并移除所有的成绩信息，依然使用懒加载    List&lt;Score&gt; scoreList;&#125;

多对多@ManyToMany(fetch = FetchType.LAZY)   //多对多场景@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称)List&lt;Teacher&gt; teacher;

JPQL自定义SQL语句@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;    @Transactional    //DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下    @Modifying     //表示这是一个DML操作    @Query(&quot;update Account set password = ?2 where id = ?1&quot;) //这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数    int updatePasswordById(int id, String newPassword);&#125;

或者
@Transactional@Modifying@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true) //使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。int updatePasswordByUsername(@Param(&quot;name&quot;) String username,   //我们可以使用@Param指定名称                             @Param(&quot;pwd&quot;) String newPassword);

MybatisPlus框架所需依赖
&lt;dependency&gt;      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;      &lt;version&gt;3.5.10.1&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;      &lt;version&gt;9.1.0&lt;/version&gt;  &lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-plus-extension&lt;/artifactId&gt;      &lt;version&gt;3.5.5&lt;/version&gt;  &lt;/dependency&gt;

数据源
spring:  datasource:    url: jdbc:mysql://localhost:3306/test    username: root    password: Abc123    driver-class-name: com.mysql.cj.jdbc.Driver

开启日志打印
mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
快速上手实体类，可以直接映射到数据库中的表
@Data@TableName(&quot;user&quot;)  //对应的表名public class User &#123;    @TableId(type = IdType.AUTO)   //对应的主键    int id;    @TableField(&quot;name&quot;)   //对应的字段    String name;    @TableField(&quot;email&quot;)    String email;    @TableField(&quot;password&quot;)    String password;&#125;

跟 mybatis 一样，需要一个 mapper
@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;  	//使用方式与JPA极其相似，同样是继承一个基础的模版Mapper  	//这个模版里面提供了预设的大量方法直接使用，跟JPA如出一辙&#125;

@SpringBootTestclass DemoApplicationTests &#123;    @Resource    UserMapper mapper;    @Test    void contextLoads() &#123;        System.out.println(mapper.selectById(1));  //同样可以直接selectById，非常快速方便    &#125;&#125;


条件构造器@Testvoid contextLoads() &#123;    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    //复杂查询可以使用QueryWrapper来完成  	wrapper            .select(&quot;id&quot;, &quot;name&quot;, &quot;email&quot;, &quot;password&quot;)    //可以自定义选择哪些字段            .ge(&quot;id&quot;, 2)     			//选择判断id大于等于1的所有数据            .orderByDesc(&quot;id&quot;);   //根据id字段进行降序排序    System.out.println(mapper.selectList(wrapper));   //Mapper同样支持使用QueryWrapper进行查询&#125;
等同于
select id,name,email,password from user where id &gt;= 2 order by id desc


支持批处理操作，我们可以一次性删除多个指定ID的用户：
@Testvoid contextLoads() &#123;    mapper.deleteByIds(List.of(1, 3));&#125;

更新：
@Testvoid contextLoads() &#123;    UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;();    wrapper            .set(&quot;name&quot;, &quot;lbw&quot;)            .eq(&quot;id&quot;, 1);    System.out.println(mapper.update(null, wrapper));&#125;
分页查询先配置
@Configurationpublic class MybatisConfiguration &#123;    @Bean    public MybatisPlusInterceptor paginationInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();      	//添加分页拦截器到MybatisPlusInterceptor中        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    &#125;&#125;

使用
@Testvoid contextLoads() &#123;    //这里我们将用户表分2页，并获取第一页的数据    Page&lt;User&gt; page = mapper.selectPage(Page.of(1, 2), Wrappers.emptyWrapper());    System.out.println(page.getRecords());   //获取分页之后的数据&#125;

Lambda表达式@Testvoid contextLoads() &#123;        LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers                .&lt;User&gt;lambdaQuery()                .eq(User::getId, 2)   //比如我们需要选择id为2的用户，前面传入方法引用，后面比的值                .select(User::getName, User::getId);   //比如我们只需要选择name和id，那就传入对应的get方法引用        System.out.println(mapper.selectOne(wrapper));&#125;

代码生成器依赖
&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;    &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;

package com.example;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import jakarta.annotation.Resource;import org.apache.ibatis.annotations.Mapper;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;@SpringBootTestclass Demo4ApplicationTests &#123;    @Resource    DataSource DataSource;    @Test    void contextLoads() &#123;        FastAutoGenerator                .create(new DataSourceConfig.Builder(DataSource))                .globalConfig(builder -&gt; &#123;                    builder.author(&quot;hs&quot;);                    builder.commentDate(&quot;2024-01-01&quot;);                    builder.outputDir(&quot;src/main/java&quot;);                &#125;)                .packageConfig(builder -&gt; builder.parent(&quot;com.example&quot;))                .strategyConfig(builder -&gt; &#123;                    builder                            .mapperBuilder()                            .mapperAnnotation(Mapper.class)                            .build();                &#125;)                .execute();    &#125;&#125;

前后端分离基于 session 的分离前后端分离，需要前端与后端各占一个服务器
环境搭建
创建前端文件

勾选上spring web
在resources里创建一个web目录，把所有web相关的文件塞进去，然后修改配置文件
spring:  web:    resources:      static-locations: classpath:/web


创建后端文件

把右下角看到的依赖都勾选上
后端文件的resources中只需要保留一个配置文件即可，因为前端已经占用了8080端口，我们这里需要改成其他端口
server:    port: 8081  spring:    datasource:      url: jdbc:mysql://localhost:3306/test      username: root      password: Abc123      driver-class-name: com.mysql.cj.jdbc.Driver

实现登录授权和跨域处理还是跟之前security一样
@Configurationpublic class SecurityConfiguration &#123;    @Bean    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;        return http                .authorizeHttpRequests(conf -&gt; &#123;                    conf.anyRequest().authenticated();                &#125;)                .formLogin(conf -&gt; &#123;                  	//一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口                    conf.loginProcessingUrl(&quot;/api/auth/login&quot;);                    conf.permitAll();                &#125;)                .csrf(AbstractHttpConfigurer::disable)                .build();    &#125;&#125;

手动设置SuccessHandler和FailureHandler来实现让SpringSecurity在登录成功之后返回一个JSON数据给前端而不是默认的重定向：
@Beanpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;	return http			...			.formLogin(conf -&gt; &#123;				conf.loginProcessingUrl(&quot;/api/auth/login&quot;);				//使用自定义的成功失败处理器				conf.failureHandler(this::onAuthenticationFailure);				conf.successHandler(this::onAuthenticationSuccess);				conf.permitAll();			&#125;)			...&#125;	//自定义成功失败处理器void onAuthenticationFailure(HttpServletRequest request,							 HttpServletResponse response,							 AuthenticationException exception) &#123;&#125;void onAuthenticationSuccess(HttpServletRequest request, 							 HttpServletResponse response, 							 Authentication authentication) &#123;	&#125;

REST应答一般使用的格式为JSON，这里我们创建一个实体类来装载响应数据，两种写法：

1、基本写法：@Datapublic class RestBean&lt;T&gt; &#123;    int code;    T data;    String message;    private RestBean(int code, T data, String message) &#123;        this.code = code;        this.data = data;        this.message = message;    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; success(T data) &#123;        return new RestBean&lt;&gt;(200, data, &quot;success&quot;);    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; failure(int code, String message) &#123;        return new RestBean&lt;&gt;(code, null, message);    &#125;    public String asJsonString() &#123;        return JSONObject                .from(this, JSONWriter.Feature.WriteNulls)                .toString();    &#125;&#125;
或者
2、JDK的新特性：public record RestBean&lt;T&gt; (int code, T data, String message) &#123;		//写几个工具方法，用于快速创建RestBean对象    public static &lt;T&gt; RestBean&lt;T&gt; success(T data)&#123;        return new RestBean&lt;&gt;(200, data, &quot;请求成功&quot;);    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; failure(int code, String message)&#123;        return new RestBean&lt;&gt;(code, null, message);    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; failure(int code)&#123;        return failure(code, &quot;请求失败&quot;);    &#125;		//将当前对象转换为JSON格式的字符串用于返回    public String asJsonString() &#123;        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);    &#125;&#125;

把handler补充完
void onAuthenticationFailure(HttpServletRequest request,                                 HttpServletResponse response,                                 AuthenticationException exception) throws IOException &#123;        response.setContentType(&quot;application/json;charset=utf-8&quot;);        PrintWriter writer = response.getWriter();        writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());    &#125;    void onAuthenticationSuccess(HttpServletRequest request,                                 HttpServletResponse response,                                 Authentication authentication) throws IOException &#123;        response.setContentType(&quot;application/json;charset=utf-8&quot;);        PrintWriter writer = response.getWriter();        writer.write(RestBean.success(authentication.getName()).asJsonString());    &#125;

我们在发起登录请求时，前端得到了一个跨域请求错误，这是因为我们前端的站点和后端站点不一致导致的，我们只需要告诉浏览器那些站点发出的请求是安全的即可
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;    return http            ...            .cors(conf -&gt; &#123;                CorsConfiguration cors = new CorsConfiguration();              	//添加前端站点地址，这样就可以告诉浏览器信任了              	cors.addAllowedOrigin(&quot;http://localhost:8080&quot;);                //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);              	//但是这样并不安全，我们应该只许可给我们信任的站点                cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie                cors.addAllowedHeader(&quot;*&quot;);   //其他的也可以配置，为了方便这里就 * 了                cors.addAllowedMethod(&quot;*&quot;);                cors.addExposedHeader(&quot;*&quot;);                UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();                source.registerCorsConfiguration(&quot;/**&quot;, cors);  //直接针对于所有地址生效                conf.configurationSource(source);            &#125;)            ...            .build();&#125;

SecurityConfiguration 最终代码
package com.example.config;import com.example.entity.RestBean;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.SecurityFilterChain;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import java.io.IOException;import java.io.PrintWriter;@Configurationpublic class SecurityConfiguration &#123;    @Bean    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;        return http                .authorizeHttpRequests(conf -&gt; &#123;                    conf.anyRequest().authenticated();                &#125;)                .formLogin(conf -&gt; &#123;                    //一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口                    conf.loginProcessingUrl(&quot;/api/auth/login&quot;);                    conf.successHandler(this::onAuthenticationSuccess);                    conf.failureHandler(this::onAuthenticationFailure);                    conf.permitAll();                &#125;)                .csrf(AbstractHttpConfigurer::disable)                .cors(conf -&gt; &#123;                    CorsConfiguration cors = new CorsConfiguration();                    //添加前端站点地址，这样就可以告诉浏览器信任了                    cors.addAllowedOrigin(&quot;http://localhost:8080&quot;);                    //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);                    //但是这样并不安全，我们应该只许可给我们信任的站点                    cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie                    cors.addAllowedHeader(&quot;*&quot;);   //其他的也可以配置，为了方便这里就 * 了                    cors.addAllowedMethod(&quot;*&quot;);                    cors.addExposedHeader(&quot;*&quot;);                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();                    source.registerCorsConfiguration(&quot;/**&quot;, cors);  //直接针对于所有地址生效                    conf.configurationSource(source);                &#125;)                .build();    &#125;    //自定义成功失败处理器    void onAuthenticationFailure(HttpServletRequest request,                                 HttpServletResponse response,                                 AuthenticationException exception) throws IOException &#123;        response.setContentType(&quot;application/json;charset=utf-8&quot;);        PrintWriter writer = response.getWriter();        writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());    &#125;    void onAuthenticationSuccess(HttpServletRequest request,                                 HttpServletResponse response,                                 Authentication authentication) throws IOException &#123;        response.setContentType(&quot;application/json;charset=utf-8&quot;);        PrintWriter writer = response.getWriter();        writer.write(RestBean.success(authentication.getName()).asJsonString());    &#125;&#125;

实体类最终代码
package com.example.entity;import com.alibaba.fastjson2.JSONObject;import com.alibaba.fastjson2.JSONWriter;public record RestBean&lt;T&gt; (int code, T data, String message) &#123;    //写几个工具方法，用于快速创建RestBean对象    public static &lt;T&gt; RestBean&lt;T&gt; success(T data)&#123;        return new RestBean&lt;&gt;(200, data, &quot;请求成功&quot;);    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; failure(int code, String message)&#123;        return new RestBean&lt;&gt;(code, null, message);    &#125;    public static &lt;T&gt; RestBean&lt;T&gt; failure(int code)&#123;        return failure(code, &quot;请求失败&quot;);    &#125;    //将当前对象转换为JSON格式的字符串用于返回    public String asJsonString() &#123;        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);    &#125;&#125;


JWT一个JWT令牌由3部分组成:标头(Header)、有效载荷(Payload)和签名(Signature)。
依赖：
&lt;dependency&gt;     &lt;groupId&gt;com.auth0&lt;/groupId&gt;     &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;     &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt;

快速体验生成一个JWT令牌
public class Main &#123;    public static void main(String[] args) &#123;        String jwtKey = &quot;abcdefghijklmn&quot;;                 //使用一个JWT秘钥进行加密        Algorithm algorithm = Algorithm.HMAC256(jwtKey);  //创建HMAC256加密算法对象        String jwtToken = JWT.create()                .withClaim(&quot;id&quot;, 1)   //向令牌中塞入自定义的数据                .withClaim(&quot;name&quot;, &quot;lbw&quot;)                .withClaim(&quot;role&quot;, &quot;nb&quot;)                .withExpiresAt(new Date(2024, Calendar.FEBRUARY, 1))  //JWT令牌的失效时间                .withIssuedAt(new Date())   //JWT令牌的签发时间                .sign(algorithm);    //使用上面的加密算法进行加密，完成签名        System.out.println(jwtToken);   //得到最终的JWT令牌    &#125;&#125;

得到的令牌为：
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTc0MDA2OTA0N30.1IJCxw3HUmOy2qbEw--6Qnz5fub6dbnIv-u2GmZQam0

还原代码：
public static void main(String[] args) &#123;        String jwtToken = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s&quot;;        String[] split = jwtToken.split(&quot;\\.&quot;);        for (int i = 0; i &lt; split.length - 1; i++) &#123;            String s = split[i];            byte[] decode = Base64.getDecoder().decode(s);            System.out.println(new String(decode));        &#125;&#125;

解码后：
&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;&#123;&quot;role&quot;:&quot;nb&quot;,&quot;name&quot;:&quot;lbw&quot;,&quot;id&quot;:1,&quot;exp&quot;:61664860800,&quot;iat&quot;:1740069366&#125;

SpringSecurity 实现 JWT 校验首先先创建处理JWT令牌的工具类
public class JwtUtils &#123;  	//Jwt秘钥    private static final String key = &quot;abcdefghijklmn&quot;;  	//根据用户信息创建Jwt令牌    public static String createJwt(UserDetails user)&#123;        Algorithm algorithm = Algorithm.HMAC256(key);        Calendar calendar = Calendar.getInstance();        Date now = calendar.getTime();        calendar.add(Calendar.SECOND, 3600 * 24 * 7);        return JWT.create()                .withClaim(&quot;name&quot;, user.getUsername())  //配置JWT自定义信息                .withClaim(&quot;authorities&quot;, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())                .withExpiresAt(calendar.getTime())  //设置过期时间                .withIssuedAt(now)    //设置创建创建时间                .sign(algorithm);   //最终签名    &#125;  	//根据Jwt验证并解析用户信息    public static UserDetails resolveJwt(String token)&#123;        Algorithm algorithm = Algorithm.HMAC256(key);        JWTVerifier jwtVerifier = JWT.require(algorithm).build();        try &#123;            DecodedJWT verify = jwtVerifier.verify(token);  //对JWT令牌进行验证，看看是否被修改            Map&lt;String, Claim&gt; claims = verify.getClaims();  //获取令牌中内容            if(new Date().after(claims.get(&quot;exp&quot;).asDate())) //如果是过期令牌则返回null                return null;            else              	//重新组装为UserDetails对象，包括用户名、授权信息等                return User                        .withUsername(claims.get(&quot;name&quot;).asString())                        .password(&quot;&quot;)                        .authorities(claims.get(&quot;authorities&quot;).asArray(String.class))                        .build();        &#125; catch (JWTVerificationException e) &#123;            return null;        &#125;    &#125;&#125;

然后再编写 JwtAuthenticationFilter
public class JwtAuthenticationFilter extends OncePerRequestFilter &#123;  //继承OncePerRequestFilter表示每次请求过滤一次，用于快速编写JWT校验规则    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;      	//首先从Header中取出JWT        String authorization = request.getHeader(&quot;Authorization&quot;);      	//判断是否包含JWT且格式正确        if (authorization != null &amp;&amp; authorization.startsWith(&quot;Bearer &quot;)) &#123;            String token = authorization.substring(7);	          	//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题            UserDetails user = JwtUtils.resolveJwt(token);            if(user != null) &#123;              	//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致              	//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去                UsernamePasswordAuthenticationToken authentication =                        new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));              	//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证                SecurityContextHolder.getContext().setAuthentication(authentication);            &#125;        &#125;      	//最后放行，继续下一个过滤器      	//可能各位小伙伴会好奇，要是没验证成功不是应该拦截吗？这个其实没有关系的      	//因为如果没有验证失败上面是不会给SecurityContext设置Authentication的，后面直接就被拦截掉了      	//而且有可能用户发起的是用户名密码登录请求，这种情况也要放行的，不然怎么登录，所以说直接放行就好        filterChain.doFilter(request, response);    &#125;&#125;

最后再修改 SecurityConfiguration
package com.example.config;    import com.example.entity.RestBean;  import com.example.filter.JwtAuthenticationFilter;  import com.example.util.JwtUtils;  import jakarta.servlet.http.HttpServletRequest;  import jakarta.servlet.http.HttpServletResponse;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.security.access.AccessDeniedException;  import org.springframework.security.config.annotation.web.builders.HttpSecurity;  import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;  import org.springframework.security.config.http.SessionCreationPolicy;  import org.springframework.security.core.Authentication;  import org.springframework.security.core.AuthenticationException;  import org.springframework.security.core.userdetails.User;  import org.springframework.security.web.SecurityFilterChain;  import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  import org.springframework.web.cors.CorsConfiguration;  import org.springframework.web.cors.UrlBasedCorsConfigurationSource;    import java.io.IOException;  import java.io.PrintWriter;    @Configuration  public class SecurityConfiguration &#123;        @Bean      public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;          return http                  .authorizeHttpRequests(conf -&gt; &#123;                      conf.anyRequest().authenticated();                  &#125;)                  .formLogin(conf -&gt; &#123;                      //一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口                      conf.loginProcessingUrl(&quot;/api/auth/login&quot;);                      conf.successHandler(this::handleProcess);                      conf.failureHandler(this::handleProcess);                      conf.permitAll();                  &#125;)                  .csrf(AbstractHttpConfigurer::disable)                  .cors(conf -&gt; &#123;                      CorsConfiguration cors = new CorsConfiguration();                      //添加前端站点地址，这样就可以告诉浏览器信任了                      cors.addAllowedOrigin(&quot;http://localhost:8080&quot;);                      //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);                    //但是这样并不安全，我们应该只许可给我们信任的站点                      cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie                      cors.addAllowedHeader(&quot;*&quot;);   //其他的也可以配置，为了方便这里就 * 了                      cors.addAllowedMethod(&quot;*&quot;);                      cors.addExposedHeader(&quot;*&quot;);                      UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();                      source.registerCorsConfiguration(&quot;/**&quot;, cors);  //直接针对于所有地址生效                      conf.configurationSource(source);                  &#125;)                  .exceptionHandling(conf -&gt; &#123;                      //配置授权相关异常处理器                      conf.accessDeniedHandler(this::handleProcess);                      //配置验证相关异常的处理器                      conf.authenticationEntryPoint(this::onAuthenticationFailure);                  &#125;)                  .sessionManagement(conf -&gt; conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS))                  .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)                  .build();      &#125;      //自定义成功失败处理器      void onAuthenticationFailure(HttpServletRequest request,                                   HttpServletResponse response,                                   AuthenticationException exception) throws IOException &#123;          response.setContentType(&quot;application/json;charset=utf-8&quot;);          PrintWriter writer = response.getWriter();          writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());      &#125;        void onAuthenticationSuccess(HttpServletRequest request,                                   HttpServletResponse response,                                   Authentication authentication) throws IOException &#123;          response.setContentType(&quot;application/json;charset=utf-8&quot;);          PrintWriter writer = response.getWriter();          writer.write(RestBean.success(authentication.getName()).asJsonString());      &#125;        private void handleProcess(HttpServletRequest request,                                 HttpServletResponse response,                                 Object exceptionOrAuthentication) throws IOException &#123;          response.setContentType(&quot;application/json;charset=utf-8&quot;);          PrintWriter writer = response.getWriter();          if(exceptionOrAuthentication instanceof AccessDeniedException exception) &#123;              writer.write(RestBean.failure(403, exception.getMessage()).asJsonString());          &#125; else if(exceptionOrAuthentication instanceof Exception exception) &#123;              writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());          &#125;else if(exceptionOrAuthentication instanceof Authentication authentication)&#123;              //不过这里需要注意，在登录成功的时候需要返回我们生成的JWT令牌，这样客户端下次访问就可以携带这个令牌了，令牌过期之后就需要重新登录才可以              writer.write(RestBean.success(JwtUtils.createJwt((User) authentication.getPrincipal())).asJsonString());          &#125;      &#125;  &#125;












]]></content>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2025/01/12/articles/SpringCloud/SpringCloud/</url>
    <content><![CDATA[
版本选择
Nacos下载：Nacos Server 下载 | Nacos 官网
下载解压后在bin文件，打开cmd，输入 startup.cmd -m standalone
服务注册
导入web依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;

引入服务依赖发现
@SpringBootApplicationpublic class OrderMainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderMainApplication.class, args);    &#125;&#125;

修改配置文件
spring.application.name=service-orderserver.port=8000spring.cloud.nacos.server-addr=127.0.0.1:8848

启动程序后即可在服务列表中查看
启动不同端口来模拟集群，这个复制找半天
服务发现首先，在主配置类 MainApplication 加上注解 @EnableDiscoveryClient 开启服务发现功能
然后在需要使用服务发现的地方调用已经装配好的 DiscoveryClient
@Autowired    DiscoveryClient discoveryClient;    @Test    public void TestDiscoveryClient() &#123;        for (String service : discoveryClient.getServices()) &#123;            System.out.println(&quot;service = &quot; + service);            for (ServiceInstance instance : discoveryClient.getInstances(service))&#123;                System.out.println(&quot;ip: &quot; + instance.getHost() + &quot;, port: &quot; + instance.getPort());            &#125;        &#125;    &#125;

或者使用 NacosServiceDiscovery，区别在于 NacosServiceDiscovery 只能用在 Nacos 的服务发现，DiscoveryClient 能用在其他地方
@Autowired    NacosServiceDiscovery nacosServiceDiscovery;    @Test    public void TestNacosServiceDiscovery() throws NacosException &#123;        for (String service : nacosServiceDiscovery.getServices()) &#123;            System.out.println(&quot;service = &quot; + service);            for (ServiceInstance instance : nacosServiceDiscovery.getInstances(service)) &#123;                System.out.println(&quot;ip: &quot; + instance.getHost() + &quot;, port: &quot; + instance.getPort());            &#125;        &#125;    &#125;

远程调用的基本实现最外层依赖
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.3.4&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;modules&gt;        &lt;module&gt;services&lt;/module&gt;        &lt;module&gt;model&lt;/module&gt;    &lt;/modules&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;cloud-demo&lt;/name&gt;    &lt;description&gt;cloud-demo&lt;/description&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;        &lt;spring-cloud-alibaba.version&gt;2023.0.3.2&lt;/spring-cloud-alibaba.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;

第二层详细功能实现order依赖
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.example&lt;/groupId&gt;        &lt;artifactId&gt;services&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;artifactId&gt;service-order&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;

OrderMainApplication
package com.example.order;@EnableDiscoveryClient@SpringBootApplicationpublic class OrderMainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderMainApplication.class, args);    &#125;&#125;

config
package com.example.order.config;@Configurationpublic class OrderConfig &#123;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;

controller
package com.example.order.Controller;@RestControllerpublic class orderController &#123;    @Autowired    OrderServiceImpl orderService;    @GetMapping(&quot;/create&quot;)    public Order getOrder(@RequestParam(&quot;userId&quot;) long userId,                          @RequestParam(&quot;productId&quot;) long productId) &#123;        Order order = orderService.createOrder(productId, userId);        return order;    &#125;&#125;

ServiceImpl
package com.example.order.Service.Impl;@Slf4j@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    DiscoveryClient discoveryClient;    @Autowired    RestTemplate restTemplate;    @Override    public Order createOrder(long productId, long userId) &#123;        Product product = getProductFromRemote(productId);        Order order = new Order();        order.setId(1L);        // TODO 总金额暂设为0        order.setTotalAmount(product.getPrice().multiply(new BigDecimal(product.getNum())));        order.setUserId(userId);        order.setNickname(&quot;hs&quot;);        order.setAddress(&quot;byxy&quot;);        // TODO 远程查询商品列表        order.setProductList(Arrays.asList(product));        return order;    &#125;    private Product getProductFromRemote(Long productId)&#123;        // 获取商品所在机器的服务实例        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;service-product&quot;);        ServiceInstance serviceInstance = instances.get(0);        //远程URL地址 ： http://localhost:9001/product/4        String url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/product/&quot; + productId;        log.info(&quot;远程请求:&#123;&#125;&quot;, url);        // 远程发送请求        Product forObject = restTemplate.getForObject(url, Product.class);        return forObject;    &#125;&#125;

product依赖
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.example&lt;/groupId&gt;        &lt;artifactId&gt;services&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;artifactId&gt;service-product&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;

ProductMainApplication
package com.example.product;@SpringBootApplicationpublic class ProductMainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ProductMainApplication.class, args);    &#125;&#125;

config
package com.example.product.config;@Configurationpublic class ProductServiceConfig &#123;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;

controller
package com.example.product.controller;@RestControllerpublic class ProductController &#123;    @Autowired    ProductServiceImpl productService;    @GetMapping(&quot;/product/&#123;id&#125;&quot;)    public Product getProduct(@PathVariable(&quot;id&quot;) Long id) &#123;        Product product = productService.getProductById(id);        return product;    &#125;&#125;

ServiceImpl
package com.example.product.service.Impl;@Servicepublic class ProductServiceImpl implements ProductService &#123;    @Override    public Product getProductById(Long id) &#123;        Product product = new Product();        product.setId(id);        product.setPrice(new BigDecimal(&quot;99&quot;));        product.setProductName(&quot;苹果 - &quot; + id);        product.setNum(2);        return product;    &#125;&#125;

model主要是装 order 和 product 的 实体entity
package com.example.order.Bean;import com.example.product.Bean.Product;@Datapublic class Order &#123;    private long id;    private BigDecimal totalAmount;    private Long userId;    private String nickname;    private String address;    private List&lt;Product&gt; productList;&#125;

package com.example.product.Bean;@Datapublic class Product &#123;    private Long id;    private BigDecimal price;    private String productName;    private int num;&#125;

装好后在 order 和 product 两个项目中导入这个model的依赖
&lt;dependency&gt;      &lt;groupId&gt;org.example&lt;/groupId&gt;      &lt;artifactId&gt;model&lt;/artifactId&gt;      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;/dependency&gt;

负载均衡方式一所需依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;  &lt;/dependency&gt;

@Autowired    LoadBalancerClient loadBalancerClient;    @Test    void test() &#123;        // 可以选择单个服务实例        ServiceInstance choose = loadBalancerClient.choose(&quot;service-product&quot;);        System.out.println(choose.getHost() + &quot;:&quot; + choose.getPort());        choose = loadBalancerClient.choose(&quot;service-product&quot;);        System.out.println(choose.getHost() + &quot;:&quot; + choose.getPort());        choose = loadBalancerClient.choose(&quot;service-product&quot;);        System.out.println(choose.getHost() + &quot;:&quot; + choose.getPort());    &#125;

通过测试可得知，并不是通过平均抽取来实现负载均衡，而是通过依次调用
修改前面代码，添加一个负载均衡来发送请求
private Product getProductFromRemoteWithLoadBalancer(Long productId)&#123;        // 获取商品所在机器的服务实例        ServiceInstance choose = loadBalancerClient.choose(&quot;service-product&quot;);        //远程URL地址 ： http://localhost:9001/product/4        String url = &quot;http://&quot; + choose.getHost() + &quot;:&quot; + choose.getPort() + &quot;/product/&quot; + productId;        log.info(&quot;远程请求:&#123;&#125;&quot;, url);        // 远程发送请求        return restTemplate.getForObject(url, Product.class);    &#125;

方式二我们可以直接通过添加注解的形式来实现负载均衡
package com.example.order.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class OrderConfig &#123;    @LoadBalanced //注解式负载均衡    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;

编写函数
private Product getProductFromRemoteWithLoadBalancerAnnotation(Long productId)&#123;        String url = &quot;http://service-product/product/&quot; + productId;        log.info(&quot;远程请求:&#123;&#125;&quot;, url);        // 远程发送请求 service-product会被动态替换        return restTemplate.getForObject(url, Product.class);    &#125;


配置中心导入依赖
&lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;  &lt;/dependency&gt;

基本用法首先创建一个配置

然后在需要引入配置的项目中的配置文件中加入spring.config.import=nacos:service-order.properties
ok，完成配置，然后再试试能不能调用到配置
@RestController  @RefreshScope // 激活配置属性的自动刷新  public class orderController &#123;        ......      @Value(&quot;$&#123;order.timeout&#125;&quot;)      String orderTimeout;      @Value(&quot;$&#123;order.auto-confirm&#125;&quot;)      String orderAutoConfirm;        @GetMapping(&quot;/config&quot;)      public String config() &#123;          return &quot;order.timeout=&quot; + orderTimeout + &quot;\n&quot; + &quot;order.auto-confirm=&quot; + orderAutoConfirm;      &#125;  	......&#125;


@RefreshScope的作用是在我们修改配置中心的时候可以不重启项目，激活配置属性的自动刷新功能

但是这样会有一个问题，就是如果导入了依赖，但不配置，启动时会报错，因此我们在不需要配置的项目中的配置文件加入禁用导入检查
spring.cloud.nacos.config.import-check.enabled=false

注：如果配置中心与项目中有相同的配置项，以配置中心为主
动态刷新
方式一
  和上面一样@Value(“${xx}”)获取配置+@Refreshscope 实现自动刷新

方式二


把配置的属性抽取出来
@Component  @ConfigurationProperties(prefix = &quot;order&quot;) //配置批量绑定，在nacos下可以无需（接上）@RefreshScope就能实现自动刷新  @Data  public class OrderProperties &#123;        String timeout;        String autoConfirm;  &#125;


ConfigurationProperties 是批量绑定，如上为例，是前缀以 order. 开头的配置项，下面的属性名与点后一样对应，配置上的短横线 - 换成驼峰
记得绑定成容器 @Component

回到调用的地方，@RefreshScope 可以不要了
@RestControllerpublic class orderController &#123;    ...    @Autowired    OrderProperties orderProperties;    @GetMapping(&quot;/config&quot;)    public String config() &#123;        return &quot;order.timeout=&quot; + orderProperties.getTimeout() + &quot;\n&quot; + &quot;order.auto-confirm=&quot; + orderProperties.getAutoConfirm();    &#125;&#125;

监听配置变化@EnableDiscoveryClient  @SpringBootApplication  public class OrderMainApplication &#123;      public static void main(String[] args) &#123;          SpringApplication.run(OrderMainApplication.class, args);      &#125;        @Bean      ApplicationRunner applicationRunner(NacosConfigManager nacosConfigManager) &#123;          return args -&gt; &#123;              ConfigService configService = nacosConfigManager.getConfigService(); // 拿到配置服务              // 在服务里添加一个监听器，参数分别是dataId，就是想监控的配置文件Id，第二个是项目组，第三个是传一个监听器            configService.addListener(                      &quot;service-order.properties&quot;,                      &quot;DEFAULT_GROUP&quot;,                      new Listener() &#123;                          @Override                          public Executor getExecutor() &#123;  	                        // new 一个线程池                            return Executors.newFixedThreadPool(4);                          &#125;                            @Override                          public void receiveConfigInfo(String configInfo) &#123;                              System.out.println(&quot;变化的配置信息: &quot; + configInfo);                              System.out.println(&quot;发送到....&quot;);                          &#125;                      &#125;);          &#125;;      &#125;  &#125;


ApplicationRunner 是 springboot 里的一次性任务，项目一启动就会执行
NacosConfigManager 可以监听配置的变化

数据隔离一般 Nacos 的组织是有多套 命名空间Namespace， Namespace 下有多个 分组Group、Group 下又有多个 数据集Data-id，每个环境下只需要绑定一个命名空间
不创建命名空间下默认是 public
大致如下
首先先去创建命名空间，然后再去配置列表在命名空间下创建配置
把配置文件从原来的 application.properties 改成 &#96;&#96;application.yml&#96;
server:  port: 8000spring:  profiles:    active: test  application:    name: service-order  cloud:    nacos:      server-addr: 127.0.0.1:8848      config:        import-check:          enabled: false        namespace: $&#123;spring.profiles.active:public&#125;---spring:  config:    import:      - nacos:common.properties?group=order      - nacos:database.properties?group=order    activate:      on-profile: dev---spring:  config:    import:      - nacos:common.properties?group=order      - nacos:database.properties?group=order    activate:      on-profile: test
很好理解，多环境，如果我们想要改成开发环境 dev 我们只需要修改 active:dev  
hhh，当然可以写的不用上面这么麻烦，如果你是一个人写单环境的话
server:    port: 8000    spring:    profiles:      active: dev    application:      name: service-order    cloud:      nacos:        server-addr: 127.0.0.1:8848        config:          namespace: test      config:      import:        - nacos:common.properties?group=order        - nacos:database.properties?group=order  ---  spring:    config:      import:        - nacos:common.properties?group=order        - nacos:database.properties?group=order

OpenFeign 远程调用所需依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;  &lt;/dependency&gt;

声明式调用ok，前面我们的远程调用，只需要把 RestTemplate 装成 bean，然后调用里面的 getForObject 就可以实现远程调用了，已经很方便了，现在有个方便的，连 bean 都不需要我们自己注册，只需要几个注解就能完成
首先在主方法里面加上 @EnableFeignClients，表示开启 Feign 远程调用
@EnableFeignClients // 开启Feign远程调用@EnableDiscoveryClient@SpringBootApplicationpublic class OrderMainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderMainApplication.class, args);    &#125;	...&#125;

然后我们需要写一个接口，表示为 Feign 客户端，写上注解 @FeignClient(value = &quot;service-product&quot;) 指明远程调用服务端，也可以指名域名 url = &quot;url地址&quot;
@FeignClient(value = &quot;service-product&quot;) // 声明是一个Feign客户端，value指定服务名  public interface ProductFeignClient &#123;        // mvc注解的两套使用逻辑      // 1、标注在Controller上，是表示接受这样的请求      // 2、标注在FeignClient上，是表示发送这样的请求      @GetMapping(&quot;product/&#123;id&#125;&quot;)      Product getProductById(@PathVariable(&quot;id&quot;) Long id);  &#125;


这里有个小知识，在我们之前MVC里面有提到 @GetMapping 表示获取 GetMapping 请求，把参数赋给变量 id，但是在 Feign 里面，@GetMapping 表示发送一个 @GetMapping 请求，是把参数 id 赋上去

然后修改 Controller，可以不用再另写一个方法来获取远程调用服务端，获取地址再推送出去巴拉巴拉，直接用我们上面声明好的 Feign 客户端  ProductFeignClient 里的 getProductById
@Slf4j@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    ProductFeignClient productFeignClient;    @Override    public Order createOrder(long productId, long userId) &#123;        Product product = productFeignClient.getProductById(productId);        Order order = new Order();        order.setId(1L);        // TODO 总金额暂设为0        order.setTotalAmount(product.getPrice().multiply(new BigDecimal(product.getNum())));        order.setUserId(userId);        order.setNickname(&quot;hs&quot;);        order.setAddress(&quot;byxy&quot;);        // TODO 远程查询商品列表        order.setProductList(Arrays.asList(product));        return order;    &#125;&#125;

客户端负载均衡与服务端负载均衡区别：客户端负载均衡调用负载均衡的位置在客户端，服务端负载均衡的位置在服务端
日志首先在 yml 配置文件里面配置
logging:    level:      com.example.order.feign: debug

然后在 @Configuration 注解类下编写，这里在之前创建的 OrderConfig 里写
@Bean  Logger.Level feignLoggerLevel() &#123;      return Logger.Level.FULL;  &#125;

超时控制两个概念：

connectTimeout 连接超时
   建立连接所需要的时间是连接时间，连接超时就是建立连接的时间太久没用得到响应

readTimeout 读取超时
   建立连接后，等待对方运行的时间是读取时间，读取时间超市就是已经和对方建立连接，但是对方运行太久没有返回结果


OpenFeign 默认的连接超时是 10 秒，读取超时是 60 秒
超时配置项目的配置文件内容太多了，可以新开一个配置文件，这里新开一个 application-feign.yml
spring:  cloud:    openfeign:      client:        config:          default:  # 默认的配置            logger-level: full            connect-timeout: 1000            read-timeout: 3000          service-product:  # Feign客户端 service-product 的配置            logger-level: full            connect-timeout: 3000            read-timeout: 5000


然后记得在原配置文件中 include 进来
spring:    profiles:      include: feign

重试机制Retryer 和上面的 Logger.Level 一样，只要在容器中注册，就会被自动识别，因此只需要在 Configuration 配置类里面注册成 bean 即可
在之前的配置类 OrderConfig 里面编写
@BeanRetryer retryer() &#123;	return new Retryer.Default(1000, 5000, 5);// 隔1000毫秒，最大间隔5000毫秒，重试5次，每次间隔时间都会增加1.5倍&#125;

拦截器也是两个

请求拦截器
   请求拦截器是每次发送请求前拦截下来，可以对请求做一些定制修改，比如添加一些字段

响应拦截器
   响应拦截器也是一样，每次接收回应时，对响应做一些预处理，处理完将真正的处理结果发回来


方法一：编写拦截器类，在配置文件中把拦截器导入
public class XTokenRequestInterceptor implements RequestInterceptor &#123;    /*    * 请求拦截器    * @Param template 请求模板    * */    @Override    public void apply(RequestTemplate template) &#123;        System.out.println(&quot;template: &quot; + template);        template.header(&quot;X-Token&quot;, UUID.randomUUID().toString());    &#125;&#125;

spring:    cloud:      openfeign:        client:          config:            default:              logger-level: full              connect-timeout: 1000              read-timeout: 3000            service-product:              logger-level: full              connect-timeout: 3000              read-timeout: 5000  #            retryer: feign.retryer.Default              request-interceptors:                - com.example.order.interceptor.XTokenRequestIntercept

方法二：注册一个 RequestInterceptor 组件，SpringCloud 会自动寻找，不需要手动添加到配置
@Componentpublic class XTokenRequestInterceptor implements RequestInterceptor &#123;    /*    * 请求拦截器    * @Param template 请求模板    * */    @Override    public void apply(RequestTemplate template) &#123;        System.out.println(&quot;template: &quot; + template);        template.header(&quot;X-Token&quot;, UUID.randomUUID().toString());    &#125;&#125;

Fallback 兜底返回
我们之前有写到远程调用，但是有时候对方微服务并没有启动或者其他原因没有返回数据，按照正常流程走这时候程序就会报错，我们并不希望用户在使用中会看到报错，所以就有了 Fallback 兜底返回，如果没有收到数据，就伪造一个数据返回
以我们前面写的 ProductFeignClient 为例，我们先写一个类来实现远程调用 ProductFeignClient 的接口并且注册成组件
@Component  public class ProductFeignClientFallback implements ProductFeignClient &#123;      @Override      public Product getProductById(Long id) &#123;          System.out.println(&quot;兜底回调...&quot;);          Product product = new Product();          product.setId(id);          product.setPrice(new BigDecimal(&quot;0&quot;));          product.setProductName(&quot;位置商品&quot;);          product.setNum(0);            return null;      &#125;  &#125;

然后在 ProductFeignClient 添加上 fallback
@FeignClient(value = &quot;service-product&quot;, fallback = ProductFeignClientFallback.class) // 添加上fallbackpublic interface ProductFeignClient &#123;	...	    @GetMapping(&quot;/product/&#123;id&#125;&quot;)    Product getProductById(@PathVariable(&quot;id&quot;) Long id);&#125;

还需要用上熔断机制 Sentinel，导入依赖
&lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;  &lt;/dependency&gt;

添加配置
feign:  sentinel:    enabled: true

现在如果调用对方微服务有正常返回就会走 ProductFeignClient，如果没有得到放回就会走 ProductFeignClientFallback 来伪造一条数据
Sentinel 服务保护java -jar sentinel-dashboard-1.8.8.jar
默认账号密码： sentinel
快速上手两个项目都编写配置文件 yml：
sentinel:    transport:      dashboard: localhost:8080    eager: true

xml：
spring.cloud.sentinel.transport.dashboard=localhost:8080  spring.cloud.sentinel.eager=true

以创建订单为例，我们认为创建订单是一个资源，要给予保护，做一些流控等设置，添加注解 @SentinelResource 来定义资源的名字
@SentinelResource(value = &quot;createOrder&quot;)  @Override  public Order createOrder(long productId, long userId) &#123;      ......&#125;

我们发送一条创建订单的信号，然后在 sentinel 上就能检测到我们发送的资源，我们可以在上面添加保护，例如我们这里添加资源流控资源名是请求的路径，在这里的单机阈值是指每秒只放行一个，多了就会报错（Blocked by Sentinel (flow limiting)）
异常处理web 接口异常处理编写实体类与一些可能会用到的方法
@Data  public class R &#123;      private Integer code;      private String msg;      private Object data;        public static R ok() &#123;          R r = new R();          r.setCode(200);          r.setMsg(&quot;success&quot;);          return r;      &#125;        public static R ok(String msg, Object data) &#123;          R r = new R();          r.setCode(200);          r.setMsg(msg);          r.setData(data);          return r;      &#125;        public static R error() &#123;          R r = new R();          r.setCode(500);          return r;      &#125;        public static R error(Integer code, String msg) &#123;          R r = new R();          r.setCode(code);          r.setMsg(msg);          return r;      &#125;  &#125;

编写 web 接口异常处理规则
@Componentpublic class MyBlockExceptionHandler implements BlockExceptionHandler &#123;    private ObjectMapper objectMapper = new ObjectMapper(); //把JSON数据转成String    @Override    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, String resourceName, BlockException e) throws Exception &#123;        response.setContentType(&quot;application/json;charset=utf-8&quot;); // 转换编码        PrintWriter writer = response.getWriter();//给外界写出JSON数据        R error = R.error(500, resourceName + &quot;被sentinel限制住了，原因：&quot; + e.getClass());        String json = objectMapper.writeValueAsString(error);        writer.write(json);        writer.flush();        writer.close();    &#125;&#125;











]]></content>
  </entry>
  <entry>
    <title>快速上手SpringAI 2.0</title>
    <url>/2025/07/14/articles/AI/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpringAI%202.0/</url>
    <content><![CDATA[前面那篇1.0没用，一点用没有，还得是CSDN大佬啊
快速使用创建项目
选择创建 Spring Initializr 项目，JDK最低要求17，不可低于17

依赖选择

SpringBoot版本需要高于3.X


需要的依赖项：

Lombok
Spring Web
MySQL Driver
openAI



最终的xml文件应为：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;SpringAI_Study&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;SpringAI_Study&lt;/name&gt;    &lt;description&gt;SpringAI_Study&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;17&lt;/java.version&gt;        &lt;spring-boot.version&gt;3.5.3&lt;/spring-boot.version&gt;        &lt;spring-ai.version&gt;1.0.0&lt;/spring-ai.version&gt;    &lt;/properties&gt;    &lt;!-- 添加仓库配置 --&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;maven-central&lt;/id&gt;            &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;        &lt;/repository&gt;        &lt;repository&gt;            &lt;id&gt;spring-milestones&lt;/id&gt;            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;            &lt;artifactId&gt;spring-ai-starter-model-openai&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 关键：手动导入 BOM 管理版本 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!-- Spring Boot BOM --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- Spring AI BOM --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;

配置文件application.yaml
spring:    application:      name: SpringAI_Study    ai:      openai:        base-url: https://dashscope.aliyuncs.com/compatible-mode/v1        api-key: sk-ab194af7f1a9411396d4510c14******        chat:          options:            model: qwen-max            temperature: 0.9

开始编写代码配置类在项目内创建一个config包，在里面创建配置类，用于初始化使用指定的ChatClient模型
import org.springframework.ai.chat.client.ChatClient;  import org.springframework.ai.chat.model.ChatModel;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;    @Configuration  public class SpringAiConfig &#123;        @Bean      public ChatClient chatClient(ChatModel chatModel) &#123;          return ChatClient                  .builder(chatModel)                  .defaultSystem(&quot;你是一个Java大佬，精通各种框架和中间件，需要你解决用户的问题&quot;)                  .build();      &#125;  &#125;


在这里 defaultSystem 就可以用来设置系统提示词，不用像1.0那里搞得这么麻烦

Controller 类@RestController  @Slf4j  @RequiredArgsConstructor  public class ChatController &#123;        private final ChatClient chatClient;        @RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=UTF-8&quot;)      public Flux&lt;String&gt; chat(String message)&#123;          log.info(&quot;用户问：&#123;&#125;&quot;, message);          return chatClient                  .prompt()                  .user(message)                  .stream()  // 流式响应，可以换成call()                  .content();      &#125;  &#125;


如果使用了 stream，要添加上 produces = &quot;text/html;charset=UTF-8&quot;，如果用的是call就不用

实现连续对话ChatMemory 的配置@Configuration  public class MemoryConfig &#123;        @Bean      public ChatMemory chatMemory() &#123;          return MessageWindowChatMemory                  .builder()                  .chatMemoryRepository(new InMemoryChatMemoryRepository())                  .maxMessages(20)                  .build();      &#125;  &#125;


很眼熟啊这里，感觉用起来跟langchain4j一模一样

配置到ChatClient在LangChain4j里我们可以通过 @AIService 来配置，但是 SpringAI还没有做这个注解，所以这里需要通过 SpringAI 的 Advisor（顾问） 机制
修改前面写的配置类
@Configuration  public class SpringAiConfig &#123;        @Bean      public ChatClient chatClient(OpenAiChatModel chatModel, ChatMemory chatMemory) &#123;          return ChatClient                  .builder(chatModel)                  .defaultSystem(&quot;你是一个Java大佬，精通各种框架和中间件，需要你解决用户的问题&quot;)                  .defaultAdvisors(                          new SimpleLoggerAdvisor(),                          MessageChatMemoryAdvisor.builder(chatMemory).build()                  )                  .build();      &#125;  &#125;


这里只加了两个Advisor，一个是记录大模型的请求、响应的日志 SimpleLoggerAdvisor
另一个是刚刚编写的 ChatMemory

因为配置了 SimpleLoggerAdvisor，所以需要在配置文件修改日志级别，不然看不到日志效果
server:    port: 8080  spring:    application:      name: SpringAI_Study    ai:      openai:        base-url: https://dashscope.aliyuncs.com/compatible-mode        api-key: sk-ab194af7f1a9411396d4510c14f6cc45        chat:          options:            model: qwen-max            temperature: 0.9  logging:    level:      org.springframework.ai.chat.client.advisor: debug


根据会话id区分对话上面我们配置了 ChatMemory 实现连续对话，但是我们换个浏览器问依旧还是同样的上下文
修改前面的controller
@RestController  @Slf4j  @RequiredArgsConstructor  public class ChatController &#123;        private final ChatClient chatClient;        @RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=UTF-8&quot;)      public Flux&lt;String&gt; chat(@RequestParam(&quot;message&quot;) String message, @RequestParam(&quot;userId&quot;) String userId)&#123;          log.info(&quot;用户问：&#123;&#125;&quot;, message);          return chatClient                  .prompt()                  .user(message)                  .advisors(a -&gt; a.param(ChatMemory.CONVERSATION_ID, userId))                  .stream()  // 流式响应，可以换成call()                  .content();      &#125;  &#125;




]]></content>
  </entry>
  <entry>
    <title>docker学习记录</title>
    <url>/2024/03/16/articles/docker/docker/</url>
    <content><![CDATA[Docker学习记录因为在学习MySQL的时候需要用到多台客户端，如果使用VMware来一个个创建就太过于麻烦，因此我在网上冲浪的时候发现了Docker，Docker是一个 基于go语言 的开源应用引擎，通过利用Docker的方法来快速交付，测试和部署代码，可以大大减少编写代码和在生产环境中运行代码之间的延迟。
Docker的安装因为我用的是centOS，所以我在这里展示的也是centOS的安装方法注：如果没给权限记得在命令前加sudo首先，如果之前有安装过docker，无论有没有成功，都先删除一遍：

yum remove docker \


docker-client                   docker-client-latest                   docker-common                   docker-latest                   docker-latest-logrotate                   docker-logrotate                   docker-engine



安装依赖，下载 repo 文件：

yum install -y yum-utils

设置软件仓库地址（默认是国外的，不建议）：

yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo

建议使用阿里云的仓库地址，因为比较快:

yum-config-manager –add-repo https://mirrors.aliyum.com/docker-ce/linux/centos/docker-ce.repo

在安装前建议更新一下yum软件包

yum makecache fast

最后在安装docker-ce(ce指的是社区版，免费，也有ee版是企业版，需要付费)：

yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

Docker的安装就可以了
Docker的信息首先，我们先要启动docker

systemctl start docker 

我们可以通过 docker version 来查询docker的一些版本信息或者可以用 docker info 来查看docker的一些系统级的信息，比如内核，镜像数，容器数等
hello-world一切语言或者其他都有hello world，docker也不例外，真就是精通各种hello world了首先，我们先来查看一下目前已有的镜像

docker images

不出意外，显示的是下面几个列标题，没有值然后，我们来执行命令

docker run hello-world

运行完后会显示一长串的东西，简单来说就是没有找到这个镜像，然后就去pull，去远程拉取一个镜像，如果输出有 Hello from Docker! 则表示成功但是，如果没有显示上图那一长串的信息，或者是显示 Redirecting to /bin/systemctl stop docker.servic之类的信息，说明拉取镜像失败了，这时候要考虑设备或者网络的问题。我在做这一步的时候也发生了两次错误，一次是把 docker run hello-world 打错成 docker run hello-word了，另一次是因为原来配置的镜像问题，建议使用阿里云的镜像加速器.

sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’{  “registry-mirrors”: [“]]></content>
  </entry>
  <entry>
    <title>SpringMVC学习笔记</title>
    <url>/2024/12/24/articles/SpringMVC/SpringMVC/</url>
    <content><![CDATA[所需依赖&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;junit.version&gt;5.9.2&lt;/junit.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;            &lt;version&gt;5.0.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;6.2.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

HelloMVC

web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;         version=&quot;5.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;

自动扫描包，让指定包下的注解生效，有IOC容器统一管理


springmvc-servlet.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;         xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;        &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt;        &lt;mvc:default-servlet-handler/&gt;      &lt;mvc:annotation-driven/&gt;        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;          &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;          &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;      &lt;/bean&gt;  &lt;/beans&gt;

hello.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;  &lt;html&gt;  &lt;head&gt;      &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  $&#123;msg&#125;  &lt;/body&gt;  &lt;/html&gt;

ControllerTest.class
package com.example.controller;    import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.RequestMapping;    @Controller  @RequestMapping(&quot;/c&quot;)  public class ControllerTest &#123;      @RequestMapping(&quot;/h1&quot;)      public String test1(Model model) &#123;            model.addAttribute(&quot;msg&quot;, &quot;Controller Test&quot;);            return &quot;hello&quot;;  //会被视图解析器处理，找到WEB-INF/jsp/hello.jsp    &#125;  &#125;

RestFul 风格**RestFul风格会允许我们将参数通过URL拼接传送到服务端
比如这里我们的URL可以填http://localhost:8080/add/13/18
@Controller  public class RestFulController &#123;      @GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)      public String test1(@PathVariable int a, @PathVariable int b, Model model)&#123;          int result = a + b;            model.addAttribute(&quot;msg&quot;, &quot;result is &quot; + result);            return &quot;hello&quot;;      &#125;  &#125;

**当然，我们也可以通过RestFul风格来传对象，例如：
package com.example.controller;    import com.example.pojo.User;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RequestParam;    @Controller  @RequestMapping(&quot;/user&quot;)  public class UserController &#123;        @GetMapping(&quot;/t1&quot;)      public String test1(@RequestParam(&quot;name&quot;) String name, Model model) &#123;          // 接受前端参数          System.out.println(&quot;前端接收的参数为&quot; + name);          // 将返回的结果赋给前端          model.addAttribute(&quot;msg&quot;, name);          // 视图跳转          return &quot;hello&quot;;      &#125;        @GetMapping(&quot;/t2&quot;)      public String test2(User user, Model model) &#123;          model.addAttribute(&quot;msg&quot;, user);          return &quot;hello&quot;;      &#125;  &#125;

我们输入http://localhost:8080/mvc/user/t2?id=1&amp;name=&quot;呵帅&quot;&amp;age=18)也可以成功传值
这里有一篇博客讲的很清楚RESTful 风格（详细介绍 + 案例实现）_resultful风格开发-CSDN博客
JSON&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;Title&lt;/title&gt;        &lt;script type=&quot;javascript&quot;&gt;          let user = &#123;              name: &quot;hs&quot;,              age: 18,              sex: &quot;男&quot;          &#125;;            let jsonStr = JSON.stringify(user);            console.log(jsonStr);            let obj = JSON.parse(jsonStr);          console.log(obj);        &lt;/script&gt;    &lt;/head&gt;  &lt;body&gt;    &lt;/body&gt;  &lt;/html&gt;

utils用json对象表示法来返回一个时间给页面
package com.example.utils;    import com.fasterxml.jackson.core.JsonProcessingException;  import com.fasterxml.jackson.databind.ObjectMapper;  import com.fasterxml.jackson.databind.SerializationFeature;    import java.text.SimpleDateFormat;  import java.util.Date;    public class JsonUtils &#123;      public static String getJson(Object o) &#123;          return getJson(o, &quot;yyyy-MM-dd HH:mm:ss&quot;);      &#125;      public static String getJson(Object o, String dateFormat) &#123;          ObjectMapper mapper = new ObjectMapper();            mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);            SimpleDateFormat sdf =  new SimpleDateFormat(dateFormat);          mapper.setDateFormat(sdf);            try &#123;              return mapper.writeValueAsString(o);          &#125; catch (JsonProcessingException e) &#123;              throw new RuntimeException(e);          &#125;      &#125;    &#125;

UserController
package com.example.controller;    import com.example.pojo.User;  import com.example.utils.JsonUtils;  import com.fasterxml.jackson.core.JsonGenerator;  import com.fasterxml.jackson.core.JsonProcessingException;  import com.fasterxml.jackson.databind.ObjectMapper;  import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.ResponseBody;  import org.springframework.web.bind.annotation.RestController;    import java.text.SimpleDateFormat;  import java.util.ArrayList;  import java.util.Date;    @Controller  public class UserController &#123;        @GetMapping(&quot;/j1&quot;)      @ResponseBody // 不会走视图解析器，直接返回一个字符串      public String test1() throws JsonProcessingException &#123;            User user = new User(&quot;hs&quot;, 18, &quot;男&quot;);            return JsonUtils.getJson(user);      &#125;        @GetMapping(&quot;/j2&quot;)      @ResponseBody // 不会走视图解析器，直接返回一个字符串      public String test2() throws JsonProcessingException &#123;            ArrayList&lt;User&gt; arr = new ArrayList&lt;&gt;();            User user = new User(&quot;呵帅1&quot;, 18, &quot;男&quot;);          User user2 = new User(&quot;呵帅2&quot;, 18, &quot;男&quot;);          User user3 = new User(&quot;呵帅3&quot;, 18, &quot;男&quot;);          User user4 = new User(&quot;呵帅4&quot;, 18, &quot;男&quot;);          User user5 = new User(&quot;呵帅5&quot;, 18, &quot;男&quot;);            arr.add(user);          arr.add(user2);          arr.add(user3);          arr.add(user4);          arr.add(user5);            return JsonUtils.getJson(arr);      &#125;        @GetMapping(&quot;/j3&quot;)      @ResponseBody // 不会走视图解析器，直接返回一个字符串      public String test3() throws JsonProcessingException &#123;            Date date = new Date();            return JsonUtils.getJson(date);        &#125;  &#125;

ModelAndView固定模板两个config
package com.example.config;    import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;    public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;        @Override      protected Class&lt;?&gt;[] getRootConfigClasses() &#123;          return new Class[]&#123;WebConfiguration.class&#125;;   //基本的Spring配置类，一般用于业务层配置      &#125;        @Override      protected Class&lt;?&gt;[] getServletConfigClasses() &#123;          return new Class[0];  //配置DispatcherServlet的配置类、主要用于Controller等配置，这里为了教学简单，就不分这么详细了，只使用上面的基本配置类      &#125;        @Override      protected String[] getServletMappings() &#123;          return new String[]&#123;&quot;/&quot;&#125;;    //匹配路径，与上面一致      &#125;  &#125;

package com.example.config;    import com.example.interceptor.MainInterceptor;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.ComponentScan;  import org.springframework.context.annotation.Configuration;  import org.springframework.web.servlet.config.annotation.EnableWebMvc;  import org.springframework.web.servlet.config.annotation.InterceptorRegistry;  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  import org.thymeleaf.spring6.SpringTemplateEngine;  import org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver;  import org.thymeleaf.spring6.view.ThymeleafViewResolver;  import org.thymeleaf.templateresolver.ITemplateResolver;    @Configuration  @EnableWebMvc   //快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置  @ComponentScan(&quot;com.example.controller&quot;)  public class WebConfiguration &#123;      //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面      @Bean      public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine)&#123;          ThymeleafViewResolver resolver = new ThymeleafViewResolver();          resolver.setOrder(1);   //可以存在多个视图解析器，并且可以为他们设定解析顺序          resolver.setCharacterEncoding(&quot;UTF-8&quot;);   //编码格式是重中之重          resolver.setTemplateEngine(springTemplateEngine);   //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎          return resolver;      &#125;        //配置模板解析器      @Bean      public SpringResourceTemplateResolver templateResolver()&#123;          SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();          resolver.setSuffix(&quot;.html&quot;);   //需要解析的后缀名称          resolver.setPrefix(&quot;classpath:&quot;);   //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀          return resolver;      &#125;        //配置模板引擎Bean      @Bean      public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver)&#123;          SpringTemplateEngine engine = new SpringTemplateEngine();          engine.setTemplateResolver(resolver);   //模板解析器，默认即可          return engine;      &#125;    &#125;

返回错误信息给页面package com.example.controller;    import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.ControllerAdvice;  import org.springframework.web.bind.annotation.ExceptionHandler;    @ControllerAdvice  public class ErrorController &#123;        @ExceptionHandler(Exception.class)      public String error(Exception e, Model model) &#123;          e.printStackTrace();          model.addAttribute(&quot;e&quot;, e);          return &quot;error&quot;;      &#125;  &#125;

获取cookie的方法@RequestMapping(&quot;/test2&quot;)  public String index2(@CookieValue(&quot;JSESSIONID&quot;) String id) &#123;      System.out.println(id);      return &quot;index&quot;;  &#125;

拦截器package com.example.interceptor;    import jakarta.servlet.http.HttpServletRequest;  import jakarta.servlet.http.HttpServletResponse;  import org.springframework.web.servlet.HandlerInterceptor;  import org.springframework.web.servlet.ModelAndView;    public class MainInterceptor implements HandlerInterceptor &#123;      @Override      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;          System.out.println(&quot;处理前&quot;);          return true;      &#125;        @Override      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;          System.out.println(&quot;处理后&quot;);      &#125;        @Override      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;          System.out.println(&quot;完成后&quot;);      &#125;    &#125;

这段代码是一个Spring框架中的拦截器（Interceptor）实现示例。拦截器是Spring MVC中处理请求的组件之一，它可以在请求的多个不同阶段执行自定义逻辑。这个MainInterceptor类实现了HandlerInterceptor接口，并重写了其中的三个方法，分别对应请求处理的不同阶段：

preHandle：在请求处理之前调用（Controller方法调用之前）。
postHandle：在请求处理之后调用，但在视图被渲染之前（Controller方法调用之后）。
afterCompletion：在请求处理之后调用，当所有的请求处理工作完成之后，也就是在DispatcherServlet渲染了对应的视图之后调用。
具体到这个MainInterceptor类：


preHandle方法中，打印了”处理前”，并返回true，表示请求可以继续向下执行。
postHandle方法中，打印了”处理后”，这个方法可以修改ModelAndView对象，但在这个示例中并没有进行任何操作。
afterCompletion方法中，打印了”完成后”，这个方法用于进行资源清理工作。

这个拦截器可以被注册到Spring MVC的配置中，以便在请求处理过程中自动调用。注册拦截器通常在Spring的配置类中通过WebMvcConfigurer接口的addInterceptors方法完成。
SpringSecurity配置环境**导入 maven 依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;      &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;      &lt;version&gt;6.3.4&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;      &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;      &lt;version&gt;6.1.4&lt;/version&gt;  &lt;/dependency&gt;

配置 SecurityInitializer ，与MVC一样，需要一个初始化器
package com.example.init;    import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;    public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer &#123;        // 这里会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的&#125;

然后我们创建一个配置类用于配置SpringSecurity
package com.example.config;    import org.springframework.context.annotation.Configuration;  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;    @Configuration  @EnableWebSecurity // 开启 WebSecurity 相关功能  public class SecurityConfiguration &#123;  &#125;

创建完 SecurityConfiguration 配置类后需要修改 MainInitializer 中的 getRootConfigClasses
@Override  protected Class&lt;?&gt;[] getRootConfigClasses() &#123;      return new Class[]&#123;WebConfiguration.class, SecurityConfiguration.class&#125;;&#125;


认证在Spring Security中，认证（Authentication）是确定用户身份的过程。它是Spring Security提供的安全功能的核心部分，用于验证用户是否为他们声称的那个人。
package com.example.config;    import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  import org.springframework.security.core.userdetails.User;  import org.springframework.security.core.userdetails.UserDetails;  import org.springframework.security.core.userdetails.UserDetailsService;  import org.springframework.security.provisioning.InMemoryUserDetailsManager;    @Configuration  @EnableWebSecurity // 开启 WebSecurity 相关功能  public class SecurityConfiguration &#123;        @Bean      public UserDetailsService userDetailsService() &#123;          UserDetails user = User                  .withDefaultPasswordEncoder()                  .username(&quot;hs&quot;)                  .password(&quot;123456&quot;)                  .build();          UserDetails admin = User                  .withDefaultPasswordEncoder()                  .username(&quot;admin&quot;)                  .password(&quot;123456&quot;)                  .build();          return new InMemoryUserDetailsManager(user, admin);      &#125;  &#125;

BCrypt加密工具在我们上面配置用户信息的时候发现 withDefaultPasswordEncoder 是已经被弃用的，因为用这种方式来存储密码并不安全。
这是因为SpringSecurity的密码校验建议使用加密算法将密码进行加密（或者说使用Hash处理）后将用户提供的密码与加密后的密码进行比较，而不是使用原文来进行匹配。
因此，我们在配置用户信息的时候，可以使用官方提供的BCrypt加密工具：
package com.example.config;    import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  import org.springframework.security.core.userdetails.User;  import org.springframework.security.core.userdetails.UserDetails;  import org.springframework.security.core.userdetails.UserDetailsService;  import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  import org.springframework.security.crypto.password.PasswordEncoder;  import org.springframework.security.provisioning.InMemoryUserDetailsManager;    @Configuration  @EnableWebSecurity // 开启 WebSecurity 相关功能  public class SecurityConfiguration &#123;        //这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择      @Bean      public PasswordEncoder passwordEncoder() &#123;          return new BCryptPasswordEncoder();      &#125;        @Bean      public UserDetailsService userDetailsService(PasswordEncoder encoder) &#123;          UserDetails user = User                  .withUsername(&quot;hs&quot;)                  .password(encoder.encode(&quot;123456&quot;))                  .build();          System.out.println(encoder.encode(&quot;123456&quot;));          UserDetails admin = User                  .withUsername(&quot;admin&quot;)                  .password(encoder.encode(&quot;123456&quot;))                  .build();          return new InMemoryUserDetailsManager(user, admin);      &#125;  &#125;

替换后，首先最直观的体验是没有黄线警告了，然后我们正常在登录页面输入账号密码，我们在程序中可以插入print看看加密后的密码是怎么样的：
第一次登录：$2a$10$PWLZcJqEFGmDWdz6OxQaLuTP&#x2F;nwi2KEZ1TwVNN3GqcuVJkcELalAG第二次登录：$2a$10$BZpxArIf6yP.xfYVE7MywuPLH46m6UsmTWeOkd6RGDE0BoTnhSmE6
我们会发现两次登录加密后的密码都不一样，这加密强在自己都不知道加密后是怎么样的
登录从现在开始，我们的网站不需要再自己编写登录模块了，这里我们可以直接去掉，只留下主页面：
package com.example.controller;    import com.alibaba.fastjson2.JSONObject;  import jakarta.servlet.http.HttpSession;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.*;    @Controller  public class HelloController &#123;        @ResponseBody      @PostMapping(&quot;/pay&quot;)      public JSONObject pay(@RequestParam String account, HttpSession session) &#123;          JSONObject jsonObject = new JSONObject();          if(session.getAttribute(&quot;login&quot;) != null)&#123;              System.out.println(&quot;转账给&quot; + account + &quot;成功，交易已完成&quot;);              jsonObject.put(&quot;success&quot;, true);          &#125; else &#123;              System.out.println(&quot;转账给&quot; + account + &quot;未成功，用户未登录&quot;);              jsonObject.put(&quot;success&quot;, false);          &#125;          return jsonObject;      &#125;        //处理首页或是登录界面跳转      @GetMapping(&quot;/&quot;)      public String index()&#123;          return &quot;index&quot;;      &#125;  &#125;

配置完成后即可通过上面配置的账号密码进行登录
403但是在页面中会发现，我们所有的Post请求都被403了
这是因为SpringSecurity自带了csrf防护，需求我们在POST请求中携带页面中的csrfToken才可以，否则一律进行拦截操作，这里我们可以将其嵌入到页面中，随便找一个地方添加以下内容：
&lt;input type=&quot;text&quot; th:id=&quot;$&#123;_csrf.getParameterName()&#125;&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; hidden&gt;

目前完整index.html：
&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;白马银行 - 首页&lt;/title&gt;      &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;div&gt;      &lt;label&gt;        转账账号：          &lt;input type=&quot;text&quot; id=&quot;account&quot;/&gt;      &lt;/label&gt;    &lt;input type=&quot;text&quot; th:id=&quot;$&#123;_csrf.getParameterName()&#125;&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; hidden&gt;      &lt;button onclick=&quot;pay()&quot;&gt;立即转账&lt;/button&gt;  &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;    &lt;script&gt;      function pay() &#123;          const account = document.getElementById(&quot;account&quot;).value          const _csrf = document.getElementById(&quot;_csrf&quot;).value          axios.post(&#x27;/mvc/pay&#x27;, &#123; account: account, _csrf: _csrf &#125;, &#123;              headers: &#123;                  &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;              &#125;          &#125;).then((&#123;data&#125;) =&gt; &#123;              if(data.success)                  alert(&quot;转账成功&quot;)              else                  alert(&quot;转账失败&quot;)          &#125;)      &#125;  &lt;/script&gt;



校验前面我们实现了登录用户功能，但我们会想到，一般来说，用户信息都是存在数据库里的，不可能一个个写在后configuration里面，所有我们需要使用到数据库
搭建环境我们使用官方默认提供的可以直接使用的用户和权限表设计，根本不需要我们来建表，直接在DataGrip 中执行以下查询：
create table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null);create table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username));create unique index ix_auth_username on authorities (username,authority);

然后我们需要导入所需的依赖
&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;    &lt;version&gt;8.0.31&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;6.0.10&lt;/version&gt;&lt;/dependency&gt;
基于数据库校验package com.example.config;    import org.apache.ibatis.datasource.pooled.PooledDataSource;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  import org.springframework.security.core.userdetails.User;  import org.springframework.security.core.userdetails.UserDetailsService;  import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  import org.springframework.security.crypto.password.PasswordEncoder;  import org.springframework.security.provisioning.JdbcUserDetailsManager;    import javax.sql.DataSource;    @Configuration  @EnableWebSecurity // 开启 WebSecurity 相关功能  public class SecurityConfiguration &#123;        //这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择      @Bean      public PasswordEncoder passwordEncoder() &#123;          return new BCryptPasswordEncoder();      &#125;        // 数据源      @Bean      public DataSource dataSource() &#123;          return new PooledDataSource(&quot;com.mysql.cj.jdbc.Driver&quot;,                  &quot;jdbc:mysql://localhost:3306/springsecurity_study&quot;,                  &quot;root&quot;,                  &quot;Abc123&quot;);      &#125;        @Bean      public UserDetailsService userDetailsService(PasswordEncoder encoder, DataSource dataSource) &#123;          JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);          manager.createUser(User.withUsername(&quot;hs&quot;)                  .password(encoder.encode(&quot;123456&quot;))                  .roles(&quot;USER&quot;)                  .build());          return manager;      &#125;  &#125;
这里使用的是JDBC的JdbcUserDetailsManager，自由度不高，挺死板的重启tomcat可以看到两张表中已经自动添加好对应的数据了：
修改密码通过使用UserDetailsManager对象，我们就能快速执行用户相关的管理操作，比如我们可以直接在网站上添加一个快速重置密码的接口，首先需要配置一下JdbcUserDetailsManager，为其添加一个AuthenticationManager用于原密码的校验：
@Configuration  @EnableWebSecurity // 开启 WebSecurity 相关功能  public class SecurityConfiguration &#123;        ......      //手动创建一个AuthenticationManager用于处理密码校验      private AuthenticationManager authenticationManager(UserDetailsManager manager,                                                          PasswordEncoder encoder)&#123;          DaoAuthenticationProvider provider = new DaoAuthenticationProvider();          provider.setUserDetailsService(manager);          provider.setPasswordEncoder(encoder);          return new ProviderManager(provider);      &#125;        @Bean      public UserDetailsManager userDetailsService(DataSource dataSource,                                                   PasswordEncoder encoder) throws Exception &#123;          JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);          //为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验          manager.setAuthenticationManager(authenticationManager(manager, encoder));          return manager;      &#125;    &#125;

编写接口
@Controller  public class HelloController &#123;        @Resource      UserDetailsManager manager;        @Resource      PasswordEncoder encoder;        @ResponseBody      @PostMapping(&quot;/change-password&quot;)      public JSONObject changePassword(@RequestParam String oldPassword,                                       @RequestParam String newPassword) &#123;          manager.changePassword(oldPassword, encoder.encode(newPassword));          JSONObject object = new JSONObject();          object.put(&quot;success&quot;, true);          return object;      &#125;      ......&#125;

最后在index.html中添加修改密码功能
&lt;div&gt;    &lt;label&gt;        修改密码：        &lt;input type=&quot;text&quot; id=&quot;oldPassword&quot; placeholder=&quot;旧密码&quot;/&gt;        &lt;input type=&quot;text&quot; id=&quot;newPassword&quot; placeholder=&quot;新密码&quot;/&gt;    &lt;/label&gt;    &lt;button onclick=&quot;change()&quot;&gt;修改密码&lt;/button&gt;&lt;/div&gt;

function change() &#123;    const oldPassword = document.getElementById(&quot;oldPassword&quot;).value    const newPassword = document.getElementById(&quot;newPassword&quot;).value    const csrf = document.getElementById(&quot;_csrf&quot;).value    axios.post(&#x27;/mvc/change-password&#x27;, &#123;        oldPassword: oldPassword,        newPassword: newPassword,        _csrf: csrf    &#125;, &#123;        headers: &#123;            &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;        &#125;    &#125;).then((&#123;data&#125;) =&gt; &#123;        alert(data.success ? &quot;密码修改成功&quot; : &quot;密码修改失败，请检查原密码是否正确&quot;)    &#125;)&#125;
这种方式虽然能够完成我们所需要的功能，但是太麻烦了，不适合在实际开发中使用。
自定义校验大多数，我们并不会用SpringSecurity默认的验证来设计，而是采用自定义的表校验。
首先自行在数据库中创建一个数据表，然后在项目中创建实体类
package com.example.entity;    import lombok.Data;    @Data  public class Account &#123;      int id;      String username;      String password;  &#125;

Service中调用数据库查询
package com.example.service;    import com.example.entity.Account;  import com.example.mapper.UserMapper;  import jakarta.annotation.Resource;  import org.springframework.security.core.userdetails.User;  import org.springframework.security.core.userdetails.UserDetails;  import org.springframework.security.core.userdetails.UserDetailsService;  import org.springframework.security.core.userdetails.UsernameNotFoundException;  import org.springframework.stereotype.Service;    @Service  public class AuthorizeService implements UserDetailsService &#123;        @Resource      UserMapper mapper;        @Override      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;          Account account = mapper.findUserByName(username);          if(account == null)              throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);          return User                  .withUsername(account.getUsername())                  .password(account.getPassword())                  .build();      &#125;  &#125;

根据用户名查询用户的Mapper接口：
package com.example.mapper;    import com.example.entity.Account;  import org.apache.ibatis.annotations.Select;    public interface UserMapper &#123;      @Select(&quot;select * from springsecurity_study.user where username = #&#123;username&#125;&quot;)      Account findUserByName(String username);  &#125;

别忘记在配置类WebConfiguration上添加相应的包扫描
@Configuration  @EnableWebMvc  @ComponentScans(&#123;          @ComponentScan(&quot;com.example.controller&quot;),          @ComponentScan(&quot;com.example.service&quot;)  &#125;)  @MapperScan(&quot;com.example.mapper&quot;)

最后，在SecurityConfiguration里配置mybatis
@Bean  public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;      SqlSessionFactoryBean bean = new SqlSessionFactoryBean();      bean.setDataSource(dataSource);      return bean;  &#125;

**注意：如果运行失败，则降低依赖的版本
其他配置自定义登录界面虽然SpringSecurity为我们提供了一个登录界面，但是很多情况下往往都是我们使用自定义的登录界面，这个时候就需要进行更多的配置了，我们还是以之前图书管理系统使用的模版为例。
首先先修改Controller
@Controllerpublic class HelloController &#123;    @GetMapping(&quot;/&quot;)    public String index()&#123;        return &quot;index&quot;;    &#125;    @GetMapping(&quot;/login&quot;)    public String login()&#123;        return &quot;login&quot;;    &#125;&#125;

不过现在依然是默认进入到SpringSecurity默认的登录界面，现在我们来配置自定义的登录界面，将我们的前端模版中的登录页面作为SpringSecurity的默认登录界面。
@Configuration@EnableWebSecuritypublic class SecurityConfiguration &#123;  	...	@Bean  	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;  	    return http  	            //以下是验证请求拦截和放行配置  	            .authorizeHttpRequests(auth -&gt; &#123;  	                auth.requestMatchers(new AntPathRequestMatcher(&quot;/static/**&quot;));//静态资源放行  	                auth.anyRequest().authenticated();    //将所有请求全部拦截，一律需要验证  	            &#125;)  	            //以下是表单登录相关配置  	            .formLogin(conf -&gt; &#123;  	                conf.loginPage(&quot;/login&quot;);   //将登录页设置为我们自己的登录页面  	                conf.loginProcessingUrl(&quot;/doLogin&quot;); //登录表单提交的地址，可以自定义  	                conf.defaultSuccessUrl(&quot;/&quot;);   //登录成功后跳转的页面  	                conf.permitAll();    //将登录相关的地址放行，否则未登录的用户连登录界面都进不去  	                //用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求  	                conf.usernameParameter(&quot;username&quot;);  	                conf.passwordParameter(&quot;password&quot;);  	            &#125;)  	            .build();  	&#125;

需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为/login，登陆请求地址为/doLogin，登陆页面我们刚刚已经自己编写Controller来实现了，登陆请求提交处理由SpringSecurity提供，只需要写路径就可以了。
**如果页面加载失败没有格式，记得查看是不是没有给静态资源放行
.authorizeHttpRequests(auth -&gt; &#123;      auth.requestMatchers(&quot;/static/**&quot;).permitAll();   //将所有的静态资源放行，一定要添加在全部请求拦截之前      auth.anyRequest().authenticated();    //将所有请求全部拦截，一律需要验证&#125;)

登出按钮和关闭scrf.logout(conf -&gt; &#123;      conf.logoutUrl(&quot;/doLogout&quot;);      conf.logoutSuccessUrl(&quot;/login&quot;);      conf.permitAll();  &#125;)  ..csrf(AbstractHttpConfigurer::disable)

记住我之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦
SpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。**记得修改前端页面中的表单。
.rememberMe(conf -&gt; &#123;      // conf.alwaysRemember(true);//无论点不点“记住我”，都记住用户      // conf.rememberMeParameter(&quot;remember-me&quot;);// 记住我表单字段，默认就是这个，可以不配置      // conf.rememberMeCookieName(&quot;xxxx&quot;);// 记住我cookie名称，默认就是这个，可以不配置  &#125;)



这个Cookie信息的过期时间并不是仅会话，而是默认保存一段时间，当然，由于记住我信息是存放在内存中的，我们需要保证服务器一直处于运行状态，如果关闭服务器的话，记住我信息会全部丢失，因此，如果我们希望记住我能够一直持久化保存，我们就需要进一步进行配置。我们需要创建一个基于JDBC的TokenRepository实现
@Beanpublic PersistentTokenRepository tokenRepository(DataSource dataSource)&#123;    JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl();  	//在启动时自动在数据库中创建存储记住我信息的表，仅第一次需要，后续不需要    repository.setCreateTableOnStartup(true);    repository.setDataSource(dataSource);    return repository;&#125;

设置持久化存储时间
.rememberMe(conf -&gt; &#123;     conf.rememberMeParameter(&quot;remember-me&quot;);     conf.tokenRepository(repository);      //设置刚刚的记住我持久化存储库     conf.tokenValiditySeconds(60 * 60 * 24 * 7);   //设置记住我有效时间为7天&#125;)

授权用户登录后，可能会根据用户当前是身份进行角色划分，每个角色执行不同的功能。
SpringSecurity为我们提供了两种授权方式：

基于权限的授权：只要拥有某权限的用户，就可以访问某个路径。
基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径。

基于角色授权配置开发现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。
首先先修改数据库中的字段，添加一个role字段，接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：
.authorizeHttpRequests(auth -&gt; &#123;    //静态资源依然全部可以访问    auth.requestMatchers(&quot;/static/**&quot;).permitAll();    //只有具有以下角色的用户才能访问路径&quot;/&quot;    auth.requestMatchers(&quot;/&quot;).hasAnyRole(&quot;user&quot;, &quot;admin&quot;);    //其他所有路径必须角色为admin才能访问    auth.anyRequest().hasRole(&quot;admin&quot;);&#125;)

修改实体类：
@Datapublic class Account &#123;    int id;    String username;    String password;    String role;&#125;

修改我们之前写的获取用户信息：
 @Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;    Account account = mapper.findUserByName(username);    if(account == null)        throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);    return User            .withUsername(username)            .password(account.getPassword())            .roles(account.getRole())   //添加角色，一个用户可以有一个或多个角色            .build();&#125;

最后可以实验，只有admin可以访问其他页面，其他用户只能访问index
基于权限授权基于权限的授权与角色类似，需要以hasAnyAuthority或hasAuthority进行判断：
.authorizeHttpRequests(auth -&gt; &#123;    //静态资源依然全部可以访问    auth.requestMatchers(&quot;/static/**&quot;).permitAll();    //基于权限和基于角色其实差别并不大，使用方式是相同的    auth.anyRequest().hasAnyAuthority(&quot;page:index&quot;);&#125;)

这里是index页面运行所有用户访问
注解开发首先需要在配置类（这里是在MVC的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由MVC配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：
@Configuration@EnableWebSecurity@EnableMethodSecurity   //开启方法安全校验public class SecurityConfiguration &#123;	...&#125;

现在就可以在想要进行权限校验的方法上添加注解了，通过添加@PreAuthorize注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。
@PreAuthorize(&quot;hasAnyRole(&#x27;user&#x27;, &#x27;&#x27;admin)&quot;)@GetMapping(&quot;/&quot;)  public String index()&#123;      return &quot;index&quot;;  &#125;

同样的还有@PostAuthorize注解，但是它是在方法执行之后再进行拦截：
@PostAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)@RequestMapping(&quot;/&quot;)public String index()&#123;    System.out.println(&quot;执行了&quot;);    return &quot;index&quot;;&#125;

除了Controller以外，只要是被Spring托管的Bean都可以使用注解形式来控制权限，可以在任意方法上添加这个注解，只要不具备表达式中指定的访问权限，就无法执行方法并且放回403页面。
固定模板(终)MvcConfiguration
package com.example.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.thymeleaf.spring6.SpringTemplateEngine;import org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver;import org.thymeleaf.spring6.view.ThymeleafViewResolver;import org.thymeleaf.templateresolver.ITemplateResolver;@EnableWebMvc@Configurationpublic class MvcConfiguration implements WebMvcConfigurer &#123;    @Bean    public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine)&#123;        ThymeleafViewResolver resolver = new ThymeleafViewResolver();        resolver.setOrder(1);   //可以存在多个视图解析器，并且可以为他们设定解析顺序        resolver.setCharacterEncoding(&quot;UTF-8&quot;);   //编码格式是重中之重        resolver.setTemplateEngine(springTemplateEngine);   //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎        return resolver;    &#125;    //配置模板解析器    @Bean    public SpringResourceTemplateResolver templateResolver()&#123;        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();        resolver.setSuffix(&quot;.html&quot;);   //需要解析的后缀名称        resolver.setPrefix(&quot;classpath:/templates/&quot;);   //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀        resolver.setCharacterEncoding(&quot;UTF-8&quot;);        return resolver;    &#125;    //配置模板引擎Bean    @Bean    public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver)&#123;        SpringTemplateEngine engine = new SpringTemplateEngine();        engine.setTemplateResolver(resolver);   //模板解析器，默认即可        return engine;    &#125;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123;        configurer.enable();   //开启默认Servlet处理    &#125;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);    &#125;&#125;]]></content>
  </entry>
  <entry>
    <title>mybatis-plus 组件策略</title>
    <url>/2025/04/18/articles/Substitute%20driver/mybatis-plus%20%E7%BB%84%E4%BB%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[默认的组件策略 ASSIGN_ID 雪花算法
mp有默认的组件策略 ASSIGN_ID，会生成一个唯一的值，包含数字

雪花算法：使用一个64位的长型的数字作为全局唯一ID

表对应类型 bigint 或者 varchar类型


ASSIGN_UUID
ASSIGN_ID 还有另一个相近的策略 ASSIGN_UUID，生成唯一的uuid值，包含数字和字母

表对应字段的类型 varchar(32) 类型，实体类字段对应 String


自增策略 AUTO
想要主键自增需要配置以下操作

需要创建表的时候给主键设置自增

实体字段种配置 @TableId(type=IdType.AUTO)




INPUT
普遍用法是需要自己手动设置主键ID值，有其他复杂用法，但是看着感觉运用不多，需要的时候再做了解

]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture异步编排</title>
    <url>/2025/06/23/articles/Substitute%20driver/CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</url>
    <content><![CDATA[简介
CompletableFuture是java.utils.concurrent里的一个类

作用：把串行执行的代码变为并行执行，提高代码执行速度


快速上手创建异步编排对象public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);



线程串行方法// 使线程串行执行，无入参，无返回值public CompletableFuture&lt;Void&gt; thenRun(Runnable action);public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action);public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor);// 使线程串行执行，有入参，无返回值public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor);// 使线程串行执行，有入参，有返回值public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor);

多任务组合public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);

代码实例public class CompletableFutureTest5 &#123;    @SneakyThrows    public static void main(String[] args) &#123;        //动态获取服务器核数        int processors = Runtime.getRuntime().availableProcessors();        ThreadPoolExecutor executor = new ThreadPoolExecutor(                processors+1, // 核心线程个数 io:2n ,cpu: n+1  n:内核数据                processors+1,                0,                TimeUnit.SECONDS,                new ArrayBlockingQueue&lt;&gt;(10),                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.AbortPolicy()        );        CompletableFuture&lt;String&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &quot;任务1&quot;, executor);        CompletableFuture&lt;String&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &quot;任务2&quot;, executor);        CompletableFuture&lt;String&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;            try &#123;                Thread.sleep(3000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            return &quot;任务3&quot;;        &#125;, executor);        // 串联起若干个线程任务, 没有返回值        CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future01, future02, future03);        // 等待所有线程执行完成        // .join()和.get()都会阻塞并获取线程的执行情况        // .join()会抛出未经检查的异常，不会强制开发者处理异常 .get()会抛出检查异常，需要开发者处理        all.join();        all.get();    &#125;&#125;  ]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事物锁</title>
    <url>/2025/06/07/articles/Substitute%20driver/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9%E9%94%81/</url>
    <content><![CDATA[分布式锁解决司机抢单因为上面写的司机抢单并没有考虑并发，类似于电商的超卖问题
**解决方案

第一种 设置数据库事务的隔离级别，设置为Serializable，效率低下

第二种 使用乐观锁解决，通过版本号进行控制

第三种  加锁解决，学习过synchronized 及lock锁，本地锁，目前微服务架构，分布式部署方式。


本地锁的局限性
我们使用锁一般都是，synchronized 及lock锁，这些都是本地锁，只在当前jvm生效，在微服务里面就是只有当个微服务生效
举例演示TestController@Tag(name = &quot;测试接口&quot;)  @RestController  @RequestMapping(&quot;/order/test&quot;)  public class TestController &#123;        @Autowired      private TestService testService;        @GetMapping(&quot;testLock&quot;)      public Result testLock() &#123;          testService.testLock();          return Result.ok();      &#125;  &#125;

TestServiceImpl
@Service  public class TestServiceImpl implements TestService&#123;        @Autowired      private StringRedisTemplate redisTemplate;        @Override      public synchronized void testLock() &#123;          //从redis里面获取数据          String value = redisTemplate.opsForValue().get(&quot;num&quot;);            if(StringUtils.isBlank(value)) &#123;              return;          &#125;            //把从redis获取数据+1          int num = Integer.parseInt(value);            //数据+1之后放回到redis里面          redisTemplate.opsForValue().set(&quot;num&quot;,String.valueOf(++num));      &#125;  &#125;


测试，模拟200个请求并发过程

在redis添加初始值，num &#x3D; 0


使用测试工具 jmeter 实现功能测试
![[Pasted image 20250605203137.png]]![[Pasted image 20250605203153.png]]
加上锁 synchronized 后是没有问题

上面的测试方式是在一个服务内进行的，单机测试，但是如果部署到集群下这个锁不一定会生效

实现分布式锁-redis设置过期时间，到时间之后自动释放锁
@Overridepublic void testLock() &#123;	//从redis里面获取数据	//1 获取当前锁  setnx	Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;lock&quot;);	//2 如果获取到锁，从redis获取数据 数据+1 放回redis里面	if(ifAbsent) &#123;		//获取锁成功，执行业务代码		//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0		String value = redisTemplate.opsForValue().get(&quot;num&quot;);		//2.如果值为空则非法直接返回即可		if (StringUtils.isBlank(value)) &#123;			return;		&#125;		//3.对num值进行自增加一		int num = Integer.parseInt(value);		redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));		//3 释放锁		redisTemplate.delete(&quot;lock&quot;);	&#125; else &#123;		try &#123;			Thread.sleep(100);			this.testLock();		&#125; catch (InterruptedException e) &#123;			e.printStackTrace();		&#125;	&#125;&#125;

问题：如果锁的删除时间小于事物的执行时间例如：

场景：如果业务逻辑执行的时间是7s
index1业务逻辑没执行完，3秒后释放
index2获取到锁，执行业务逻辑，3秒后锁会被自动释放
index3获取到锁，执行业务逻辑
index1业务逻辑完成，开始调用del释放锁，这是释放的是index3的锁，导致index3的业务只执行1s就被别人释放

修改后的代码
//uuid防止误删@Overridepublic void testLock() &#123;    //从redis里面获取数据    String uuid = UUID.randomUUID().toString();    //1 获取当前锁  setnx  + 设置过期时间    //        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;lock&quot;);    Boolean ifAbsent =            redisTemplate.opsForValue()                    .setIfAbsent(&quot;lock&quot;, uuid,10, TimeUnit.SECONDS);    //2 如果获取到锁，从redis获取数据 数据+1 放回redis里面    if(ifAbsent) &#123;        //获取锁成功，执行业务代码        //1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0        String value = redisTemplate.opsForValue().get(&quot;num&quot;);        //2.如果值为空则非法直接返回即可        if (StringUtils.isBlank(value)) &#123;            return;        &#125;        //3.对num值进行自增加一        int num = Integer.parseInt(value);        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));        //出现异常        //3 释放锁        String redisUuid = redisTemplate.opsForValue().get(&quot;lock&quot;);        if(uuid.equals(redisUuid)) &#123;            redisTemplate.delete(&quot;lock&quot;);        &#125;           &#125; else &#123;        try &#123;            Thread.sleep(100);            this.testLock();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

通过LUA脚本保证原子性通过uuid防止误删，但是还是有问题，不具备原子性
@Overridepublic void testLock() &#123;	//从redis里面获取数据	String uuid = UUID.randomUUID().toString();	//1 获取当前锁  setnx  + 设置过期时间	//        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;lock&quot;);	Boolean ifAbsent =			redisTemplate.opsForValue()					.setIfAbsent(&quot;lock&quot;, uuid,3, TimeUnit.SECONDS);	//2 如果获取到锁，从redis获取数据 数据+1 放回redis里面	if(ifAbsent) &#123;		//获取锁成功，执行业务代码		//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0		String value = redisTemplate.opsForValue().get(&quot;num&quot;);		//2.如果值为空则非法直接返回即可		if (StringUtils.isBlank(value)) &#123;			return;		&#125;		//3.对num值进行自增加一		int num = Integer.parseInt(value);		redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));		//出现异常		//3 释放锁 lua脚本实现		DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();		// lua脚本		String script = &quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1]\n&quot; +				&quot;then\n&quot; +				&quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot; +				&quot;else\n&quot; +				&quot;    return 0\n&quot; +				&quot;end&quot;;		redisScript.setScriptText(script);		// 设置返回结果		redisScript.setResultType(Long.class);		redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;), uuid);	&#125; else &#123;		try &#123;			Thread.sleep(100);			this.testLock();		&#125; catch (InterruptedException e) &#123;			e.printStackTrace();		&#125;	&#125;&#125;

总结1、加锁
// 1. 从Redis中获取锁,set k1 v1 px 20000 nxString uuid = UUID.randomUUID().toString();Boolean lock = this.redisTemplate.opsForValue()      .setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS);

2、使用lua释放锁
// 2. 释放锁 delString script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;// 设置lua脚本返回的数据类型DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();// 设置lua脚本返回类型为LongredisScript.setResultType(Long.class);redisScript.setScriptText(script);redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid);

3、重试
Thread.sleep(500); testLock();

为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：
第一个：互斥性，在任何时刻，只有一个客户端能持有锁。
第二个：不会发生死锁，即使有一个客户端在获取锁操作时候崩溃了，也能保证其他客户端能获取到锁。
第三个：解铃还须系铃人，解锁加锁必须同一个客户端操作。
第四个：加锁和解锁必须具备原子性
实现分布式锁-Redisson准备工作引入依赖在common里service-utils引入依赖
&lt;dependency&gt;      &lt;groupId&gt;org.redisson&lt;/groupId&gt;      &lt;artifactId&gt;redisson&lt;/artifactId&gt;  &lt;/dependency&gt;

创建Redisson配置类@Data  @Configuration  @ConfigurationProperties(prefix = &quot;spring.data.redis&quot;)  public class RedissonConfig &#123;        private String host;        private String password;        private String port;        private int timeout = 3000;      private static String ADDRESS_PREFIX = &quot;redis://&quot;;        @Bean      RedissonClient redissonSingle() &#123;          Config config = new Config();            if(!StringUtils.hasText(host))&#123;              throw new RuntimeException(&quot;host is  empty&quot;);          &#125;          SingleServerConfig serverConfig = config.useSingleServer()                  .setAddress(ADDRESS_PREFIX + this.host + &quot;:&quot; + port)                  .setTimeout(this.timeout);          if(StringUtils.hasText(this.password)) &#123;              serverConfig.setPassword(this.password);          &#125;          return Redisson.create(config);      &#125;  &#125;


在业务方法编写加锁和解锁// Redisson实现  @Override  public void testLock() &#123;  	// 通过redisson创建锁对象  	RLock lock = redissonClient.getLock(&quot;lock1&quot;);  	// 尝试获取锁  	// 阻塞一直等待直到获取到，获取锁之后设置锁的超时时间为10秒，没有参数默认是30秒  	lock.lock(10, TimeUnit.SECONDS);  	// tryLock，设置等待时间为30秒，超时时间为10秒  //        try &#123;  //            boolean b = lock.tryLock(30, 10, TimeUnit.SECONDS);  //        &#125; catch (InterruptedException e) &#123;  //            throw new RuntimeException(e);  //        &#125;  	//编写业务代码  	//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0  	String value = redisTemplate.opsForValue().get(&quot;num&quot;);  	//2.如果值为空则非法直接返回即可  	if (StringUtils.isBlank(value)) &#123;  		return;  	&#125;  	//3.对num值进行自增加一  	int num = Integer.parseInt(value);  	redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));  	//释放锁  	lock.unlock();  &#125;

看门狗原理只要线程加锁成功，就会启动一个watch dog看门狗，它是一个后台进程，每隔十秒检查一下，如果线程还持有锁，那么就会不断延长锁key的生存时间，因此可以解决锁过期释放，业务还没完成的问题

若使用 tryLock() 方法并指定了租约时间，则不会启动看门狗
如果我们未指定超时时间，就会使用 lockwatchdogTimeout = 30 * 1000

]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2025/06/17/articles/Substitute%20driver/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BMongoDB/</url>
    <content><![CDATA[概述
MongoDB 与传统关系型数据库相比更加简单，架构为key-value结构
MySQL数据库：数据库-表-记录MongoDB      ：数据库-集合-文档（记录）
文档类似于JSON对象，结构成为BSON

安装与启动1. 导入 MongoDB 官方 GPG 密钥首先需要导入 MongoDB 官方的 GPG 密钥，以便系统能够验证下载包的完整性。
curl -fsSL https://pgp.mongodb.com/server-7.0.asc | \   sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg \   --dearmor

2. 添加 MongoDB 软件源将 MongoDB 的软件源添加到系统的源列表中，这样就可以通过包管理器直接下载 MongoDB。
echo &quot;deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list

3. 更新包索引添加完软件源后，需要更新本地的包索引，让系统知道有哪些新的软件包可以安装。
sudo apt-get update

4. 安装 MongoDB 7.0.0使用包管理器安装指定版本的 MongoDB。
sudo apt-get install -y mongodb-org=7.0.0 mongodb-org-database=7.0.0 mongodb-org-server=7.0.0 mongodb-org-shell=7.0.0 mongodb-org-mongos=7.0.0 mongodb-org-tools=7.0.0

5. 锁定 MongoDB 版本为了防止系统自动升级 MongoDB 版本，需要对其进行版本锁定。
echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-database hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections

6. 启动 MongoDB 服务安装完成后，启动 MongoDB 服务并设置为开机自启动。
sudo systemctl start mongodsudo systemctl enable mongod

7. 验证安装结果通过以下命令检查 MongoDB 服务的运行状态，确认是否安装成功。
sudo systemctl status mongod

Linux进入MongoDB
mongosh

show dbs  # 查看数据库db.version() # 查看版本  db.getMongo()  # 查看当前db的链接机器地址db.help()    # 帮助quit()       # 退出

命令行操作MongoDB数据库操作创建数据库，如果数据库不存在，则创建数据库，否则切换数据库
use 库名

查看当前数据库
db.getName()

查看当前数据库状态
db.stats()

删除当前数据库
db.dropDatabase()


集合操作创建集合
db.createCollection(&quot;User&quot;)

删除集合
db.集合名.drop()


文档操作注意：

MongoDB区分类型和大小写
MongoDB文档不能有重复的键

insert，向集合插入一条记录。可以预先使用 createCollection 方法创建，也可以不先创建，直接插入，集合会自动创建
db.集合名.insert(&#123;name:&#x27;zhangsan&#x27;,age:21,sex:true&#125;)

find，查询当前集合中name是zhangsan的数据，空参的话是查询全部
db.集合名.find(&#123;name:zhangsan&#125;)

update，只更新匹配到的第一条记录
db.集合名.update(&#123;age:21&#125;,&#123;$set:&#123;name:100&#125;)
更新匹配到的所有记录
db.集合名.update(&#123;age:21&#125;,&#123;set:&#123;name:100&#125;&#125;,&#123;multi:true&#125;)

remove，删除一个文档
db.集合名.remove(id)
删除所有文档
db.集合名.remove(&#123;&#125;)

SpringBoot整合MongoDB
spring-data-mongodb提供了两种方式

第一种 MongoTemplate（更灵活）
第二种 MongoRepository（操作简单）
准备工作第一步 创建项目，导入依赖
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;artifactId&gt;mongo_demo0&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mongodb--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;

第二步 创建项目文件
application.yml
spring:  data:    mongodb:      database: daijia      host: 47.107.42.25      port: 27017

第三步 创建实体类
@Data@Document(&quot;user&quot;) //指定mongodb中的集合名字public class User &#123;    @Id    private ObjectId id;        private String name;    private Integer age;    private String email;    private Date createDate;&#125;

MongoRepository
添加interface继承MongoRepository

public interface UserRepository extends MongoRepository&lt;User, ObjectId&gt; &#123;&#125;

普通方法
编写测试类

@SpringBootTestpublic class MongoRepositoryTest &#123;    @Autowired    private UserRepository userRepository;    //添加    @Test    public void add() &#123;        User user = new User();        user.setName(&quot;mary&quot;);        user.setAge(30);        user.setCreateDate(new Date());        userRepository.save(user);    &#125;    //查询所有    @Test    public void findAll() &#123;        List&lt;User&gt; list = userRepository.findAll();        System.out.println(list);    &#125;    //根据id查询    @Test    public void testFindById() &#123;        Optional&lt;User&gt; optional =                userRepository.findById(new ObjectId(&quot;666a9a85f5294513720647ff&quot;));        boolean present = optional.isPresent();        if(present) &#123;            User user = optional.get();            System.out.println(user);        &#125;    &#125;    //条件查询 + 排序    // age = 20    @Test    public void testFindCondition() &#123;        //封装条件        User user = new User();        user.setAge(20);        Example&lt;User&gt; example = Example.of(user);        Sort sort = Sort.by(Sort.Direction.DESC, &quot;name&quot;);        List&lt;User&gt; list = userRepository.findAll(example, sort);        System.out.println(list);    &#125;    //分页查询    @Test    public void testPage() &#123;        //第一页从0开始的        PageRequest pageable = PageRequest.of(0,2);        Page&lt;User&gt; page = userRepository.findAll(pageable);        List&lt;User&gt; list = page.getContent();        System.out.println(list);    &#125;    //更新    @Test    public void testUpdateUser()&#123;        //注意：先查询，再更新        Optional&lt;User&gt; optional = userRepository.findById(                new ObjectId(&quot;64eee9dff317c823c62b4faf&quot;)        );        if(optional.isPresent())&#123;            User user = optional.get();            user.setAge(100);            //user中包含id，就会执行更新            userRepository.save(user);            System.out.println(user);        &#125;    &#125;    //删除    @Test    public void testDeleteUser()&#123;        userRepository.deleteById(                new ObjectId(&quot;64eee9dff317c823c62b4faf&quot;)        );    &#125;&#125;

命名方法
MongoRepository也可以按照规则在把查询方法创建出来

总体规模：

查询方法 以  get   |   find   |   read开头
后面街上查询字段名称，满足大驼峰命名
字段查询条件添加关键字，比如like

比如：
@Repository  public interface OrderServiceLocationRepository extends MongoRepository&lt;OrderServiceLocation, String&gt; &#123;        // 根据订单id获取位置信息，按照创建时间排序      List&lt;OrderServiceLocation&gt; findByOrderIdOrderByCreateTimeAsc(Long orderId);  &#125;

MongoTemplate@SpringBootTestpublic class MongoTemplateTest &#123;    @Autowired    private MongoTemplate mongoTemplate;    //添加    @Test    public void add() &#123;        User user = new User();        user.setName(&quot;test&quot;);        user.setAge(20);        user.setCreateDate(new Date());        mongoTemplate.insert(user);    &#125;    //查询所有    @Test    public void findAll() &#123;        List&lt;User&gt; list = mongoTemplate.findAll(User.class);        list.forEach(user-&gt;&#123;            System.out.println(user);        &#125;);    &#125;    //根据id查询    @Test    public void testFindId() &#123;        User user = mongoTemplate.findById(&quot;666a9b5e9a3653796627bb3c&quot;, User.class);        System.out.println(user);    &#125;    //条件查询    @Test    public void testCondition() &#123;        // where name=? and age=?        Criteria criteria =                Criteria.where(&quot;name&quot;).is(&quot;test&quot;).and(&quot;age&quot;).is(20);        Query query = new Query(criteria);        List&lt;User&gt; list = mongoTemplate.find(query,User.class);        System.out.println(list);    &#125;    //分页查询    @Test    public void testPage() &#123;        // limit 0,2        Query query = new Query();        List&lt;User&gt; list = mongoTemplate.find(query.skip(0).limit(2), User.class);        list.forEach(user-&gt;&#123;            System.out.println(user);        &#125;);    &#125;    //修改和删除    //修改    @Test    public void testUpdateUser() &#123;        Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;64eeeae31711344f35635788&quot;);        Query query = new Query(criteria);        Update update = new Update();        update.set(&quot;name&quot;, &quot;zhangsan&quot;);        update.set(&quot;age&quot;, 99);        UpdateResult result = mongoTemplate.upsert(query, update, User.class);//改一条        //UpdateResult result = mongoTemplate.updateMulti(query, update, User.class);//改多条        long count = result.getModifiedCount();        System.out.println(count);    &#125;    //删除    @Test    public void testRemove() &#123;        Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;64eeeae31711344f35635788&quot;);        Query query = new Query(criteria);        DeleteResult result = mongoTemplate.remove(query, User.class);        long count = result.getDeletedCount();        System.out.println(count);    &#125;&#125;

































]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见的几个问题</title>
    <url>/2025/05/08/articles/Substitute%20driver/Redis%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[缓存雪崩当大量缓存在同一时间失效或者过期，亦或者Redis故障宕机时，如果此时有大量用户数据访问，Redis 无法处理，于是全部请求都会直接访问数据库，导致数据库压力剧增，严重会导致数据库宕机，从而出现更严重的问题
常见解决方法：

给各数据设置不相同的过期时间，尽量让他们不要在同一时间过期
设置互斥锁，当发现需要查找的数据在Redis中找不到，就加上一个互斥锁，保证一个时间只有规定的次数查询数据库来构建缓存
如果是宕机，那我们可以用熔断来解决，或者是拒绝服务

缓存击穿缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩其中之一
如果缓存中某个热点数据过期了，此时大量的数据请求访问了该数据，就无法从缓存中读取，直接访问数据库，数据库很容易被高并发的请求冲垮，这就是缓存击穿问题。
常见解决方法：

互斥锁方案，保证同一时间只有一个业务线程更新缓存
不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；

缓存穿透当用户访问的数据不存在，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，那么此时大量的请求都落在数据库中，导致数据库压力骤增
常见解决方法

限制非法请求，进行参数校验，对于不合法的参数请求直接抛出异常返回给客户端。
缓存空值或者默认值，当发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，使其不会继续查询数据库
使用布隆过滤器，过滤器说数据不存在，那么数据库中一定不会有这个数据。如果说数据存在，并不一定证明数据库中存在这个数据，有误判的几率，只不过几率非常小。（底层是hash，有极小概率误判）

]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手xxl-job</title>
    <url>/2025/05/31/articles/Substitute%20driver/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bxxl-job/</url>
    <content><![CDATA[XXL-JOB入门案例第一步下载XXL-JOB示例代码，解压，使用idea打开
**项目组成：

admin：调度中心
core：公共依赖
sample
sample-frameless：不带框架的
sample-springboot：带springboot框架的



第二步创建XXL-JOB使用数据库和相关表
在示例代码文件里面doc文件夹下的db里面有相关的sql语句，直接拉到数据库即可
代码如下
#  # XXL-JOB v2.3.0  # Copyright (c) 2015-present, xuxueli.    CREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci;  use `xxl_job`;    SET NAMES utf8mb4;    CREATE TABLE `xxl_job_info` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `job_group` int(11) NOT NULL COMMENT &#x27;执行器主键ID&#x27;,    `job_desc` varchar(255) NOT NULL,    `add_time` datetime DEFAULT NULL,    `update_time` datetime DEFAULT NULL,    `author` varchar(64) DEFAULT NULL COMMENT &#x27;作者&#x27;,    `alarm_email` varchar(255) DEFAULT NULL COMMENT &#x27;报警邮件&#x27;,    `schedule_type` varchar(50) NOT NULL DEFAULT &#x27;NONE&#x27; COMMENT &#x27;调度类型&#x27;,    `schedule_conf` varchar(128) DEFAULT NULL COMMENT &#x27;调度配置，值含义取决于调度类型&#x27;,    `misfire_strategy` varchar(50) NOT NULL DEFAULT &#x27;DO_NOTHING&#x27; COMMENT &#x27;调度过期策略&#x27;,    `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT &#x27;执行器路由策略&#x27;,    `executor_handler` varchar(255) DEFAULT NULL COMMENT &#x27;执行器任务handler&#x27;,    `executor_param` varchar(512) DEFAULT NULL COMMENT &#x27;执行器任务参数&#x27;,    `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT &#x27;阻塞处理策略&#x27;,    `executor_timeout` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;任务执行超时时间，单位秒&#x27;,    `executor_fail_retry_count` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;失败重试次数&#x27;,    `glue_type` varchar(50) NOT NULL COMMENT &#x27;GLUE类型&#x27;,    `glue_source` mediumtext COMMENT &#x27;GLUE源代码&#x27;,    `glue_remark` varchar(128) DEFAULT NULL COMMENT &#x27;GLUE备注&#x27;,    `glue_updatetime` datetime DEFAULT NULL COMMENT &#x27;GLUE更新时间&#x27;,    `child_jobid` varchar(255) DEFAULT NULL COMMENT &#x27;子任务ID，多个逗号分隔&#x27;,    `trigger_status` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;调度状态：0-停止，1-运行&#x27;,    `trigger_last_time` bigint(13) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;上次调度时间&#x27;,    `trigger_next_time` bigint(13) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;下次调度时间&#x27;,    PRIMARY KEY (`id`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_log` (    `id` bigint(20) NOT NULL AUTO_INCREMENT,    `job_group` int(11) NOT NULL COMMENT &#x27;执行器主键ID&#x27;,    `job_id` int(11) NOT NULL COMMENT &#x27;任务，主键ID&#x27;,    `executor_address` varchar(255) DEFAULT NULL COMMENT &#x27;执行器地址，本次执行的地址&#x27;,    `executor_handler` varchar(255) DEFAULT NULL COMMENT &#x27;执行器任务handler&#x27;,    `executor_param` varchar(512) DEFAULT NULL COMMENT &#x27;执行器任务参数&#x27;,    `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT &#x27;执行器任务分片参数，格式如 1/2&#x27;,    `executor_fail_retry_count` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;失败重试次数&#x27;,    `trigger_time` datetime DEFAULT NULL COMMENT &#x27;调度-时间&#x27;,    `trigger_code` int(11) NOT NULL COMMENT &#x27;调度-结果&#x27;,    `trigger_msg` text COMMENT &#x27;调度-日志&#x27;,    `handle_time` datetime DEFAULT NULL COMMENT &#x27;执行-时间&#x27;,    `handle_code` int(11) NOT NULL COMMENT &#x27;执行-状态&#x27;,    `handle_msg` text COMMENT &#x27;执行-日志&#x27;,    `alarm_status` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败&#x27;,    PRIMARY KEY (`id`),    KEY `I_trigger_time` (`trigger_time`),    KEY `I_handle_code` (`handle_code`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_log_report` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `trigger_day` datetime DEFAULT NULL COMMENT &#x27;调度-时间&#x27;,    `running_count` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;运行中-日志数量&#x27;,    `suc_count` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;执行成功-日志数量&#x27;,    `fail_count` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;执行失败-日志数量&#x27;,    `update_time` datetime DEFAULT NULL,    PRIMARY KEY (`id`),    UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_logglue` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `job_id` int(11) NOT NULL COMMENT &#x27;任务，主键ID&#x27;,    `glue_type` varchar(50) DEFAULT NULL COMMENT &#x27;GLUE类型&#x27;,    `glue_source` mediumtext COMMENT &#x27;GLUE源代码&#x27;,    `glue_remark` varchar(128) NOT NULL COMMENT &#x27;GLUE备注&#x27;,    `add_time` datetime DEFAULT NULL,    `update_time` datetime DEFAULT NULL,    PRIMARY KEY (`id`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_registry` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `registry_group` varchar(50) NOT NULL,    `registry_key` varchar(255) NOT NULL,    `registry_value` varchar(255) NOT NULL,    `update_time` datetime DEFAULT NULL,    PRIMARY KEY (`id`),    KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_group` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `app_name` varchar(64) NOT NULL COMMENT &#x27;执行器AppName&#x27;,    `title` varchar(12) NOT NULL COMMENT &#x27;执行器名称&#x27;,    `address_type` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;执行器地址类型：0=自动注册、1=手动录入&#x27;,    `address_list` text COMMENT &#x27;执行器地址列表，多地址逗号分隔&#x27;,    `update_time` datetime DEFAULT NULL,    PRIMARY KEY (`id`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_user` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `username` varchar(50) NOT NULL COMMENT &#x27;账号&#x27;,    `password` varchar(50) NOT NULL COMMENT &#x27;密码&#x27;,    `role` tinyint(4) NOT NULL COMMENT &#x27;角色：0-普通用户、1-管理员&#x27;,    `permission` varchar(255) DEFAULT NULL COMMENT &#x27;权限：执行器ID列表，多个逗号分割&#x27;,    PRIMARY KEY (`id`),    UNIQUE KEY `i_username` (`username`) USING BTREE  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    CREATE TABLE `xxl_job_lock` (    `lock_name` varchar(50) NOT NULL COMMENT &#x27;锁名称&#x27;,    PRIMARY KEY (`lock_name`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;    INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, &#x27;xxl-job-executor-sample&#x27;, &#x27;示例执行器&#x27;, 0, NULL, &#x27;2018-11-03 22:21:31&#x27; );  INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, &#x27;测试任务1&#x27;, &#x27;2018-11-03 22:21:31&#x27;, &#x27;2018-11-03 22:21:31&#x27;, &#x27;XXL&#x27;, &#x27;&#x27;, &#x27;CRON&#x27;, &#x27;0 0 0 * * ? *&#x27;, &#x27;DO_NOTHING&#x27;, &#x27;FIRST&#x27;, &#x27;demoJobHandler&#x27;, &#x27;&#x27;, &#x27;SERIAL_EXECUTION&#x27;, 0, 0, &#x27;BEAN&#x27;, &#x27;&#x27;, &#x27;GLUE代码初始化&#x27;, &#x27;2018-11-03 22:21:31&#x27;, &#x27;&#x27;);  INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, &#x27;admin&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, 1, NULL);  INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( &#x27;schedule_lock&#x27;);    commit;

第三步部署调度中心

修改xxl-job-admin项目里面配置文件

主要修改数据库
### xxl-job, datasourcespring.datasource.url=jdbc:mysql://localhost:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


启动调度中心

通过路径访问：http://localhost:8080/xxl-job-admin

默认用户名和密码： admin&#x2F;123456


第四步部署执行器项目

导入依赖

修改配置文件，把执行器项目放在调度中心进行注册

创建配置类，获取任务调用过程中需要使用的参数
package com.xxl.job.executor.core.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123;    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)    private String adminAddresses;    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)    private String accessToken;    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)    private String appname;    @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)    private String address;    @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)    private String ip;    @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)    private int port;    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)    private String logPath;    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() &#123;        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    &#125;&#125;


启动执行器项目

注册到调度中心里面


第五步开发执行器项目job方法
@Componentpublic class SampleXxlJob &#123;    private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class);    /**     * 1、简单任务示例（Bean模式）     */    @XxlJob(&quot;demoJobHandler&quot;)    public void demoJobHandler() throws Exception &#123;        XxlJobHelper.log(&quot;XXL-JOB, Hello World.&quot;);        for (int i = 0; i &lt; 5; i++) &#123;            XxlJobHelper.log(&quot;beat at:&quot; + i);            TimeUnit.SECONDS.sleep(2);            System.out.println(Thread.currentThread().getName()+&quot;atguigu....&quot;);        &#125;        // default success    &#125;&#125;

第六步创建任务并启动任务
通过图形化界面进行操作新增任务![[Pasted image 20250531154302.png]]
]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>校园闪送项目笔记</title>
    <url>/2025/04/17/articles/Substitute%20driver/%E6%88%91%E6%9D%A5%E5%BC%80%EF%BC%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[搭建前端环境注册微信开发者账号打开微信公总平台，按照流程一步步注册：https://mp.weixin.qq.com/
然后去申请开通三个我们项目会用到的接口![[Pasted image 20250417092751.png]]
以及我们需要用到的插件![[Pasted image 20250417093027.png]]https://fuwu.weixin.qq.com/search?tab=3&amp;type=&amp;serviceType=3&amp;page=1&amp;kw=腾讯位置服务地图选点fuwu.weixin.qq.com&#x2F;search?tab&#x3D;3&amp;type&#x3D;&amp;serviceType&#x3D;3&amp;page&#x3D;1&amp;kw&#x3D;微信同声传译
安装 node.js 和微信开发者工具下载node.js：https://nodejs.org/en/download 版本选择16.20.0![[Pasted image 20250417093149.png]]
微信开发者工具也是点击下载一步步走就行

下载两遍，安装两个相同的，方便后期项目两个端口一起调试![[Pasted image 20250417091648.png]]![[Pasted image 20250417091741.png]]

在开发者工具中运行前端代码
点击左上角项目栏下的导入项目![[Pasted image 20250417093655.png]]

点击上方设置栏中的安全设置，打开里面的服务端口![[Pasted image 20250417093936.png]]


另一个也是一样
搭建后端环境安装软件环境安装rabbitmq
**第一步 拉取镜像

&#96;docker pull rabbitmq:3.9.0-management

**第二步 使用容器启动服务

&#96;docker run -d –name&#x3D;rabbitmq –restart&#x3D;always -p 5672:5672 -p 15672:15672 rabbitmq:3.9.0-management  

**第三步 安装延迟队列插件

1、首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：https://www.rabbitmq.com/community-plugins.html
2、上传下载延迟队列插件到Linux操作系统中，切换到插件所在目录，
执行 docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins 命令，将刚插件拷贝到容器内plugins目录下
3、执行 docker exec -it rabbitmq /bin/bash 命令进入到容器内部，并 cd plugins 进入plugins目录
执行 ls -l|grep delay  命令查看插件是否copy成功在容器内plugins目录下，执行 rabbitmq-plugins enable rabbitmq_delayed_message_exchange  命令启用插件
4、exit命令退出RabbitMQ容器内部，然后执行 docker restart rabbitmq 命令重启RabbitMQ容器

**第四步 远程访问设置凭证# 进入容器docker exec -it rabbitmq bash# 创建新用户（用户名：admin，密码：Abc123）rabbitmqctl add_user admin Abc123# 赋予管理员权限rabbitmqctl set_user_tags admin administrator# 赋予所有权限（虚拟主机为 /）rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;

安装redis
**第一步 拉取镜像

docker pull redis

**第二步 创建Redis配置文件

## 创建目录mkdir -p /home/redis/conf## 创建文件touch /home/redis/conf/redis.conf


**第三步 创建redis并启动

docker run -d \  --name redis \  -p 6379:6379 \  --restart unless-stopped \  -v /home/redis/data:/data \  -v /home/redis/conf/redis.conf:/etc/redis/redis.conf \  redis:latest \  redis-server /etc/redis/redis.conf


**第四步 进入redis容器

### 直接通过Docker Redis 命令进入Redis控制台docker exec -it redis redis-cli### 进入 Redis 控制台redis-cli### 添加一个变量为 key 为 name , value 为 bella 的内容&gt; set name bella### 查看 key 为 name 的 value 值&gt; get name
安装minio docker run \--name minio_one \-p 9000:9000  \-p 9001:9001  \-d \-e &quot;MINIO_ROOT_USER=admin&quot; \-e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \-v /root/minio-data:/data \-v /root/minio-config:/root/.minio \minio/minio server  /data --console-address &quot;:9001&quot;


docker run：这是Docker命令行工具用来运行一个新容器的命令。

–name minio_one：这个参数为容器指定了一个名称，这里名称被设置为minio_one。使用名称可以更方便地管理容器。

p 9000:9000：这个参数将容器内的9000端口映射到宿主机的9000端口。MinIO服务默认使用9000端口提供API服务。

-p 9001:9001：这个参数将容器内的9001端口映射到宿主机的9001端口。这是MinIO的控制台（Console）端口，用于访问MinIO的图形用户界面。

-d：这个参数告诉Docker以“detached”模式运行容器，即在后台运行。

-e “MINIO_ROOT_USER&#x3D;admin”：设置环境变量MINIO_ROOT_USER，这是访问MinIO服务的用户名称，这里设置为admin。

-e “MINIO_ROOT_PASSWORD&#x3D;admin123456”：设置环境变量MINIO_ROOT_PASSWORD，这是访问MinIO服务的用户密码，这里设置为admin123456。

-v &#x2F;home&#x2F;data:&#x2F;data：这个参数将宿主机的目录&#x2F;home&#x2F;data:&#x2F;data挂载到容器的&#x2F;data目录。MinIO会将所有数据存储在这个目录。

-v  &#x2F;root&#x2F;config:&#x2F;root&#x2F;.minio：这个参数将宿主机的目录&#x2F;root&#x2F;minio-config挂载到容器的&#x2F;root&#x2F;.minio目录。这个目录用于存储MinIO的配置文件和数据。

minio&#x2F;minio：这是要运行的Docker镜像的名称，这里使用的是官方发布的MinIO镜像。

server &#x2F;data：这是传递给MinIO程序的命令行参数，告诉MinIO以服务器模式运行，并且使用&#x2F;data目录作为其数据存储位置。

–console-address “:9001”：这个参数指定MinIO控制台服务的监听地址和端口。在这个例子中，它设置为监听所有接口上的9001端口。


注意:文件上传时，需要调整-下Linux 服务器的时间与Windows 时间一致!
第一步:安装ntp服务yum -y install ntp第二步:开启开机启动服务systemctl enable ntpd第三步:启动服务systemctl start ntpd第四步:更改时区timedatectl set-timezone Asia/Shanghai第五步:启用ntp同步timedatectl set-ntp yes第六步:同步时间ntpq -p

如果启动不了，那么就重构主义，推了重建
# 强制删除旧容器（保留数据卷）docker rm -f minio_one# 重新运行 MinIO 容器（使用正确的镜像名称 minio/minio）docker run \--name minio_one \-p 9000:9000 \-p 9001:9001 \-d \-e &quot;MINIO_ROOT_USER=admin&quot; \-e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \-v /root/minio-data:/data \-v /root/minio-config:/root/.minio \minio/minio server /data --console-address &quot;:9001&quot;

nacos
开启nacos

bash /root/nacos/bin/startup.sh -m standalone

关闭nacos

bash /root/nacos/bin/shutdown.sh
导入数据库内容
只需要在 DataGrip 连接上服务器或者本地的数据库

然后再把所需要的数据库和表创建好，数据导入进去


逻辑删除
物理删除是与之前一样，直接把数据删除，但这样不方便我们恢复数据，所以 mybatis-plus 有一种删除叫逻辑删除

我们可以在数据表加一列属性表示为逻辑删除，值为0表示没有删除，值为1表示删除，方便我们恢复数据


官方文档：https://baomidou.com/guides/logic-delete/
第一种方法：
mybatis-plus:  global-config:    db-config:      logic-delete-field: isDelete #默认deleted      logic-delete-value: 1      logic-not-delete-value: 0      id-type: auto

第二种方法：添加@TableLogic注解
@Datapublic class User&#123;。。。    /**     * 1删除0正常     */    @TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)    private Integer isDelete;。。。&#125;

添加完后再使用mp已经封装好的语句都会加上 where deleted = 0
分页查询
实现分页查询前需要配置分页插件

分页插件：
@Configuration@MapperScan(&quot;scan.your.mapper.package&quot;)public class MybatisPlusConfig &#123;    /**     * 添加分页插件     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); // 如果配置多个插件, 切记分页最后添加        // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType        return interceptor;    &#125;&#125;

导入配置文件
两种导入模式

第一种：像之前一样一条一条创建
第二种：把文件打成压缩包，但是压缩包名称要与组的名字相同（默认是 DEFAULT_GROUP）![[Pasted image 20250418214153.png]]
客户端登录微信小程序登录流程
官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html

![[Pasted image 20250419174655.png]]
微信小程序登录接口
这是接下来需要实现的步骤

项目工程结构：![[Pasted image 20250419180421.png]]
准备工作
**导入微信工具包相关依赖

在 service-customer 中引入依赖
&lt;dependency&gt;      &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt;      &lt;artifactId&gt;weixin-java-miniapp&lt;/artifactId&gt;  &lt;/dependency&gt;


**修改 nacos 配置中心文件

因为查看官方文档可以看到我们后端请求腾讯接口需要三个值：小程序id、密钥和临时票据code，所以我们需要去 nacos 修改配置文件，把密钥和小程序id先作配置

注意查看项目配置文件 bootstrap.properties 里 nacos 的 IP 与端口是否正确



创建配置类来读取配置文件信息


在 service-customer 创建包config，创建类来读取配置文件中的内容
@Component@Data//从配置文件中读取 wx.miniapp 前缀下的字段@ConfigurationProperties(prefix = &quot;wx.miniapp&quot;)public class WxConfigProperties &#123;    private String appId;    private String secret;&#125;

创建微信工具包对象
@Componentpublic class WxConfigOperator &#123;    @Autowired    private WxConfigProperties wxConfigProperties;    @Bean    public WxMaService wxMaService() &#123;        WxMaDefaultConfigImpl config = new WxMaDefaultConfigImpl();        config.setAppid(wxConfigProperties.getAppId());        config.setSecret(wxConfigProperties.getSecret());        WxMaService service = new WxMaServiceImpl();        service.setWxMaConfig(config);        return service;    &#125;&#125;


功能实现-基础功能
在 service-customer 的 CustomerInfoController
@Slf4j@RestController@RequestMapping(&quot;/customer/info&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CustomerInfoController &#123;	@Autowired	private CustomerInfoService customerInfoService;	// 微信小程序登录接口	@Operation(summary = &quot;小程序授权登录&quot;)	@GetMapping(&quot;login/&#123;code&#125;&quot;)	public Result&lt;Long&gt; longin(@PathVariable String code) &#123;	    return Result.ok(customerInfoService.login(code));	&#125;&#125;

service实现接口
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CustomerInfoServiceImpl extends ServiceImpl&lt;CustomerInfoMapper, CustomerInfo&gt; implements CustomerInfoService &#123;    @Autowired    private WxMaService wxMaService;    @Autowired    private CustomerInfoMapper customerInfoMapper;    @Autowired    private CustomerLoginLogMapper customerLoginLogMapper;    //微信小程序登录    @Override    public Long login(String code) &#123;        String openid = null;        // 获取code值，通过微信工具包对象，获取唯一标识openId        try &#123;            WxMaJscode2SessionResult sessionInfo = wxMaService.getUserService().getSessionInfo(code);             openid = sessionInfo.getOpenid();        &#125; catch (WxErrorException e) &#123;            throw new RuntimeException(e);        &#125;        // 用openId查询数据库是否存在        // 如果openId不存在返回null，如果存在返回记录        LambdaQueryWrapper&lt;CustomerInfo&gt; wrapper = new LambdaQueryWrapper();        wrapper.eq(CustomerInfo::getWxOpenId, openid);        CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);        // 如果不存在，也就是第一次登陆，添加信息到用户表        if (customerInfo == null) &#123;            customerInfo = new CustomerInfo();            //用当前时间戳作为昵称            customerInfo.setNickname(String.valueOf(System.currentTimeMillis()));            //设置默认头像            customerInfo.setAvatarUrl(&quot;https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg&quot;);            //把openId存入用户表            customerInfo.setWxOpenId(openid);            customerInfoMapper.insert(customerInfo);        &#125;        // 记录登录日志        CustomerLoginLog loginLog = new CustomerLoginLog();        loginLog.setCustomerId(customerInfo.getId());        loginLog.setMsg(&quot;小程序登录&quot;);        customerLoginLogMapper.insert(loginLog);        // 最后返回用户id        return customerInfo.getId();    &#125;&#125;

功能实现-远程调用
service-customer-client 定义接口
@FeignClient(value = &quot;service-customer&quot;)public interface CustomerInfoFeignClient &#123;    @GetMapping(&quot;/customer/info/login/&#123;code&#125;&quot;)    public Result&lt;Long&gt; longin(@PathVariable String code);    &#125;

在 web-customer 进行远程调用controller：
@Slf4j@Tag(name = &quot;客户API接口管理&quot;)@RestController@RequestMapping(&quot;/customer&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CustomerController &#123;    @Autowired    private CustomerService customerInfoService;    @Operation(summary = &quot;小程序授权登录&quot;)    @GetMapping(&quot;/login/&#123;code&#125;&quot;)    public Result&lt;String&gt; wxLogin(@PathVariable String code) &#123;        return Result.ok(customerInfoService.login(code));    &#125;&#125;

service：
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CustomerServiceImpl implements CustomerService &#123;    // 注入远程调用    @Autowired    private CustomerInfoFeignClient client;    @Autowired    private RedisTemplate redisTemplate;    @Override    public String login(String code) &#123;        // 拿着code进行远程调用，返回用户id        Result&lt;Long&gt; longin = client.longin(code);        // 如果返回失败了。返回错误信息        Integer code1 = longin.getCode();        if(code1 != 200)&#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;        // 获取远程调用的用户id        Long customerId = longin.getData();        // 判断返回用户id是否为空，为空则返回错误提示        if(customerId == null)&#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;        // 把用户id放到Redis中，设置过期时间        String token = UUID.randomUUID().toString();        // 返回token        redisTemplate.opsForValue().set(RedisConstant.USER_LOGIN_KEY_PREFIX+token,                customerId.toString(),                RedisConstant.USER_LOGIN_KEY_TIMEOUT,                TimeUnit.SECONDS);        return token;    &#125;&#125;

功能实现-测试
运行乘客端微信小程序（微信开发者工具）

启动后端服务

启动网关

启动 service-customer 服务

启动 web-customer 服务




把用到的配置文件都检查一遍，重点看看IP地址和开放端口，以及MySQL的远程用户(就是因为这个问题，后面用映射成localhost解决了)
获取客户端登录信息service-customer 接口
Controller
@Operation(summary = &quot;获取客户端登录信息&quot;)	@GetMapping(&quot;/getCustomerLoginInfo/&#123;customerId&#125;&quot;)	public Result&lt;CustomerLoginVo&gt; getCustomerLoginInfo(@PathVariable Long customerId) &#123;		CustomerLoginVo customerLoginVo = customerInfoService.getCustomerInfoService(customerId);		return Result.ok(customerLoginVo);	&#125;

service
@Override    public CustomerLoginVo getCustomerInfoService(Long customerId) &#123;        // 根据用户id查询用户信息//        LambdaQueryWrapper&lt;CustomerInfo&gt; wrapper = new LambdaQueryWrapper();//        wrapper.eq(CustomerInfo::getId, customerId);//        CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);        CustomerInfo info = customerInfoMapper.selectById(customerId);        if (info == null) &#123;            throw new RuntimeException(&quot;用户不存在&quot;);        &#125;        // 封装到customerLoginVo对象        CustomerLoginVo customerLoginVo = new CustomerLoginVo();        // springboot的工具类，可以把第一个对象的属性复制到第二个对象的同名属性中        BeanUtils.copyProperties(info, customerLoginVo);        /*        * 还有一个属性需要手动拷贝，判断是否存在手机号        * StringUtils.hasText(info.getPhone())判断字符串是否有值        */        customerLoginVo.setIsBindPhone(StringUtils.hasText(info.getPhone()));        // 返回对象        return customerLoginVo;    &#125;

web-customer 接口
controller
@Operation(summary = &quot;获取客户登录信息&quot;)@GetMapping(&quot;/getCustomerLoginInfo&quot;)public Result&lt;CustomerLoginVo&gt; getCustomerLoginInfo(@RequestHeader(value = &quot;token&quot;) String token) &#123;	CustomerLoginVo customerLoginVo = customerInfoService.getCustomerLoginInfo(token);	// 返回用户对象	return Result.ok(customerLoginVo);&#125;

service

这里的token要和前面设置的一样
redisTemplate.opsForValue().get() 就是把redis当成一个map容器，通过键值对的方式来存储或查询@Overridepublic CustomerLoginVo getCustomerLoginInfo(String token) &#123;	/*	 * 从请求头中获取token字符串	 * 根据token查询redis	 */	String customerId = (String) redisTemplate.opsForValue().get(RedisConstant.USER_LOGIN_KEY_PREFIX+token);	// 根据用户id进行远程调用，获取用户信息	if(!StringUtils.hasText(customerId))&#123;		throw new GuiguException(ResultCodeEnum.DATA_ERROR);	&#125;	Result&lt;CustomerLoginVo&gt; customerLoginInfo = client.getCustomerLoginInfo(Long.parseLong(customerId));	Integer code = customerLoginInfo.getCode();	if(code != 200)&#123;		throw new GuiguException(ResultCodeEnum.DATA_ERROR);	&#125;	CustomerLoginVo data = customerLoginInfo.getData();	if(data == null)&#123;		throw new GuiguException(ResultCodeEnum.DATA_ERROR);	&#125;	return data;&#125;



登录校验这里选用 AOP面向切面加自定义注解完成，有想过用拦截器来做，但是路径太多，懒得配置了（高情商，更希望学习底层知识）
创建自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginDetection &#123;    &#125;

创建切面类@Component@Aspectpublic class LoginAspect &#123;    @Autowired    private RedisTemplate redisTemplate;    // 环绕通知，运行前后都触发    // 切入点表达式，用来指定那些规则的方法进行增强    @Around(&quot;execution(* com.atguigu.daijia.*.controller.*.*(..)) &amp;&amp; @annotation(loginDetection)&quot;)    public Object login(ProceedingJoinPoint proceedingJoinPoint,                        LoginDetection loginDetection) throws Throwable &#123;        // 获取request对象，并且从请求头获取token        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();        ServletRequestAttributes sra = (ServletRequestAttributes) requestAttributes;        String token = sra.getRequest().getHeader(&quot;token&quot;);        // 判断token是否有效，如果为空或过期，返回登录提示        if(!StringUtils.hasText(token))&#123;            throw new GuiguException(ResultCodeEnum.LOGIN_AUTH);        &#125;        // token不为空，查询redis、对应用户id，把用户id放到ThreadLocal里面        String customerId = (String) redisTemplate.opsForValue().get(RedisConstant.USER_LOGIN_KEY_PREFIX + token);                if(StringUtils.hasText(customerId))&#123;            AuthContextHolder.setUserId(Long.parseLong(customerId));        &#125;                // 执行目标方法        return proceedingJoinPoint.proceed();    &#125;&#125;

把之前的getCustomerLoginInfo用上注解在web-customer中的service里 getCustomerLoginInfo 做修改，用上我们刚刚写的注解
@Operation(summary = &quot;获取客户登录信息&quot;)    @LoginDetection    @GetMapping(&quot;/getCustomerLoginInfo&quot;)    public Result&lt;CustomerLoginVo&gt; getCustomerLoginInfo() &#123;        // 从ThreadLocal获取用户id        Long userId = AuthContextHolder.getUserId();        // 调用service        CustomerLoginVo customerLoginVo = customerInfoService.getCustomerInfo(userId);        // 返回用户对象        return Result.ok(customerLoginVo);    &#125;

service
@Overridepublic CustomerLoginVo getCustomerInfo(Long customerId) &#123;	Result&lt;CustomerLoginVo&gt; customerLoginInfo = client.getCustomerLoginInfo(customerId);	Integer code = customerLoginInfo.getCode();	if(code != 200)&#123;		throw new GuiguException(ResultCodeEnum.DATA_ERROR);	&#125;	CustomerLoginVo data = customerLoginInfo.getData();	if(data == null)&#123;		throw new GuiguException(ResultCodeEnum.DATA_ERROR);	&#125;	return data;&#125;

获取乘客手机号可恶，写完的时候发现个人版的微信开发无法使用这个，白写，最后不做判断直接改成true了
controller@Operation(summary = &quot;更新客户微信手机号码&quot;)@PostMapping(&quot;/updateWxPhoneNumber&quot;)public Result&lt;Boolean&gt; updateWxPhoneNumber(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) &#123;	return Result.ok(customerInfoService.updateWxPhoneNumber(updateWxPhoneForm));&#125;

service// 更新客户微信手机号码@Overridepublic Boolean updateWxPhoneNumber(UpdateWxPhoneForm updateWxPhoneForm) &#123;	// 根据code查询用户信息	try &#123;		WxMaPhoneNumberInfo phoneNoInfo = wxMaService.getUserService().getPhoneNoInfo(updateWxPhoneForm.getCode());		// 更新用户信息		Long customerId = updateWxPhoneForm.getCustomerId();		CustomerInfo customerInfo = customerInfoMapper.selectById(customerId);		customerInfo.setPhone(phoneNoInfo.getPhoneNumber());		customerInfoMapper.updateById(customerInfo);		return true;	&#125; catch (WxErrorException e) &#123;		throw new RuntimeException(e);	&#125;&#125;

web-customer
controller企业版@Operation(summary = &quot;更新用户微信手机号&quot;)@LoginDetection@PostMapping(&quot;/updateWxPhone&quot;)public Result updateWxPhone(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) &#123;	updateWxPhoneForm.setCustomerId(AuthContextHolder.getUserId());	return Result.ok(customerInfoService.updateWxPhoneNumber(updateWxPhoneForm));&#125;

个人版：
@Operation(summary = &quot;更新用户微信手机号&quot;)@LoginDetection@PostMapping(&quot;/updateWxPhone&quot;)public Result updateWxPhone(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) &#123;	updateWxPhoneForm.setCustomerId(AuthContextHolder.getUserId());	return Result.ok(true);&#125;


service@Overridepublic boolean updateWxPhoneNumber(UpdateWxPhoneForm updateWxPhoneForm) &#123;	Result&lt;Boolean&gt; booleanResult = client.updateWxPhoneNumber(updateWxPhoneForm);	return true;&#125;

司机端登录司机开启接单的条件：1、登录
2、认证通过
3、建立了腾讯云人员库人员
4、当日验证了人脸识别
准备工作与流程
准备共奏

因为司机端要完成认证模块，比如身份证，驾驶证之类的，所以我们需要用到腾讯云的对象存储COS还有腾讯云的OCR来识别身份证和驾驶证

流程如下
司机端登录功能
获取用户信息
腾讯云对象存储COS
上传信息接口
腾讯云OCR，识别身份证与驾驶证
人脸识别




修改项目配置文件和Nacos里面配置文件内容

创建类，读取配置文件内容，微信小程序id和秘钥，这个跟客户端的一样，直接复制过来
@Component@Data@ConfigurationProperties(prefix = &quot;wx.miniapp&quot;)public class WxConfigProperties &#123;    private String appId;    private String secret;&#125;

创建类，初始化微信工具包相关对象
@Componentpublic class WxConfigOperator &#123;    @Autowired    private WxConfigProperties wxConfigProperties;    @Bean    public WxMaService wxMaService() &#123;        //微信小程序id和秘钥        WxMaDefaultConfigImpl wxMaConfig = new WxMaDefaultConfigImpl();        wxMaConfig.setAppid(wxConfigProperties.getAppId());        wxMaConfig.setSecret(wxConfigProperties.getSecret());        WxMaService service = new WxMaServiceImpl();        service.setWxMaConfig(wxMaConfig);        return service;    &#125;&#125;

司机端登录功能这个步骤跟之前客户端差不多

service：
就是获取code，然后通过code加密钥和小程序id去获取用户的唯一表示openid
判断这个用户是不是第一次登录
是的话初始化用户
返回id


web-service:
获取code，调用service
远程调用获取数据
生成token
放入redis
返回token



service-driveDriverInfoController
@Slf4j@Tag(name = &quot;司机API接口管理&quot;)@RestController@RequestMapping(value=&quot;/driver/info&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class DriverInfoController &#123;    @Autowired    private DriverInfoService driverInfoService;    @Operation(summary = &quot;小程序授权登录&quot;)    @GetMapping(&quot;/login/&#123;code&#125;&quot;)    public Result&lt;Long&gt; login(@PathVariable(&quot;code&quot;) String code) &#123;        return Result.ok(driverInfoService.login(code));    &#125;&#125;

DriverInfoServiceImpl
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class DriverInfoServiceImpl extends ServiceImpl&lt;DriverInfoMapper, DriverInfo&gt; implements DriverInfoService &#123;    @Autowired    private WxMaService wxMaService;    @Autowired    private DriverInfoMapper driverInfoMapper;    @Autowired    private DriverSetMapper driverSetMapper;    @Autowired    private DriverAccountMapper driverAccountMapper;    @Autowired    private DriverLoginLogMapper driverLoginLogMapper;    // 小程序授权登录    @Override    public Long login(String code) &#123;        try &#123;            // 通过code+密钥+小程序id获取用户唯一标识openid            WxMaJscode2SessionResult sessionInfo = wxMaService.getUserService().getSessionInfo(code);            String openid = sessionInfo.getOpenid();            // 根据openid查询用户信息            LambdaQueryWrapper&lt;DriverInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();            wrapper.eq(DriverInfo::getWxOpenId, openid);            DriverInfo driverInfo = driverInfoMapper.selectOne(wrapper);            if(driverInfo == null)&#123;                // 添加司机基本信息                driverInfo = new DriverInfo();                driverInfo.setNickname(String.valueOf(System.currentTimeMillis()));                driverInfo.setAvatarUrl(&quot;https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg&quot;);                driverInfo.setWxOpenId(openid);                driverInfoMapper.insert(driverInfo);                // 初始化司机设置                DriverSet driverSet = new DriverSet();                driverSet.setDriverId(driverInfo.getId());                driverSet.setOrderDistance(new BigDecimal(0));//0：无限制                driverSet.setAcceptDistance(new BigDecimal(SystemConstant.ACCEPT_DISTANCE));//默认接单范围：5公里                driverSet.setIsAutoAccept(0);//0：否 1：是                driverSetMapper.insert(driverSet);                // 初始化司机账户信息                DriverAccount driverAccount = new DriverAccount();                driverAccount.setDriverId(driverInfo.getId());                driverAccountMapper.insert(driverAccount);            &#125;            // 更新登录日志            DriverLoginLog loginLog = new DriverLoginLog();            loginLog.setDriverId(driverInfo.getId());            loginLog.setMsg(&quot;小程序登录&quot;);            driverLoginLogMapper.insert(loginLog);            // 返回用户id            return driverInfo.getId();        &#125; catch (WxErrorException e) &#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;    &#125;&#125;

service-drive-client@FeignClient(value = &quot;service-driver&quot;)public interface DriverInfoFeignClient &#123;    // 小程序授权登录    @GetMapping(&quot;/driver/info/login/&#123;code&#125;&quot;)    public Result&lt;Long&gt; login(@PathVariable(&quot;code&quot;) String code);&#125;

web-drivecontroller
@Slf4j@Tag(name = &quot;司机API接口管理&quot;)@RestController@RequestMapping(value=&quot;/driver&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class DriverController &#123;    @Autowired    private DriverService driverService;    @Operation(summary = &quot;小程序授权登录&quot;)    @GetMapping(&quot;/login/&#123;code&#125;&quot;)    public Result&lt;String&gt; login(@PathVariable(&quot;code&quot;) String code) &#123;        return Result.ok(driverService.login(code));    &#125;&#125;

service
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class DriverServiceImpl implements DriverService &#123;    @Autowired    private DriverInfoFeignClient driverInfoFeignClient;    @Autowired    private RedisTemplate redisTemplate;    // 小程序授权登录    @Override    public String login(String code) &#123;        Result&lt;Long&gt; result = driverInfoFeignClient.login(code);        if(result.getCode() != 200)&#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;        Long data = result.getData();        if(data == null)&#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;        String token = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);        redisTemplate.opsForValue().set(RedisConstant.USER_LOGIN_KEY_PREFIX + token,                data.toString(),                RedisConstant.USER_LOGIN_KEY_TIMEOUT,                TimeUnit.SECONDS);        return token;    &#125;&#125;

获取登录司机信息service-drivercontroller
@Operation(summary = &quot;获取司机登录信息&quot;)  @GetMapping(&quot;/getDriverLoginInfo/&#123;driverId&#125;&quot;)  public Result&lt;DriverLoginVo&gt; getDriverInfo(@PathVariable(&quot;driverId&quot;) long driverId) &#123;      DriverLoginVo driverLoginVo = driverInfoService.getDriverInfo(driverId);      return Result.ok(driverLoginVo);  &#125;

service
// 获取司机登录信息@Overridepublic DriverLoginVo getDriverInfo(long driverId) &#123;	// 通过id查询司机信息	DriverInfo driverInfo = driverInfoMapper.selectById(driverId);		// 赋予到vo对象中	DriverLoginVo driverLoginVo = new DriverLoginVo();	BeanUtils.copyProperties(driverInfo, driverLoginVo);	// 查询是否需要建档人脸识别	String faceModelId = driverInfo.getFaceModelId();	boolean isArchiveFace = StringUtils.hasText(faceModelId);	driverLoginVo.setIsArchiveFace(isArchiveFace);	return driverLoginVo;&#125;

 service-driver-client
@FeignClient(value = &quot;service-driver&quot;)public interface DriverInfoFeignClient &#123;    // 小程序授权登录    @GetMapping(&quot;/driver/info/login/&#123;code&#125;&quot;)    public Result&lt;Long&gt; login(@PathVariable(&quot;code&quot;) String code);    // 获取登录司机信息    @GetMapping(&quot;/driver/info/getDriverLoginInfo/&#123;driverId&#125;&quot;)    public Result&lt;DriverLoginVo&gt; getDriverInfo(@PathVariable(&quot;driverId&quot;) long driverId);&#125;

web-drivercontroller
@Operation(summary = &quot;获取登录司机信息&quot;)@LoginDetection@GetMapping(&quot;/getDriverLoginInfo&quot;)public Result&lt;DriverLoginVo&gt; getDriverLoginInfo() &#123;	return Result.ok(driverService.getDriverLoginVo());&#125;

service
@Overridepublic DriverLoginVo getDriverLoginVo() &#123;	Long driverId = AuthContextHolder.getUserId();	Result&lt;DriverLoginVo&gt; driverInfo = driverInfoFeignClient.getDriverInfo(driverId);	return driverInfo.getData();&#125;

测试一下前面的代码
打开微信开发者工具
改好相关配置文件
nacos
启动后端服务
网关服务service-gateway
司机端基础服务service-driver
对外访问服务web-driver



可恶，在这里前面web-driver里面controller的路径写错了，一直访问不上，还有nacos里面的配置忘记修改成映射后的端口
开通腾讯云对象存储COS准备工作
注册并实名腾讯云
找到对象存储
创建储存桶
创建并保存密钥和id

思路在 web-driver：

获取文件以及存放路径
远程调用实现文件上传
返回 vo 对象

在 service-driver：

导入依赖
获取上传文件及路径
修改配置文件
基于腾讯云官方文档调用实现上传
返回 vo 对象

注意点：因为保密隐私，我们这里的存储桶肯定是私密的，但是我们又要让用户能看到上传后的结果，因此我们需要创建一个临时地址，让客户看到存储内容
web-service
controller
@Tag(name = &quot;上传管理接口&quot;)@RestController@RequestMapping(&quot;file&quot;)public class FileController &#123;    @Autowired    private CosService cosService;    // 文件上传接口    @Operation(summary = &quot;上传&quot;)    @LoginDetection    @PostMapping(&quot;/upload&quot;)    public Result&lt;CosUploadVo&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file,                                      @RequestParam(value = &quot;path&quot;, defaultValue = &quot;auth&quot;) String path) &#123;        CosUploadVo cosUploadVo = cosService.uploadFile(file, path);        return Result.ok(cosUploadVo);    &#125;&#125;

service
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CosServiceImpl implements CosService &#123;    @Autowired    private CosFeignClient cosFeignClient;    // 文件上传接口    @Override    public CosUploadVo uploadFile(MultipartFile file, String path) &#123;        // 远程调用获取vo        Result&lt;CosUploadVo&gt; result =  cosFeignClient.upload(file, path);        CosUploadVo cosUploadVo = result.getData();        return cosUploadVo;    &#125;&#125;

service-driver-client@FeignClient(value = &quot;service-driver&quot;)public interface CosFeignClient &#123;    /*    * 文件上传    * MediaType 表示上传类型    */    @PostMapping(value = &quot;/cos/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)    public Result&lt;CosUploadVo&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file,                                      @RequestParam(value = &quot;path&quot;) String path);&#125;

service-driver
导入依赖
&lt;dependency&gt;     &lt;groupId&gt;com.qcloud&lt;/groupId&gt;     &lt;artifactId&gt;cos_api&lt;/artifactId&gt;     &lt;version&gt;5.6.227&lt;/version&gt;&lt;/dependency&gt;

修改配置文件

创建类读取配置文件内容
@Data@Component@ConfigurationProperties(prefix = &quot;tencent.cloud&quot;)public class TencentCloudProperties &#123;    private String secretId;    private String secretKey;    private String region;    private String bucketPrivate;&#125;

controller
@Slf4j@Tag(name = &quot;腾讯云cos上传接口管理&quot;)@RestController@RequestMapping(value=&quot;/cos&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CosController &#123;    @Autowired    private CosService cosService;    @Operation(summary = &quot;上传&quot;)    @PostMapping(&quot;/upload&quot;)    public Result&lt;CosUploadVo&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file,                                      @RequestParam(&quot;path&quot;) String path) &#123;        CosUploadVo cosUploadVo = cosService.upload(file, path);        return Result.ok(cosUploadVo);    &#125;&#125;

service
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class CosServiceImpl implements CosService &#123;    @Autowired    private TencentCloudProperties tencentCloudProperties;    // 文件上传   @Override    public CosUploadVo upload(MultipartFile file, String path) &#123;        // 获取cos客户端        COSClient cosClient = getCosClient();        // 文件上传        // 设置文件元数据信息        ObjectMetadata metadata = new ObjectMetadata();        metadata.setContentLength(file.getSize());        metadata.setContentEncoding(&quot;UTF-8&quot;);        metadata.setContentType(file.getContentType());        // 向储存桶保存文件        String fileType = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); //文件后缀名        String uploadPath = &quot;/driver/&quot; + path + &quot;/&quot; + UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + fileType;        // 01.jpg        // /driver/auth/0o98754.jpg        PutObjectRequest putObjectRequest = null;        try &#123;            //1 bucket名称            //2            putObjectRequest = new PutObjectRequest(tencentCloudProperties.getBucketPrivate(),                    uploadPath,                    file.getInputStream(),                    metadata);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;        putObjectRequest.setStorageClass(StorageClass.Standard);        PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); //上传文件        cosClient.shutdown();        //返回vo对象        CosUploadVo cosUploadVo = new CosUploadVo();        cosUploadVo.setUrl(uploadPath);        // 图片临时访问回显url        cosUploadVo.setShowUrl(this.getImagerUrl(uploadPath));        return cosUploadVo;    &#125;

提取CosClient
private COSClient getCosClient() &#123;	// 1 初始化用户身份信息（secretId, secretKey）。	String secretId = tencentCloudProperties.getSecretId();	String secretKey = tencentCloudProperties.getSecretKey();	COSCredentials cred = new BasicCOSCredentials(secretId, secretKey);	// 2 设置 bucket 的地域	Region region = new Region(tencentCloudProperties.getRegion());	ClientConfig clientConfig = new ClientConfig(region);	// 这里建议设置使用 https 协议	clientConfig.setHttpProtocol(HttpProtocol.https);	// 3 生成 cos 客户端。	COSClient cosClient = new COSClient(cred, clientConfig);	return cosClient;&#125;

获取临时签名url
@Overridepublic String getImagerUrl(String path) &#123;	if(!StringUtils.hasText(path))&#123;		return &quot;&quot;;	&#125;	COSClient cosClient = getCosClient();	GeneratePresignedUrlRequest request =			new GeneratePresignedUrlRequest(tencentCloudProperties.getBucketPrivate(),					path,					HttpMethodName.GET);	// 设置临时URL有效期	DateTime dateTime = new DateTime().plusMinutes(15);	request.setExpiration(dateTime.toDate());	// 调用方法获取	URL url = cosClient.generatePresignedUrl(request);	cosClient.shutdown();	return url.toString();&#125;

这一大段看着很复杂，其实大部分都是腾讯云官方文档里面的内容，我们只需要修改一下参数即可
腾讯云身份证与驾驶证识别接口思路司机注册成功后，应该需要去实名认证，这里可以用到腾讯云的身份识别和云存储功能，身份证和驾驶证上传的步骤都差不多，这里就写在一起了
那我们现在计划很明确了
web-driver：

获取上传文件
远程调用获取认证信息
返回认证信息

service-driver：

上传认证图片
调用腾讯云相关接口完成认证
返回认证信息

service-driver
controller：
@Slf4j@Tag(name = &quot;腾讯云识别接口管理&quot;)@RestController@RequestMapping(value=&quot;/ocr&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OcrController &#123;    @Autowired    private OcrService ocrService;    @Operation(summary = &quot;身份证识别&quot;)    @PostMapping(&quot;/idCardOcr&quot;)    public Result&lt;IdCardOcrVo&gt; idCardOcr(@RequestPart(&quot;file&quot;) MultipartFile file) &#123;        IdCardOcrVo idCardOcrVo = ocrService.idCardOcr(file);        return Result.ok(idCardOcrVo);    &#125;	@Operation(summary = &quot;驾驶证识别&quot;)  	@PostMapping(&quot;/driverLicenseOcr&quot;)  	public Result&lt;DriverLicenseOcrVo&gt; driverLicenseOcr(@RequestPart(&quot;file&quot;) MultipartFile file) &#123;  	    DriverLicenseOcrVo driverLicenseOcrVo = ocrService.driverLicenseOcr(file);  	    return Result.ok(driverLicenseOcrVo);  	&#125;&#125;

service：导入依赖：
&lt;dependency&gt;      &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt;      &lt;artifactId&gt;tencentcloud-sdk-java&lt;/artifactId&gt;      &lt;version&gt;$&#123;tencentcloud.version&#125;&lt;/version&gt;  &lt;/dependency&gt;

看着代码很多，其实全都是从腾讯云官网拉过来修改配置的
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OcrServiceImpl implements OcrService &#123;    @Autowired    private TencentCloudProperties tencentCloudProperties;    @Autowired    private CosService cosService;    // 身份证识别    @Override    public IdCardOcrVo idCardOcr(MultipartFile file) &#123;        try&#123;            // file转换成base64            byte[] base64 = Base64.encodeBase64(file.getBytes());            String fileBase64 = new String(base64);            // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密            Credential cred = new Credential(tencentCloudProperties.getSecretId(),                    tencentCloudProperties.getSecretKey());            // 实例化一个http选项，可选的，没有特殊需求可以跳过            HttpProfile httpProfile = new HttpProfile();            httpProfile.setEndpoint(&quot;ocr.tencentcloudapi.com&quot;);            // 实例化一个client选项，可选的，没有特殊需求可以跳过            ClientProfile clientProfile = new ClientProfile();            clientProfile.setHttpProfile(httpProfile);            // 实例化要请求产品的client对象,clientProfile是可选的            OcrClient client = new OcrClient(cred,tencentCloudProperties.getRegion(), clientProfile);            // 实例化一个请求对象,每个接口都会对应一个request对象            IDCardOCRRequest req = new IDCardOCRRequest();            //设置文件            req.setImageBase64(fileBase64);            // 返回的resp是一个IDCardOCRResponse的实例，与请求对象对应            IDCardOCRResponse resp = client.IDCardOCR(req);            //转换为IdCardOcrVo对象            IdCardOcrVo idCardOcrVo = new IdCardOcrVo();            if (StringUtils.hasText(resp.getName())) &#123;                //身份证正面                idCardOcrVo.setName(resp.getName());                idCardOcrVo.setGender(&quot;男&quot;.equals(resp.getSex()) ? &quot;1&quot; : &quot;2&quot;);                idCardOcrVo.setBirthday(DateTimeFormat.forPattern(&quot;yyyy/MM/dd&quot;).parseDateTime(resp.getBirth()).toDate());                idCardOcrVo.setIdcardNo(resp.getIdNum());                idCardOcrVo.setIdcardAddress(resp.getAddress());                //上传身份证正面图片到腾讯云cos                CosUploadVo cosUploadVo = cosService.upload(file, &quot;idCard&quot;);                idCardOcrVo.setIdcardFrontUrl(cosUploadVo.getUrl());                idCardOcrVo.setIdcardFrontShowUrl(cosUploadVo.getShowUrl());            &#125; else &#123;                //身份证反面                //证件有效期：&quot;2010.07.21-2020.07.21&quot;                String idcardExpireString = resp.getValidDate().split(&quot;-&quot;)[1];                idCardOcrVo.setIdcardExpire(DateTimeFormat.forPattern(&quot;yyyy.MM.dd&quot;).parseDateTime(idcardExpireString).toDate());                //上传身份证反面图片到腾讯云cos                CosUploadVo cosUploadVo = cosService.upload(file, &quot;idCard&quot;);                idCardOcrVo.setIdcardBackUrl(cosUploadVo.getUrl());                idCardOcrVo.setIdcardBackShowUrl(cosUploadVo.getShowUrl());            &#125;            return idCardOcrVo;        &#125; catch (Exception e) &#123;            throw new GuiguException(ResultCodeEnum.DATA_ERROR);        &#125;    &#125;	//驾驶证识别  	@Override  	public DriverLicenseOcrVo driverLicenseOcr(MultipartFile file) &#123;  	    try&#123;  	        //图片转换base64格式字符串  	        byte[] base64 = Base64.encodeBase64(file.getBytes());  	        String fileBase64 = new String(base64);  	  	        // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密  	        Credential cred = new Credential(tencentCloudProperties.getSecretId(),  	                tencentCloudProperties.getSecretKey());  	        // 实例化一个http选项，可选的，没有特殊需求可以跳过  	        HttpProfile httpProfile = new HttpProfile();  	        httpProfile.setEndpoint(&quot;ocr.tencentcloudapi.com&quot;);  	        // 实例化一个client选项，可选的，没有特殊需求可以跳过  	        ClientProfile clientProfile = new ClientProfile();  	        clientProfile.setHttpProfile(httpProfile);  	        // 实例化要请求产品的client对象,clientProfile是可选的  	        OcrClient client = new OcrClient(cred, tencentCloudProperties.getRegion(),  	                clientProfile);  	        // 实例化一个请求对象,每个接口都会对应一个request对象  	        DriverLicenseOCRRequest req = new DriverLicenseOCRRequest();  	        req.setImageBase64(fileBase64);  	  	        // 返回的resp是一个DriverLicenseOCRResponse的实例，与请求对象对应  	        DriverLicenseOCRResponse resp = client.DriverLicenseOCR(req);  	  	        //封装到vo对象里面  	        DriverLicenseOcrVo driverLicenseOcrVo = new DriverLicenseOcrVo();  	        if (StringUtils.hasText(resp.getName())) &#123;  	            //驾驶证正面  	            //驾驶证名称要与身份证名称一致  	            driverLicenseOcrVo.setName(resp.getName());  	            driverLicenseOcrVo.setDriverLicenseClazz(resp.getClass_());  	            driverLicenseOcrVo.setDriverLicenseNo(resp.getCardCode());  	            driverLicenseOcrVo.setDriverLicenseIssueDate(DateTimeFormat.forPattern(&quot;yyyy-MM-dd&quot;).parseDateTime(resp.getDateOfFirstIssue()).toDate());  	            driverLicenseOcrVo.setDriverLicenseExpire(DateTimeFormat.forPattern(&quot;yyyy-MM-dd&quot;).parseDateTime(resp.getEndDate()).toDate());  	  	            //上传驾驶证反面图片到腾讯云cos  	            CosUploadVo cosUploadVo = cosService.upload(file, &quot;driverLicense&quot;);  	            driverLicenseOcrVo.setDriverLicenseFrontUrl(cosUploadVo.getUrl());  	            driverLicenseOcrVo.setDriverLicenseFrontShowUrl(cosUploadVo.getShowUrl());  	        &#125; else &#123;  	            //驾驶证反面  	            //上传驾驶证反面图片到腾讯云cos  	            CosUploadVo cosUploadVo =  cosService.upload(file, &quot;driverLicense&quot;);  	            driverLicenseOcrVo.setDriverLicenseBackUrl(cosUploadVo.getUrl());  	            driverLicenseOcrVo.setDriverLicenseBackShowUrl(cosUploadVo.getShowUrl());  	        &#125;  	  	        return driverLicenseOcrVo;  	    &#125; catch (Exception e) &#123;  	        e.printStackTrace();  	        throw new GuiguException(ResultCodeEnum.DATA_ERROR);  	    &#125;  	&#125;&#125;

service-client@FeignClient(value = &quot;service-driver&quot;)  public interface OcrFeignClient &#123;        @PostMapping(value = &quot;/ocr/idCardOcr&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)      Result&lt;IdCardOcrVo&gt; idCardOcr(@RequestPart(&quot;file&quot;) MultipartFile file);        @PostMapping(value = &quot;/ocr/driverLicenseOcr&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)      Result&lt;DriverLicenseOcrVo&gt; driverLicenseOcr(@RequestPart(&quot;file&quot;) MultipartFile file);  &#125;


web-service
controller
@Slf4j  @Tag(name = &quot;腾讯云识别接口管理&quot;)  @RestController  @RequestMapping(value=&quot;/ocr&quot;)  @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)  public class OcrController &#123;        @Autowired      private OcrService ocrService;        @Operation(summary = &quot;身份证识别&quot;)      @LoginDetection      @PostMapping(&quot;/idCardOcr&quot;)      public Result&lt;IdCardOcrVo&gt; uploadDriverLicenseOcr(@RequestPart(&quot;file&quot;)MultipartFile file)&#123;          return Result.ok(ocrService.idCardOcr(file));      &#125;        @Operation(summary = &quot;驾驶证识别&quot;)      @LoginDetection      @PostMapping(&quot;/driverLicenseOcr&quot;)      public Result&lt;DriverLicenseOcrVo&gt; driverLicenseOcr(@RequestPart(&quot;file&quot;)MultipartFile file)&#123;          return Result.ok(ocrService.driverLicenseOcr(file));      &#125;  &#125;

serivce
@Slf4j  @Service  @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)  public class OcrServiceImpl implements OcrService &#123;        @Autowired      private OcrFeignClient ocrFeignClient;        // 身份证      @Override      public IdCardOcrVo idCardOcr(MultipartFile file) &#123;          Result&lt;IdCardOcrVo&gt; ocrVoResult = ocrFeignClient.idCardOcr(file);          return ocrVoResult.getData();      &#125;        // 驾驶证      @Override      public DriverLicenseOcrVo driverLicenseOcr(MultipartFile file) &#123;          Result&lt;DriverLicenseOcrVo&gt; result = ocrFeignClient.driverLicenseOcr(file);          return result.getData();      &#125;  &#125;

获取司机认证信息思路司机登录后会进入认证界面，判单是否认证，进入认证界面是会显示回显的图片
其实这个很简单，因为腾讯云的那个文字识别会返回参数出来，我们只需要把回显地址返回回去就行
driver-service

通过id来传入回显地址

driver-web

调用该

service-driver
controller
@Operation(summary = &quot;获取司机认证信息&quot;)@GetMapping(&quot;/getDriverAuthInfo/&#123;driverId&#125;&quot;)public Result&lt;DriverAuthInfoVo&gt; getDriverAuthInfo(@PathVariable Long driverId) &#123;    DriverAuthInfoVo driverAuthInfoVo = driverInfoService.getDriverAuthInfo(driverId);    return Result.ok(driverAuthInfoVo);&#125;

service
```java//获取司机认证信息@Overridepublic DriverAuthInfoVo getDriverAuthInfo(Long driverId) &#123;    DriverInfo driverInfo = driverInfoMapper.selectById(driverId);    DriverAuthInfoVo driverAuthInfoVo = new DriverAuthInfoVo();    BeanUtils.copyProperties(driverInfo,driverAuthInfoVo);    driverAuthInfoVo.setIdcardBackShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardBackUrl()));        driverAuthInfoVo.setIdcardFrontShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardFrontUrl()));    driverAuthInfoVo.setIdcardHandShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardHandUrl()));    driverAuthInfoVo.setDriverLicenseFrontShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseFrontUrl()));    driverAuthInfoVo.setDriverLicenseBackShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseBackUrl()));    driverAuthInfoVo.setDriverLicenseHandShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseHandUrl()));    return driverAuthInfoVo;&#125;

service-client@GetMapping(&quot;/driver/info/getDriverAuthInfo/&#123;driverId&#125;&quot;)Result&lt;DriverAuthInfoVo&gt; getDriverAuthInfo(@PathVariable(&quot;driverId&quot;) Long driverId);


web-serive
controller
@Operation(summary = &quot;获取司机认证信息&quot;)@GuiguLogin@GetMapping(&quot;/getDriverAuthInfo&quot;)public Result&lt;DriverAuthInfoVo&gt; getDriverAuthInfo() &#123;    //获取登录用户id，当前是司机id    Long driverId = AuthContextHolder.getUserId();    return Result.ok(driverService.getDriverAuthInfo(driverId));&#125;

serivce
//司机认证信息@Overridepublic DriverAuthInfoVo getDriverAuthInfo(Long driverId) &#123;    Result&lt;DriverAuthInfoVo&gt; authInfoVoResult = driverInfoFeignClient.getDriverAuthInfo(driverId);    DriverAuthInfoVo driverAuthInfoVo = authInfoVoResult.getData();    return driverAuthInfoVo;&#125;

修改司机认证信息思路前端点击提交后，后端需要更新客户认证信息​    0:  未认证 【刚注册完为未认证状态】​    1：审核中 【提交了认证信息后变为审核中】​    2：认证通过 【后台审核通过】​   -1：认证未通过【后台审核不通过】
这个和上面差不多，其他就不写了，就写一个service
// 更新司机认证信息@Overridepublic boolean updateDriverAuthInfo(UpdateDriverAuthInfoForm update) &#123;	Long driverId = update.getDriverId();	DriverInfo driverInfo = new DriverInfo();	driverInfo.setId(driverId);	BeanUtils.copyProperties(update, driverInfo);	return this.updateById(driverInfo);&#125;

开通人脸识别腾讯云文档：人脸识别_人脸搜索_人脸检测_人脸比对-腾讯云
1、开通腾讯云人脸识别2、创建人员库
创建司机人脸模型创建人脸识别模型之后，腾讯云返回模型id，获取模型id，更新到数据库表，但是因为这是调用腾讯云接口，所以如果之前已经有人拿这张图片创建过则不会创建新的模型id，而是返回之前创建的id

修改配置文件

修改配置类
@Data@Component@ConfigurationProperties(prefix = &quot;tencent.cloud&quot;)public class TencentCloudProperties &#123;    private String secretId;    private String secretKey;    private String region;    private String bucketPrivate;    private String persionGroupId;&#125;

根据腾讯云文档来实现代码 API Explorer - 云 API - 控制台


service-driver后面都是只写重要的代码实现，一般的调用就不写了
// 创建司机人脸模型@Overridepublic Boolean creatDriverFaceModel(DriverFaceModelForm driverFaceModelForm) &#123;	//根据司机id获取司机信息	DriverInfo driverInfo =			driverInfoMapper.selectById(driverFaceModelForm.getDriverId());	try&#123;		Credential cred = new Credential(tencentCloudProperties.getSecretId(),				tencentCloudProperties.getSecretKey());		// 实例化一个http选项，可选的，没有特殊需求可以跳过		HttpProfile httpProfile = new HttpProfile();		httpProfile.setEndpoint(&quot;iai.tencentcloudapi.com&quot;);		// 实例化一个client选项，可选的，没有特殊需求可以跳过		ClientProfile clientProfile = new ClientProfile();		clientProfile.setHttpProfile(httpProfile);		// 实例化要请求产品的client对象,clientProfile是可选的		IaiClient client = new IaiClient(cred, tencentCloudProperties.getRegion(),				clientProfile);		// 实例化一个请求对象,每个接口都会对应一个request对象		CreatePersonRequest req = new CreatePersonRequest();		//设置相关值		req.setGroupId(tencentCloudProperties.getPersionGroupId());		//基本信息		req.setPersonId(String.valueOf(driverInfo.getId()));		req.setGender(Long.parseLong(driverInfo.getGender()));		req.setQualityControl(4L);		req.setUniquePersonControl(4L);		req.setPersonName(driverInfo.getName());		req.setImage(driverFaceModelForm.getImageBase64());		// 返回的resp是一个CreatePersonResponse的实例，与请求对象对应		CreatePersonResponse resp = client.CreatePerson(req);		// 输出json格式的字符串回包		System.out.println(AbstractModel.toJsonString(resp));		String faceId = resp.getFaceId();		if(StringUtils.hasText(faceId)) &#123;			driverInfo.setFaceModelId(faceId);			driverInfoMapper.updateById(driverInfo);		&#125;	&#125; catch (TencentCloudSDKException e) &#123;		e.printStackTrace();		return false;	&#125;	return true;&#125;

预估订单数据查找客户端当前订单当一个客户发起订单前先要查询是否有发起并且没有完成的订单，如果有订单未完成，则会弹出进行中的订单
预估驾驶路线
访问腾讯官网 https://lbs.qq.com/

进行注册，手机号或者微信或者其他方式

使用注册账号进行登录，找到控制台

在应用管理 – 我的应用 ，创建应用

在创建应用中，添加key

修改nacos配置文件

编写接口


下面实现接口，具体内容就是请求腾讯云提供的接口，按照接口传参数，然后返回需要的结果
腾讯官方文档：WebService API | 腾讯位置服务

编写配置类
@Configurationpublic class MyConfig &#123;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;

service
@Slf4j  @Service  @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)  public class MapServiceImpl implements MapService &#123;        @Autowired      private RestTemplate restTemplate;        @Value(&quot;$&#123;tencent.map.key&#125;&quot;)      private String key;        //计算驾驶线路      @Override      public DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) &#123;          //请求腾讯提供接口，按照接口要求传递相关参数，返回需要结果          //使用HttpClient，目前Spring封装调用工具使用RestTemplate          //定义调用腾讯地址          String url = &quot;https://apis.map.qq.com/ws/direction/v1/driving/?from=&#123;from&#125;&amp;to=&#123;to&#125;&amp;key=&#123;key&#125;&quot;;            //封装传递参数          Map&lt;String,String&gt; map = new HashMap();          //开始位置          // 经纬度：比如 北纬40 东京116          map.put(&quot;from&quot;,calculateDrivingLineForm.getStartPointLatitude()+&quot;,&quot;+calculateDrivingLineForm.getStartPointLongitude());          //结束位置          map.put(&quot;to&quot;,calculateDrivingLineForm.getEndPointLatitude()+&quot;,&quot;+calculateDrivingLineForm.getEndPointLongitude());          //key          map.put(&quot;key&quot;,key);            //使用RestTemplate调用 GET        JSONObject result = restTemplate.getForObject(url, JSONObject.class, map);          //处理返回结果          //判断调用是否成功          int status = Objects.requireNonNull(result).getIntValue(&quot;status&quot;);          if(status != 0) &#123;//失败              throw new GuiguException(ResultCodeEnum.MAP_FAIL);          &#125;            //获取返回路线信息          JSONObject route =                  result.getJSONObject(&quot;result&quot;).getJSONArray(&quot;routes&quot;).getJSONObject(0);            //创建vo对象          DrivingLineVo drivingLineVo = new DrivingLineVo();          //预估时间          drivingLineVo.setDuration(route.getBigDecimal(&quot;duration&quot;));          //距离  6.583 == 6.58 / 6.59        drivingLineVo.setDistance(route.getBigDecimal(&quot;distance&quot;)                  .divide(new BigDecimal(1000))                  .setScale(2, RoundingMode.HALF_UP));          //路线          drivingLineVo.setPolyline(route.getJSONArray(&quot;polyline&quot;));            return drivingLineVo;      &#125;  &#125;

预估订单金额整合规则引擎Drools
引入依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.drools&lt;/groupId&gt;        &lt;artifactId&gt;drools-core&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.drools&lt;/groupId&gt;        &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.drools&lt;/groupId&gt;        &lt;artifactId&gt;drools-decisiontables&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.drools&lt;/groupId&gt;        &lt;artifactId&gt;drools-mvel&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

创建Drools配置类
@Configurationpublic class DroolsConfig &#123;    // 制定规则文件的路径    private static final String RULES_CUSTOMER_RULES_DRL = &quot;rules/FeeRule.drl&quot;;    @Bean    public KieContainer kieContainer() &#123;        KieServices kieServices = KieServices.Factory.get();        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();        kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_CUSTOMER_RULES_DRL));        KieBuilder kb = kieServices.newKieBuilder(kieFileSystem);        kb.buildAll();        KieModule kieModule = kb.getKieModule();        KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());        return kieContainer;    &#125;&#125;

创建规则文件


封装费用规则接口实体类
两个实体类，输入对象和输出对象

输入对象
@Datapublic class FeeRuleRequest &#123;    @Schema(description = &quot;代驾里程&quot;)// swagger里面的描述    private BigDecimal distance;    @Schema(description = &quot;代驾时间&quot;)    private String startTime;    @Schema(description = &quot;等候分钟&quot;)    private Integer waitMinute;&#125;

输出对象
@Datapublic class FeeRuleResponse &#123;    @Schema(description = &quot;总金额&quot;)    private BigDecimal totalAmount;    @Schema(description = &quot;里程费&quot;)    private BigDecimal distanceFee;    @Schema(description = &quot;等时费用&quot;)    private BigDecimal waitFee;    @Schema(description = &quot;远程费&quot;)    private BigDecimal longDistanceFee;    @Schema(description = &quot;基础里程（公里）&quot;)    private BigDecimal baseDistance;    @Schema(description = &quot;基础里程费（元）&quot;)    private BigDecimal baseDistanceFee;    @Schema(description = &quot;超出基础里程的里程（公里）&quot;)    private BigDecimal exceedDistance;    @Schema(description = &quot;超出基础里程的价格（元/公里）&quot;)    private BigDecimal exceedDistancePrice;    @Schema(description = &quot;基础等时分钟（分钟）&quot;)    private Integer baseWaitMinute;    @Schema(description = &quot;超出基础等时的分钟（分钟）&quot;)    private Integer exceedWaitMinute;    @Schema(description = &quot;超出基础分钟的价格（元/分钟）&quot;)    private BigDecimal exceedWaitMinutePrice;    @Schema(description = &quot;基础远途里程（公里）&quot;)    private BigDecimal baseLongDistance;    @Schema(description = &quot;超出基础远程里程的里程（公里）&quot;)    private BigDecimal exceedLongDistance;    @Schema(description = &quot;超出基础远程里程的价格（元/公里）&quot;)    private BigDecimal exceedLongDistancePrice;&#125;

费用规则文件1.起步价    00:00:00-06:59:59  19元(含3公里)    07:00:00-23:59:59  19元(含5公里)2.里程费    超出起步里程后开始计算    00:00:00-06:59:59   4元&#x2F;1公里    07:00:00-23:59:59   3元&#x2F;1公里3.等候费    等候10分钟后  1元&#x2F;1分钟4.远途费    订单行程超出12公里后每公里1元5.计算总金额    订单总金额 &#x3D; 基础里程费 + 超出基础里程的费 + 等候费 + 远程费
//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问package  com.atguigu.daijiaimport com.atguigu.daijia.model.form.rules.FeeRuleRequest;import java.math.BigDecimal;import java.math.RoundingMode;global com.atguigu.daijia.model.vo.rules.FeeRuleResponse feeRuleResponse;/**1.起步价    00:00:00-06:59:59  19元(含3公里)    07:00:00-23:59:59  19元(含5公里)*/rule &quot;起步价 00:00:00-06:59:59  19元(含3公里)&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(startTime &gt;= &quot;00:00:00&quot; &amp;&amp; startTime &lt;= &quot;06:59:59&quot;)    then        feeRuleResponse.setBaseDistance(new BigDecimal(&quot;3.0&quot;));        feeRuleResponse.setBaseDistanceFee(new BigDecimal(&quot;19.0&quot;));        //3公里内里程费为0        feeRuleResponse.setExceedDistance(new BigDecimal(&quot;0.0&quot;));        feeRuleResponse.setExceedDistancePrice(new BigDecimal(&quot;4.0&quot;));        System.out.println(&quot;00:00:00-06:59:59 &quot; + feeRuleResponse.getBaseDistance() + &quot;公里，起步价:&quot; + feeRuleResponse.getBaseDistanceFee() + &quot;元&quot;);endrule &quot;起步价 07:00:00-23:59:59  19元(含5公里)&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(startTime &gt;= &quot;07:00:00&quot; &amp;&amp; startTime &lt;= &quot;23:59:59&quot;)    then        feeRuleResponse.setBaseDistance(new BigDecimal(&quot;5.0&quot;));        feeRuleResponse.setBaseDistanceFee(new BigDecimal(&quot;19.0&quot;));        //5公里内里程费为0        feeRuleResponse.setExceedDistance(new BigDecimal(&quot;0.0&quot;));        feeRuleResponse.setExceedDistancePrice(new BigDecimal(&quot;3.0&quot;));        System.out.println(&quot;07:00:00-23:59:59 &quot; + feeRuleResponse.getBaseDistance() + &quot;公里，起步价:&quot; + feeRuleResponse.getBaseDistanceFee() + &quot;元&quot;);end/**2.里程费    超出起步里程后开始计算    00:00:00-06:59:59   4元/1公里    07:00:00-23:59:59   3元/1公里*/rule &quot;里程费 00:00:00-06:59:59 4元/1公里&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(startTime &gt;= &quot;00:00:00&quot;            &amp;&amp; startTime &lt;= &quot;06:59:59&quot;            &amp;&amp; distance.doubleValue() &gt; 3.0)    then        BigDecimal exceedDistance = $rule.getDistance().subtract(new BigDecimal(&quot;3.0&quot;));        feeRuleResponse.setExceedDistance(exceedDistance);        feeRuleResponse.setExceedDistancePrice(new BigDecimal(&quot;4.0&quot;));        System.out.println(&quot;里程费，超出里程:&quot; + feeRuleResponse.getExceedDistance() + &quot;公里，单价：&quot; + feeRuleResponse.getExceedDistancePrice());endrule &quot;里程费 07:00:00-23:59:59 3元/1公里&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(startTime &gt;= &quot;07:00:00&quot;            &amp;&amp; startTime &lt;= &quot;23:59:59&quot;            &amp;&amp; distance.doubleValue() &gt; 5.0)    then        BigDecimal exceedDistance = $rule.getDistance().subtract(new BigDecimal(&quot;5.0&quot;));        feeRuleResponse.setExceedDistance(exceedDistance);        feeRuleResponse.setExceedDistancePrice(new BigDecimal(&quot;3.0&quot;));        System.out.println(&quot;里程费，超出里程:&quot; + feeRuleResponse.getExceedDistance() + &quot;公里，单价：&quot; + feeRuleResponse.getExceedDistancePrice());end/**3.等候费    等候10分钟后  1元/1分钟*/rule &quot;等候费 等候10分钟后 1元/1分钟&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(waitMinute &gt; 10)    then        Integer exceedWaitMinute = $rule.getWaitMinute() - 10;        feeRuleResponse.setBaseWaitMinute(10);        feeRuleResponse.setExceedWaitMinute(exceedWaitMinute);        feeRuleResponse.setExceedWaitMinutePrice(new BigDecimal(&quot;1.0&quot;));        System.out.println(&quot;等候费，超出分钟:&quot; + feeRuleResponse.getExceedWaitMinute() + &quot;分钟，单价：&quot; + feeRuleResponse.getExceedWaitMinutePrice());endrule &quot;无等候费&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(waitMinute &lt;= 10)    then        feeRuleResponse.setBaseWaitMinute(10);        feeRuleResponse.setExceedWaitMinute(0);        feeRuleResponse.setExceedWaitMinutePrice(new BigDecimal(&quot;1.0&quot;));        System.out.println(&quot;等候费：无&quot;);end/**4.远途费    订单行程超出12公里后每公里1元*/rule &quot;远途费 订单行程超出12公里后每公里1元&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(distance.doubleValue() &gt; 12.0)    then        BigDecimal exceedLongDistance = $rule.getDistance().subtract(new BigDecimal(&quot;12.0&quot;));        feeRuleResponse.setBaseLongDistance(new BigDecimal(&quot;12.0&quot;));        feeRuleResponse.setExceedLongDistance(exceedLongDistance);        feeRuleResponse.setExceedLongDistancePrice(new BigDecimal(&quot;1.0&quot;));        System.out.println(&quot;远途费，超出公里:&quot; + feeRuleResponse.getExceedLongDistance() + &quot;公里，单价：&quot; + feeRuleResponse.getExceedLongDistancePrice());endrule &quot;无远途费&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(distance.doubleValue() &lt;= 12.0)    then        feeRuleResponse.setBaseLongDistance(new BigDecimal(&quot;12.0&quot;));        feeRuleResponse.setExceedLongDistance(new BigDecimal(&quot;0&quot;));        feeRuleResponse.setExceedLongDistancePrice(new BigDecimal(&quot;0&quot;));        System.out.println(&quot;远途费：无&quot;);end/**5.计算总金额    订单总金额 = 基础里程费 + 超出基础里程的费 + 等候费 + 远程费*/rule &quot;计算总金额&quot;    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行    no-loop true         //防止陷入死循环    when        /*规则条件，到工作内存中查找FeeRuleRequest对象        里面出来的结果只能是ture或者false        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/        $rule:FeeRuleRequest(distance.doubleValue() &gt; 0.0)    then        //订单总金额 = 基础里程费 + 超出基础里程的费 + 等候费 + 远程费        BigDecimal distanceFee = feeRuleResponse.getBaseDistanceFee().add(feeRuleResponse.getExceedDistance().multiply(feeRuleResponse.getExceedDistancePrice()));        BigDecimal waitFee = new BigDecimal(feeRuleResponse.getExceedWaitMinute()).multiply(feeRuleResponse.getExceedWaitMinutePrice());        BigDecimal longDistanceFee = feeRuleResponse.getExceedLongDistance().multiply(feeRuleResponse.getExceedLongDistancePrice());        BigDecimal totalAmount = distanceFee.add(waitFee).add(longDistanceFee);        feeRuleResponse.setDistanceFee(distanceFee);        feeRuleResponse.setWaitFee(waitFee);        feeRuleResponse.setLongDistanceFee(longDistanceFee);        feeRuleResponse.setTotalAmount(totalAmount);        System.out.println(&quot;计算总金额:&quot; + feeRuleResponse.getTotalAmount() + &quot;元&quot;);end

预估订单金额接口
FeeRuleController
@Slf4j@RestController@RequestMapping(&quot;/rules/fee&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class FeeRuleController &#123;    @Autowired    private FeeRuleService feeRuleService;    @Operation(summary = &quot;计算订单费用&quot;)    @PostMapping(&quot;/calculateOrderFee&quot;)    public Result&lt;FeeRuleResponseVo&gt; calculateOrderFee(@RequestBody FeeRuleRequestForm calculateOrderFeeForm) &#123;        FeeRuleResponseVo feeRuleResponseVo = feeRuleService.calculateOrderFee(calculateOrderFeeForm);        return Result.ok(feeRuleResponseVo);    &#125;&#125;

FeeRuleService
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class FeeRuleServiceImpl implements FeeRuleService &#123;    @Autowired    private KieContainer kieContainer;    // 计算订单费用    @Override    public FeeRuleResponseVo calculateOrderFee(FeeRuleRequestForm form) &#123;        // 封装输入对象        FeeRuleRequest request = new FeeRuleRequest();        request.setDistance(form.getDistance());        Date startTime = form.getStartTime();        request.setStartTime(new DateTime(startTime).toString(&quot;HH:mm:ss&quot;));        request.setWaitMinute(form.getWaitMinute());        // Drools执行规则        KieSession session = kieContainer.newKieSession();        // 封装返回对象        FeeRuleResponseVo response = new FeeRuleResponseVo();        session.setGlobal(&quot;feeRuleResponse&quot;,response);        session.insert(request);        session.fireAllRules();        session.dispose();        // 封装数据到输出对象        FeeRuleResponseVo vo = new FeeRuleResponseVo();        BeanUtils.copyProperties(response,vo);        return vo;    &#125;&#125;

远程调用接口@FeignClient(value = &quot;service-rules&quot;)public interface FeeRuleFeignClient &#123;    /**     * 计算订单费用     * @param calculateOrderFeeForm     * @return     */    @PostMapping(&quot;/rules/fee/calculateOrderFee&quot;)    Result&lt;FeeRuleResponseVo&gt; calculateOrderFee(@RequestBody FeeRuleRequestForm calculateOrderFeeForm);&#125;


预估订单数据接口
OrderController
@Autowired  private OrderService orderService;    @Operation(summary = &quot;预估订单数据&quot;)  @LoginDetection  @PostMapping(&quot;/expectOrder&quot;)  public Result&lt;ExpectOrderVo&gt; expectOrder(@RequestBody ExpectOrderForm expectOrderForm) &#123;      return Result.ok(orderService.expectOrder(expectOrderForm));  &#125;

OrderService
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OrderServiceImpl implements OrderService &#123;    @Autowired    private MapFeignClient mapFeignClient;    @Autowired    private FeeRuleFeignClient feeRuleFeignClient;    // 预估订单数据    @Override    public ExpectOrderVo expectOrder(ExpectOrderForm expectOrderForm) &#123;        //获取驾驶线路        CalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();        BeanUtils.copyProperties(expectOrderForm,calculateDrivingLineForm);        Result&lt;DrivingLineVo&gt; drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);        DrivingLineVo drivingLineVo = drivingLineVoResult.getData();        //获取订单费用        FeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();        calculateOrderFeeForm.setDistance(drivingLineVo.getDistance());        calculateOrderFeeForm.setStartTime(new Date());        calculateOrderFeeForm.setWaitMinute(0);        Result&lt;FeeRuleResponseVo&gt; feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);        FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();        //封装ExpectOrderVo        ExpectOrderVo expectOrderVo = new ExpectOrderVo();        expectOrderVo.setDrivingLineVo(drivingLineVo);        expectOrderVo.setFeeRuleResponseVo(feeRuleResponseVo);        return expectOrderVo;    &#125;&#125;

乘客下单（一）点击 呼叫代驾 会生成代驾订单，在 order_info 里添加订单数据
乘客下单接口
controller 不写了，就是调用获取数据

service
@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OrderInfoServiceImpl extends ServiceImpl&lt;OrderInfoMapper, OrderInfo&gt; implements OrderInfoService &#123;    @Autowired    private OrderInfoMapper orderInfoMapper;    @Autowired    private OrderStatusLogMapper orderStatusLogMapper;    // 乘客下单    @Override    public Long saveOrderInfo(OrderInfoForm orderInfoForm) &#123;        // 向order_info表中插入数据        OrderInfo orderInfo = new OrderInfo();        BeanUtils.copyProperties(orderInfoForm, orderInfo);        orderInfo.setOrderNo(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));        orderInfo.setStatus(OrderStatus.WAITING_ACCEPT.getStatus());        orderInfoMapper.insert(orderInfo);        // 记录日志        this.log(orderInfo.getId(), orderInfo.getStatus());                return orderInfo.getId();    &#125;    public void log(Long orderId, Integer status) &#123;        OrderStatusLog orderStatusLog = new OrderStatusLog();        orderStatusLog.setOrderId(orderId);        orderStatusLog.setOrderStatus(status);        orderStatusLog.setOperateTime(new Date());        orderStatusLogMapper.insert(orderStatusLog);    &#125;&#125;

远程调用
@FeignClient(value = &quot;service-order&quot;)public interface OrderInfoFeignClient &#123;    /**     * 保存订单信息     * @param orderInfoForm     * @return     */    @PostMapping(&quot;/order/info/saveOrderInfo&quot;)    Result&lt;Long&gt; saveOrderInfo(@RequestBody OrderInfoForm orderInfoForm);&#125;

web-service
@Overridepublic Long submitOrder(SubmitOrderForm submitOrderForm) &#123;	//1 重新计算驾驶线路	CalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();	BeanUtils.copyProperties(submitOrderForm,submitOrderForm);	Result&lt;DrivingLineVo&gt; drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);	DrivingLineVo drivingLineVo = drivingLineVoResult.getData();	//2 重新订单费用	FeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();	calculateOrderFeeForm.setDistance(drivingLineVo.getDistance());	calculateOrderFeeForm.setStartTime(new Date());	calculateOrderFeeForm.setWaitMinute(0);	Result&lt;FeeRuleResponseVo&gt; feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);	FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();	//封装数据	OrderInfoForm orderInfoForm = new OrderInfoForm();	BeanUtils.copyProperties(submitOrderForm,orderInfoForm);	orderInfoForm.setExpectDistance(drivingLineVo.getDistance());	orderInfoForm.setExpectAmount(feeRuleResponseVo.getTotalAmount());	Result&lt;Long&gt; orderInfoResult = orderInfoFeignClient.saveOrderInfo(orderInfoForm);	Long orderId = orderInfoResult.getData();	//TODO 查询附近可以接单司机	return orderId;&#125;

查询订单状态订单微服务模块接口
根据订单id得到订单状态

OrderInfoController
@Operation(summary = &quot;根据订单id获取订单状态&quot;)@GetMapping(&quot;/getOrderStatus/&#123;orderId&#125;&quot;)public Result&lt;Integer&gt; getOrderStatus(@PathVariable Long orderId) &#123;    return Result.ok(orderInfoService.getOrderStatus(orderId));&#125;

service
@Override  public Integer getOrderStatus(Long orderId) &#123;      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId, orderId);      wrapper.select(OrderInfo::getStatus);        OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);        if(orderInfo == null)&#123;          return OrderStatus.NULL_ORDER.getStatus();      &#125;      return orderInfo.getStatus();  &#125;

远程调用
/** * 根据订单id获取订单状态 * @param orderId * @return */@GetMapping(&quot;/order/info/getOrderStatus/&#123;orderId&#125;&quot;)Result&lt;Integer&gt; getOrderStatus(@PathVariable(&quot;orderId&quot;) Long orderId);

远程调用乘客端 web-customercontroller
@Operation(summary = &quot;查询订单状态&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderStatus/&#123;orderId&#125;&quot;)  public Result&lt;Integer&gt; getOrderStatus(@PathVariable Long orderId) &#123;      return Result.ok(orderService.getOrderStatus(orderId));  &#125;

service
@Overridepublic Integer getOrderStatus(Long orderId) &#123;    Result&lt;Integer&gt; integerResult = orderInfoFeignClient.getOrderStatus(orderId);    return integerResult.getData();&#125;

司机端 web-drivercontroller
@Tag(name = &quot;订单API接口管理&quot;)@RestController@RequestMapping(&quot;/order&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OrderController &#123;    @Autowired    private OrderService orderService;        @Operation(summary = &quot;查询订单状态&quot;)    @GuiguLogin    @GetMapping(&quot;/getOrderStatus/&#123;orderId&#125;&quot;)    public Result&lt;Integer&gt; getOrderStatus(@PathVariable Long orderId) &#123;        return Result.ok(orderService.getOrderStatus(orderId));    &#125;&#125;

service
@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class OrderServiceImpl implements OrderService &#123;    @Autowired    private OrderInfoFeignClient orderInfoFeignClient;    @Override    public Integer getOrderStatus(Long orderId) &#123;        return orderInfoFeignClient.getOrderStatus(orderId).getData();    &#125;&#125;

乘客下单（二）搜索附件可以下单的司机Redis的GEO功能
**GEOADD 添加位置信息

GEOADD zhangsan 116.403963 39.915119 tiananmen 116.417876 39.915411 wangfujing 116.404354 39.904748 qianmen


**GEORADIUS 搜索范围以内消息

GEORADIUS zhangsan 116.4000 39.9000 1 km WITHDIST
实时更新司机的位置信息封装位置相关接口service.service-map
controller
@Tag(name = &quot;位置API接口管理&quot;)@RestController@RequestMapping(&quot;/map/location&quot;)@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class LocationController &#123;    @Autowired    private LocationService locationService;    //司机开启接单，更新司机位置信息    @Operation(summary = &quot;开启接单服务：更新司机经纬度位置&quot;)    @PostMapping(&quot;/updateDriverLocation&quot;)    public Result&lt;Boolean&gt; updateDriverLocation(@RequestBody                                                UpdateDriverLocationForm updateDriverLocationForm) &#123;        Boolean flag = locationService.updateDriverLocation(updateDriverLocationForm);        return Result.ok(flag);    &#125;    //司机关闭接单，删除司机位置信息    @Operation(summary = &quot;关闭接单服务：删除司机经纬度位置&quot;)    @DeleteMapping(&quot;/removeDriverLocation/&#123;driverId&#125;&quot;)    public Result&lt;Boolean&gt; removeDriverLocation(@PathVariable Long driverId) &#123;        return Result.ok(locationService.removeDriverLocation(driverId));    &#125;&#125;

service
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class LocationServiceImpl implements LocationService &#123;    @Autowired    private RedisTemplate redisTemplate;    // 更新司机位置信息    @Override    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) &#123;        Point point = new Point(updateDriverLocationForm.getLongitude().doubleValue(),                updateDriverLocationForm.getLatitude().doubleValue());        redisTemplate.opsForGeo().add(RedisConstant.DRIVER_GEO_LOCATION,                                point,                                updateDriverLocationForm.getDriverId().toString());        return true;    &#125;    // 删除司机位置信息    @Override    public Boolean removeDriverLocation(Long driverId) &#123;        redisTemplate.opsForGeo().remove(RedisConstant.DRIVER_GEO_LOCATION,driverId.toString());        return true;    &#125;&#125;

远程调用定义service-client.service-map-client
@FeignClient(value = &quot;service-map&quot;)public interface LocationFeignClient &#123;    /**     * 开启接单服务：更新司机经纬度位置     * @param updateDriverLocationForm     * @return     */    @PostMapping(&quot;/map/location/updateDriverLocation&quot;)    Result&lt;Boolean&gt; updateDriverLocation(@RequestBody UpdateDriverLocationForm updateDriverLocationForm);    /**     * 关闭接单服务：删除司机经纬度位置     * @param driverId     * @return     */    @DeleteMapping(&quot;/map/location/removeDriverLocation/&#123;driverId&#125;&quot;)    Result&lt;Boolean&gt; removeDriverLocation(@PathVariable(&quot;driverId&quot;) Long driverId);&#125;

司机web端web.web-driver.controller
controller
@Slf4j  @Tag(name = &quot;位置API接口管理&quot;)  @RestController  @RequestMapping(value=&quot;/location&quot;)  @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)  public class LocationController &#123;        @Autowired      private LocationService locationService;        @Operation(summary = &quot;开启接单服务：更新司机经纬度位置&quot;)      @LoginDetection      @PostMapping(&quot;/updateDriverLocation&quot;)      public Result&lt;Boolean&gt; updateDriverLocation(@RequestBody UpdateDriverLocationForm updateDriverLocationForm) &#123;          Long driverId = AuthContextHolder.getUserId();          updateDriverLocationForm.setDriverId(driverId);          return Result.ok(locationService.updateDriverLocation(updateDriverLocationForm));      &#125;  &#125;

service
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class LocationServiceImpl implements LocationService &#123;    @Autowired    private LocationFeignClient locationFeignClient;    // 更新司机消息    @Override    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) &#123;        Result&lt;Boolean&gt; booleanResult = locationFeignClient.updateDriverLocation(updateDriverLocationForm);        return booleanResult.getData();    &#125;&#125;

获取司机个性化设置信息封装查询司机个性化信息接口service.service-driver.driver
controller
@Operation(summary = &quot;获取司机设置信息&quot;)@GetMapping(&quot;/getDriverSet/&#123;driverId&#125;&quot;)public Result&lt;DriverSet&gt; getDriverSet(@PathVariable Long driverId) &#123;	return Result.ok(driverInfoService.getDriverSet(driverId));&#125;

service
@Overridepublic DriverSet getDriverSet(Long driverId) &#123;	LambdaQueryWrapper&lt;DriverSet&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();	wrapper.eq(DriverSet::getDriverId, driverId);	DriverSet driverSet = driverSetMapper.selectOne(wrapper);	return driverSet;&#125;

远程调用service-client.serivce-driver-client.DriverInfoFeignClient
@GetMapping(&quot;/driver/info/getDriverSet/&#123;driverId&#125;&quot;)  Result&lt;DriverSet&gt; getDriverSet(@PathVariable(&quot;driverId&quot;) Long driverId);

修改司机web端web.web-driver.controller
@Slf4j@Service@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)public class LocationServiceImpl implements LocationService &#123;    @Autowired    private LocationFeignClient locationFeignClient;    @Autowired    private DriverInfoFeignClient driverInfoFeignClient;    // 更新司机消息    @Override    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) &#123;        Long driverId = updateDriverLocationForm.getDriverId();        Result&lt;DriverSet&gt; driverSet = driverInfoFeignClient.getDriverSet(driverId);        DriverSet data = driverSet.getData();        if(data.getServiceStatus() == 1)&#123;            Result&lt;Boolean&gt; booleanResult = locationFeignClient.updateDriverLocation(updateDriverLocationForm);            return booleanResult.getData();        &#125;else &#123;            throw new GuiguException(ResultCodeEnum.NO_START_SERVICE);        &#125;    &#125;&#125;


搜索附件适合接单的司机封装搜索接单司机接口service-map.map
controller
@Operation(summary = &quot;搜索附近满足条件的司机&quot;)@PostMapping(&quot;/searchNearByDriver&quot;)public Result&lt;List&lt;NearByDriverVo&gt;&gt; searchNearByDriver(@RequestBody													   SearchNearByDriverForm searchNearByDriverForm) &#123;	return Result.ok(locationService.searchNearByDriver(searchNearByDriverForm));&#125;

service
//搜索附近满足条件的司机@Overridepublic List&lt;NearByDriverVo&gt; searchNearByDriver(SearchNearByDriverForm searchNearByDriverForm) &#123;    //搜索经纬度位置5公里以内的司机    //1 操作redis里面geo    //创建point，经纬度位置    Point point = new Point(searchNearByDriverForm.getLongitude().doubleValue(),            searchNearByDriverForm.getLatitude().doubleValue());    //定义距离，5公里    Distance distance = new Distance(SystemConstant.NEARBY_DRIVER_RADIUS,                           RedisGeoCommands.DistanceUnit.KILOMETERS);    //创建circle对象，point  distance    Circle circle = new Circle(point,distance);    //定义GEO参数，设置返回结果包含内容    RedisGeoCommands.GeoRadiusCommandArgs args =            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()                    .includeDistance()  //包含距离                    .includeCoordinates() //包含坐标                    .sortAscending(); //升序    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; result =            redisTemplate.opsForGeo().radius(RedisConstant.DRIVER_GEO_LOCATION, circle, args);    //2 查询redis最终返回list集合    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; content = result.getContent();    //3 对查询list集合进行处理    // 遍历list集合，得到每个司机信息    // 根据每个司机个性化设置信息判断    List&lt;NearByDriverVo&gt; list = new ArrayList&lt;&gt;();    if(!CollectionUtils.isEmpty(content)) &#123;        Iterator&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; iterator = content.iterator();        while(iterator.hasNext()) &#123;            GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; item = iterator.next();            //获取司机id            Long driverId = Long.parseLong(item.getContent().getName());            //远程调用，根据司机id个性化设置信息            Result&lt;DriverSet&gt; driverSetResult = driverInfoFeignClient.getDriverSet(driverId);            DriverSet driverSet = driverSetResult.getData();            //判断订单里程order_distance            BigDecimal orderDistance = driverSet.getOrderDistance();            //orderDistance==0，司机没有限制的            //如果不等于0 ，比如30，接单30公里代驾订单。            //接单距离 - 当前单子距离  &lt; 0,不复合条件            // 30          35            if(orderDistance.doubleValue() != 0                    &amp;&amp; orderDistance.subtract(searchNearByDriverForm.getMileageDistance()).doubleValue()&lt;0) &#123;                continue;            &#125;            //判断接单里程 accept_distance            //当前接单距离            BigDecimal currentDistance =                    new BigDecimal(item.getDistance().getValue()).setScale(2, RoundingMode.HALF_UP);            BigDecimal acceptDistance = driverSet.getAcceptDistance();            if(acceptDistance.doubleValue() !=0            &amp;&amp; acceptDistance.subtract(currentDistance).doubleValue()&lt;0) &#123;                continue;            &#125;            //封装复合条件数据            NearByDriverVo nearByDriverVo = new NearByDriverVo();            nearByDriverVo.setDriverId(driverId);            nearByDriverVo.setDistance(currentDistance);            list.add(nearByDriverVo);        &#125;    &#125;    return list;&#125;

接口测试
启动相关服务

service-map 和 service-driver

使用Swagger进行接口测试

http://localhost:8503/doc.html#/home
第一个接口测试用例及结果![[Pasted image 20250528233022.png]]
发现错误来源于redis，开始排查
排查成功，犯了两个很低级的错误

测试错误接口
nacos没有改配置文件，导致redis连接不上

再次测试为成功![[Pasted image 20250528233937.png]]
第二个接口测试用例及结果![[Pasted image 20250528234733.png]]
还是失败，挠头了，去看看报错是什么![[Pasted image 20250528235311.png]]
空对象？ok啊，结合自己聪明的大脑以及一点外界帮助，得出原因是因为司机只有一个，但是却有三满足条件司机的数据，程序蒙了，不知道返回哪个
解决方法是：因为是测试嘛，也不用太严谨，自己手动在数据库里面凭空产生点司机出来就行
再次测试，成功![[Pasted image 20250528235542.png]]
集成XXL-JOBservice.serivce-dispatch模块
导入依赖&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;        &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

执行器配置
修改nacos配置文件 service-dispatch-dev.yaml

创建XXL-JOB配置类
import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;  @Configurationpublic class XxlJobConfig &#123;    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)    private String adminAddresses;    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)    private String accessToken;    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)    private String appname;    @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)    private String address;    @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)    private String ip;    @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)    private int port;    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)    private String logPath;    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() &#123;        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    &#125;&#125;

编写任务job方法测试是否成功@Componentpublic class DispatchJobHandler &#123;        @XxlJob(&quot;firstJobHandler&quot;)    public void testJobHandler() &#123;        System.out.println(&quot;xxl-job项目集成测试&quot;);    &#125;&#125;


测试第一步，启动相关服务

调度中心
执行器项目服务

第二步，在调度中心创建任务
第三步，启动任务
测试的时候遇到点小问题：

先运行调度中心再运行项目
失败要留意xxl的错误日志，哪里有问题就删哪里

封装XXL-JOB客户端调度中心创建任务方法在xxl-job-admin中的controller中创建
JobInfoController把原来的添加删除修改任务替换
//自定义任务操作的方法//添加任务@RequestMapping(&quot;/addJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; addJobInfo(@RequestBody XxlJobInfo jobInfo) &#123;	return xxlJobService.add(jobInfo);&#125;//删除任务@RequestMapping(&quot;/removeJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; removeJob(@RequestBody XxlJobInfo jobInfo) &#123;	return xxlJobService.remove(jobInfo.getId());&#125;//修改任务@RequestMapping(&quot;/updateJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; updateJob(@RequestBody XxlJobInfo jobInfo) &#123;	return xxlJobService.update(jobInfo);&#125;//停止任务@RequestMapping(&quot;/stopJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; pauseJob(@RequestBody XxlJobInfo jobInfo) &#123;	return xxlJobService.stop(jobInfo.getId());&#125;//启动任务@RequestMapping(&quot;/startJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; startJob(@RequestBody XxlJobInfo jobInfo) &#123;	return xxlJobService.start(jobInfo.getId());&#125;//添加并启动任务@RequestMapping(&quot;/addAndStartJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; addAndStartJob(@RequestBody XxlJobInfo jobInfo) &#123;	ReturnT&lt;String&gt; result = xxlJobService.add(jobInfo);	String content = result.getContent();	int id = Integer.parseInt(content);	xxlJobService.start(id);	//立即执行一次	JobTriggerPoolHelper.trigger(id, TriggerTypeEnum.MANUAL, -1, null, jobInfo.getExecutorParam(), &quot;&quot;);	return result;&#125;


执行器项目配置文件添加任务方法
修改nacos配置文件 service-dispatch-dev.yaml
在job.admin下client:  jobGroupId: 1  addUrl: $&#123;xxl.job.admin.addresses&#125;/jobinfo/addJob  removeUrl: $&#123;xxl.job.admin.addresses&#125;/jobinfo/removeJob  startJobUrl: $&#123;xxl.job.admin.addresses&#125;/jobinfo/startJob  stopJobUrl: $&#123;xxl.job.admin.addresses&#125;/jobinfo/stopJob  addAndStartUrl: $&#123;xxl.job.admin.addresses&#125;/jobinfo/addAndStartJob

添加相关配置类service-dispatch
创建配置类，读取配置文件里面的调用的调度中心的操作方法@Data@Component@ConfigurationProperties(prefix = &quot;xxl.job.client&quot;)public class XxlJobClientConfig &#123;    private Integer jobGroupId;    private String addUrl;    private String removeUrl;    private String startJobUrl;    private String stopJobUrl;    private String addAndStartUrl;&#125;


创建客户端类，编写调用调度中心里面的方法import com.alibaba.fastjson.JSONObject;import com.atguigu.daijia.common.execption.GuiguException;import com.atguigu.daijia.common.result.ResultCodeEnum;import com.atguigu.daijia.dispatch.xxl.config.XxlJobClientConfig;import com.atguigu.daijia.model.entity.dispatch.XxlJobInfo;import lombok.SneakyThrows;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;@Slf4j@Componentpublic class XxlJobClient &#123;    @Autowired    private XxlJobClientConfig xxlJobClientConfig;    //客户端调用服务端里面的方法    @Autowired    private RestTemplate restTemplate;    @SneakyThrows    public Long addJob(String executorHandler, String param, String corn, String desc)&#123;        XxlJobInfo xxlJobInfo = new XxlJobInfo();        xxlJobInfo.setJobGroup(xxlJobClientConfig.getJobGroupId());        xxlJobInfo.setJobDesc(desc);        xxlJobInfo.setAuthor(&quot;qy&quot;);        xxlJobInfo.setScheduleType(&quot;CRON&quot;);        xxlJobInfo.setScheduleConf(corn);        xxlJobInfo.setGlueType(&quot;BEAN&quot;);        xxlJobInfo.setExecutorHandler(executorHandler);        xxlJobInfo.setExecutorParam(param);        xxlJobInfo.setExecutorRouteStrategy(&quot;FIRST&quot;);        xxlJobInfo.setExecutorBlockStrategy(&quot;SERIAL_EXECUTION&quot;);        xxlJobInfo.setMisfireStrategy(&quot;FIRE_ONCE_NOW&quot;);        xxlJobInfo.setExecutorTimeout(0);        xxlJobInfo.setExecutorFailRetryCount(0);        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;XxlJobInfo&gt; request = new HttpEntity&lt;&gt;(xxlJobInfo, headers);        String url = xxlJobClientConfig.getAddUrl();        ResponseEntity&lt;JSONObject&gt; response =                restTemplate.postForEntity(url, request, JSONObject.class);        if(response.getStatusCode().value() == 200 &amp;&amp; response.getBody().getIntValue(&quot;code&quot;) == 200) &#123;            log.info(&quot;增加xxl执行任务成功,返回信息:&#123;&#125;&quot;, response.getBody().toJSONString());            //content为任务id            return response.getBody().getLong(&quot;content&quot;);        &#125;        log.info(&quot;调用xxl增加执行任务失败:&#123;&#125;&quot;, response.getBody().toJSONString());        throw new GuiguException(ResultCodeEnum.DATA_ERROR);    &#125;    public Boolean startJob(Long jobId) &#123;        XxlJobInfo xxlJobInfo = new XxlJobInfo();        xxlJobInfo.setId(jobId.intValue());        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;XxlJobInfo&gt; request = new HttpEntity&lt;&gt;(xxlJobInfo, headers);        String url = xxlJobClientConfig.getStartJobUrl();        ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(url, request, JSONObject.class);        if(response.getStatusCode().value() == 200 &amp;&amp; response.getBody().getIntValue(&quot;code&quot;) == 200) &#123;            log.info(&quot;启动xxl执行任务成功:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());            return true;        &#125;        log.info(&quot;启动xxl执行任务失败:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());        throw new GuiguException(ResultCodeEnum.DATA_ERROR);    &#125;    public Boolean stopJob(Long jobId) &#123;        XxlJobInfo xxlJobInfo = new XxlJobInfo();        xxlJobInfo.setId(jobId.intValue());        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;XxlJobInfo&gt; request = new HttpEntity&lt;&gt;(xxlJobInfo, headers);        String url = xxlJobClientConfig.getStopJobUrl();        ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(url, request, JSONObject.class);        if(response.getStatusCode().value() == 200 &amp;&amp; response.getBody().getIntValue(&quot;code&quot;) == 200) &#123;            log.info(&quot;停止xxl执行任务成功:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());            return true;        &#125;        log.info(&quot;停止xxl执行任务失败:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());        throw new GuiguException(ResultCodeEnum.DATA_ERROR);    &#125;    public Boolean removeJob(Long jobId) &#123;        XxlJobInfo xxlJobInfo = new XxlJobInfo();        xxlJobInfo.setId(jobId.intValue());        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;XxlJobInfo&gt; request = new HttpEntity&lt;&gt;(xxlJobInfo, headers);        String url = xxlJobClientConfig.getRemoveUrl();        ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(url, request, JSONObject.class);        if(response.getStatusCode().value() == 200 &amp;&amp; response.getBody().getIntValue(&quot;code&quot;) == 200) &#123;            log.info(&quot;删除xxl执行任务成功:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());            return true;        &#125;        log.info(&quot;删除xxl执行任务失败:&#123;&#125;,返回信息:&#123;&#125;&quot;, jobId, response.getBody().toJSONString());        throw new GuiguException(ResultCodeEnum.DATA_ERROR);    &#125;    //添加并启动任务    public Long addAndStart(String executorHandler, String param, String corn, String desc) &#123;        XxlJobInfo xxlJobInfo = new XxlJobInfo();        xxlJobInfo.setJobGroup(xxlJobClientConfig.getJobGroupId());        xxlJobInfo.setJobDesc(desc);        xxlJobInfo.setAuthor(&quot;qy&quot;);        xxlJobInfo.setScheduleType(&quot;CRON&quot;);        xxlJobInfo.setScheduleConf(corn);        xxlJobInfo.setGlueType(&quot;BEAN&quot;);        xxlJobInfo.setExecutorHandler(executorHandler);        xxlJobInfo.setExecutorParam(param);        xxlJobInfo.setExecutorRouteStrategy(&quot;FIRST&quot;);        xxlJobInfo.setExecutorBlockStrategy(&quot;SERIAL_EXECUTION&quot;);        xxlJobInfo.setMisfireStrategy(&quot;FIRE_ONCE_NOW&quot;);        xxlJobInfo.setExecutorTimeout(0);        xxlJobInfo.setExecutorFailRetryCount(0);        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;XxlJobInfo&gt; request = new HttpEntity&lt;&gt;(xxlJobInfo, headers);        //获取调度中心请求路径        String url = xxlJobClientConfig.getAddAndStartUrl();        //restTemplate        ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(url, request, JSONObject.class);        if(response.getStatusCode().value() == 200 &amp;&amp; response.getBody().getIntValue(&quot;code&quot;) == 200) &#123;            log.info(&quot;增加并开始执行xxl任务成功,返回信息:&#123;&#125;&quot;, response.getBody().toJSONString());            //content为任务id            return response.getBody().getLong(&quot;content&quot;);        &#125;        log.info(&quot;增加并开始执行xxl任务失败:&#123;&#125;&quot;, response.getBody().toJSONString());        throw new GuiguException(ResultCodeEnum.DATA_ERROR);    &#125;&#125;

启动类配置RestTemplate直接把RestTemplate写在启动类里
@SpringBootApplication  @EnableDiscoveryClient  @EnableFeignClients  public class ServiceDispatchApplication &#123;        public static void main(String[] args) &#123;          SpringApplication.run(ServiceDispatchApplication.class, args);      &#125;        @Bean      public RestTemplate restTemplate() &#123;          return new RestTemplate();      &#125;  &#125;

创建并启动任务接口service-dispatch
controller
// 创建并启动任务调度方法@Operation(summary = &quot;添加并开始新订单任务调度&quot;)@PostMapping(&quot;/addAndStartTask&quot;)public Result&lt;Long&gt; addAndStartTask(@RequestBody NewOrderTaskVo newOrderTaskVo) &#123;	Long id = newOrderService.addAndStartTask(newOrderTaskVo);	return Result.ok(id);&#125;

service
// 添加并开始新订单任务调度@Overridepublic Long addAndStartTask(NewOrderTaskVo newOrderTaskVo) &#123;	// 判断当前订单是否开启任务调度	LambdaQueryWrapper&lt;OrderJob&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();	wrapper.eq(OrderJob::getOrderId, newOrderTaskVo.getOrderId());	OrderJob orderJob = orderJobMapper.selectOne(wrapper);	// 没有启动，进行操作	if(orderJob == null)&#123;		//创建并启动任务调度		//String executorHandler 执行任务job方法		// String param		// String corn 执行cron表达式		// String desc 描述信息		Long id = xxlJobClient.addAndStart(&quot;newOrderTaskHandler&quot;,				&quot;&quot;, &quot;0 0/1 * * * ?&quot;,				&quot;新创建订单任务调度：&quot; + newOrderTaskVo.getOrderId());		orderJob = new OrderJob();		orderJob.setOrderId(newOrderTaskVo.getOrderId());		orderJob.setJobId(id);		orderJob.setParameter(JSONObject.toJSONString(newOrderTaskVo));		orderJobMapper.insert(orderJob);	&#125;	return orderJob.getJobId();&#125;

远程调用service-clientservice-dispatch-client
@FeignClient(value = &quot;service-dispatch&quot;)public interface NewOrderFeignClient &#123;    /**     * 添加新订单任务     * @param newOrderDispatchVo     * @return     */    @PostMapping(&quot;/dispatch/newOrder/addAndStartTask&quot;)    Result&lt;Long&gt; addAndStartTask(@RequestBody NewOrderTaskVo newOrderDispatchVo);&#125;


开发具体任务job方法JobHandler
public class JobHandler &#123;    @Autowired    private XxlJobLogMapper xxlJobLogMapper;        @Autowired    private NewOrderService newOrderService;        @XxlJob(&quot;newOrderTaskHandler&quot;)    public void newOrderTaskHandler() &#123;        //记录任务调度日志        XxlJobLog xxlJobLog = new XxlJobLog();        xxlJobLog.setJobId(XxlJobHelper.getJobId());        long startTime = System.currentTimeMillis();        try &#123;            //执行任务：搜索附近代驾司机            newOrderService.executeTask(XxlJobHelper.getJobId());            //成功状态            xxlJobLog.setStatus(1);        &#125; catch (Exception e) &#123;            //失败状态            xxlJobLog.setStatus(0);            xxlJobLog.setError(e.getMessage());            e.printStackTrace();        &#125; finally &#123;            long times = System.currentTimeMillis()- startTime;            //TODO 完善long            xxlJobLog.setTimes((int)times);            xxlJobLogMapper.insert(xxlJobLog);        &#125;    &#125;&#125;


远程调用service-driver-clientLocationFeignClient// 搜索附近满足条件的司机@PostMapping(&quot;/map/location/searchNearByDriver&quot;)public Result&lt;List&lt;NearByDriverVo&gt;&gt; searchNearByDriver(@RequestBody SearchNearByDriverForm searchNearByDriverForm);

service-dispatchNewOrderServiceImpl
@Autowiredprivate LocationFeignClient locationFeignClient;@Autowiredprivate OrderInfoFeignClient orderInfoFeignClient;@Autowiredprivate RedisTemplate redisTemplate;// 搜索附件司机@Overridepublic void executeTask(long jobId) &#123;	// 根据jobid查询当前任务是否已经创建	LambdaQueryWrapper&lt;OrderJob&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();	wrapper.eq(OrderJob::getJobId, jobId);	OrderJob orderJob = orderJobMapper.selectOne(wrapper);	if(orderJob == null)&#123;		return;	&#125;	// 查询订单状态，如果是接单状态，继续执行，否则停止	String parameter = orderJob.getParameter();	NewOrderTaskVo newOrderTaskVo = JSONObject.parseObject(parameter, NewOrderTaskVo.class);	Integer status = orderInfoFeignClient.getOrderStatus(newOrderTaskVo.getOrderId()).getData();	if(status.intValue() != OrderStatus.WAITING_ACCEPT.getStatus().intValue())&#123;		xxlJobClient.stopJob(jobId);		return;	&#125;	// 远程调用，查询正在接单的司机集合	SearchNearByDriverForm from = new SearchNearByDriverForm();	SearchNearByDriverForm searchNearByDriverForm = new SearchNearByDriverForm();	searchNearByDriverForm.setLongitude(newOrderTaskVo.getStartPointLongitude());	searchNearByDriverForm.setLatitude(newOrderTaskVo.getStartPointLatitude());	List&lt;NearByDriverVo&gt; result = locationFeignClient.searchNearByDriver(from).getData();	// 遍历满足条件的司机集合，为每个司机创建临时队列，存储新订单信息	result.forEach(driver -&gt; &#123;		String repeatKey =				RedisConstant.DRIVER_ORDER_REPEAT_LIST+newOrderTaskVo.getOrderId();		Boolean isMember = redisTemplate.opsForSet().isMember(repeatKey, driver.getDriverId());		if(!isMember)&#123;			// 把订单信息推送刚给满足条件的司机			redisTemplate.opsForSet().add(parameter, driver.getDriverId());			// 设置过期时间15分钟(一分钟等待)			redisTemplate.expire(repeatKey,					RedisConstant.DRIVER_ORDER_REPEAT_LIST_EXPIRES_TIME,					TimeUnit.MINUTES);			NewOrderDataVo newOrderDataVo = new NewOrderDataVo();			newOrderDataVo.setOrderId(newOrderTaskVo.getOrderId());			newOrderDataVo.setStartLocation(newOrderTaskVo.getStartLocation());			newOrderDataVo.setEndLocation(newOrderTaskVo.getEndLocation());			newOrderDataVo.setExpectAmount(newOrderTaskVo.getExpectAmount());			newOrderDataVo.setExpectDistance(newOrderTaskVo.getExpectDistance());			newOrderDataVo.setExpectTime(newOrderTaskVo.getExpectTime());			newOrderDataVo.setFavourFee(newOrderTaskVo.getFavourFee());			newOrderDataVo.setDistance(driver.getDistance());			newOrderDataVo.setCreateTime(newOrderTaskVo.getCreateTime());			// 新订单保存司机的临时队列			String key = RedisConstant.DRIVER_ORDER_TEMP_LIST+driver.getDriverId();			redisTemplate.opsForList().leftPush(key, JSONObject.toJSONString(newOrderDataVo));			// 设置过期时间，一分钟			redisTemplate.expire(key, RedisConstant.DRIVER_ORDER_TEMP_LIST_EXPIRES_TIME, TimeUnit.MINUTES);		&#125;	&#125;);&#125;

乘客下单添加任务调度web-customer补充之前OrderServiceImpl里写的查询附近可以接单司机
@Autowired  private NewOrderFeignClient newOrderFeignClient;@Overridepublic Long submitOrder(SubmitOrderForm submitOrderForm) &#123;	//1 重新计算驾驶线路	CalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();	BeanUtils.copyProperties(submitOrderForm,submitOrderForm);	Result&lt;DrivingLineVo&gt; drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);	DrivingLineVo drivingLineVo = drivingLineVoResult.getData();	//2 重新订单费用	FeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();	calculateOrderFeeForm.setDistance(drivingLineVo.getDistance());	calculateOrderFeeForm.setStartTime(new Date());	calculateOrderFeeForm.setWaitMinute(0);	Result&lt;FeeRuleResponseVo&gt; feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);	FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();	//封装数据	OrderInfoForm orderInfoForm = new OrderInfoForm();	BeanUtils.copyProperties(submitOrderForm,orderInfoForm);	orderInfoForm.setExpectDistance(drivingLineVo.getDistance());	orderInfoForm.setExpectAmount(feeRuleResponseVo.getTotalAmount());	Result&lt;Long&gt; orderInfoResult = orderInfoFeignClient.saveOrderInfo(orderInfoForm);	Long orderId = orderInfoResult.getData();	// 任务调度：查询附近可以接单司机	NewOrderTaskVo newOrderTaskVo = new NewOrderTaskVo();	newOrderTaskVo.setOrderId(orderId);	newOrderTaskVo.setStartLocation(orderInfoForm.getStartLocation());	newOrderTaskVo.setStartPointLongitude(orderInfoForm.getStartPointLongitude());	newOrderTaskVo.setStartPointLatitude(orderInfoForm.getStartPointLatitude());	newOrderTaskVo.setEndLocation(orderInfoForm.getEndLocation());	newOrderTaskVo.setEndPointLongitude(orderInfoForm.getEndPointLongitude());	newOrderTaskVo.setEndPointLatitude(orderInfoForm.getEndPointLatitude());	newOrderTaskVo.setExpectAmount(orderInfoForm.getExpectAmount());	newOrderTaskVo.setExpectDistance(orderInfoForm.getExpectDistance());	newOrderTaskVo.setExpectTime(drivingLineVo.getDuration());	newOrderTaskVo.setFavourFee(orderInfoForm.getFavourFee());	newOrderTaskVo.setCreateTime(new Date());	Long jobId = newOrderFeignClient.addAndStartTask(newOrderTaskVo).getData();	return orderId;&#125;

司机获取最新订单数据service-dispatch
查询最新订单和清空司机队列数据NewOrderController
@Operation(summary = &quot;查询司机新订单数据&quot;)@GetMapping(&quot;/findNewOrderQueueData/&#123;driverId&#125;&quot;)public Result&lt;List&lt;NewOrderDataVo&gt;&gt; findNewOrderQueueData(@PathVariable Long driverId) &#123;	return Result.ok(newOrderService.findNewOrderQueueData(driverId));&#125;@Operation(summary = &quot;清空新订单队列数据&quot;)@GetMapping(&quot;/clearNewOrderQueueData/&#123;driverId&#125;&quot;)public Result&lt;Boolean&gt; clearNewOrderQueueData(@PathVariable Long driverId) &#123;	return Result.ok(newOrderService.clearNewOrderQueueData(driverId));&#125;

NewOrderServiceImpl
//获取最新订单@Overridepublic List&lt;NewOrderDataVo&gt; findNewOrderQueueData(Long driverId) &#123;    List&lt;NewOrderDataVo&gt; list = new ArrayList&lt;&gt;();    String key = RedisConstant.DRIVER_ORDER_TEMP_LIST + driverId;    Long size = redisTemplate.opsForList().size(key);    if(size &gt; 0) &#123;        for (int i = 0; i &lt; size; i++) &#123;            String content = (String)redisTemplate.opsForList().leftPop(key);            NewOrderDataVo newOrderDataVo = JSONObject.parseObject(content,NewOrderDataVo.class);            list.add(newOrderDataVo);        &#125;    &#125;    return list;&#125;//清空队列数据@Overridepublic Boolean clearNewOrderQueueData(Long driverId) &#123;    String key = RedisConstant.DRIVER_ORDER_TEMP_LIST + driverId;    redisTemplate.delete(key);    return true;&#125;

远程调用service-dispatch
NewOrderFeignClient
// 查询司机新订单数据@GetMapping(&quot;/dispatch/newOrder/findNewOrderQueueData/&#123;driverId&#125;&quot;)Result&lt;List&lt;NewOrderDataVo&gt;&gt; findNewOrderQueueData(@PathVariable(&quot;driverId&quot;) Long driverId);// 清空新订单队列数据@GetMapping(&quot;/dispatch/newOrder/clearNewOrderQueueData/&#123;driverId&#125;&quot;)Result&lt;Boolean&gt; clearNewOrderQueueData(@PathVariable(&quot;driverId&quot;) Long driverId);

司机web端调用OrderController
@Operation(summary = &quot;查询司机新订单数据&quot;)  @LoginDetection  @GetMapping(&quot;/findNewOrderQueueData&quot;)  public Result&lt;List&lt;NewOrderDataVo&gt;&gt; findNewOrderQueueData() &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.findNewOrderQueueData(driverId));  &#125;

service
@Autowired  private NewOrderFeignClient newOrderFeignClient;@Override  public List&lt;NewOrderDataVo&gt; findNewOrderQueueData(Long driverId) &#123;      return newOrderFeignClient.findNewOrderQueueData(driverId).getData();  &#125;

司机接单需求
乘客下单后，新订单信息已经放在司机临时队列，然后可以开始接单了

首先，司机登录、认证（身份证、驾驶证、创建人脸模型）第二，司机每天接单前都需要人脸识别第三，司机开始接单，更新接单状态第四，司机接单后，删除司机之前存储在redis里面的位置信息第五，司机接单后，清空临时队列新订单信息
查找司机端当前订单设定是接单去需要验证司机是否有未完成的订单，暂时不管

后续完成，暂时跳过

@Operation(summary = &quot;查找司机端当前订单&quot;)  @LoginDetection  @GetMapping(&quot;/searchDriverCurrentOrder&quot;)  public Result&lt;CurrentOrderInfoVo&gt; searchDriverCurrentOrder() &#123;      CurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();      // TODO 后续完善      currentOrderInfoVo.setIsHasCurrentOrder(false);      return Result.ok(currentOrderInfoVo);  &#125;

判断司机在当日是否人脸识别service-driverDriverInfoController
@Operation(summary = &quot;判断司机当日是否进行过人脸识别&quot;)  @GetMapping(&quot;/isFaceRecognition/&#123;driverId&#125;&quot;)  Result&lt;Boolean&gt; isFaceRecognition(@PathVariable(&quot;driverId&quot;) Long driverId) &#123;      return Result.ok(driverInfoService.isFaceRecognition(driverId));  &#125;

service
// 判断司机当日是否进行过人脸识别  @Override  public Boolean isFaceRecognition(Long driverId) &#123;      //根据司机id + 当日日期进行查询      LambdaQueryWrapper&lt;DriverFaceRecognition&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(DriverFaceRecognition::getDriverId,driverId);      // 年-月-日 格式      wrapper.eq(DriverFaceRecognition::getFaceDate,new DateTime().toString(&quot;yyyy-MM-dd&quot;));      //调用mapper方法      Long count = driverFaceRecognitionMapper.selectCount(wrapper);        return count != 0;  &#125;

远程调用
DriverInfoFeignClient
// 判断司机当日是否进行过人脸识别  @GetMapping(&quot;/driver/info/isFaceRecognition/&#123;driverId&#125;&quot;)  Result&lt;Boolean&gt; isFaceRecognition(@PathVariable(&quot;driverId&quot;) Long driverId);


web端调用DriverController
@Operation(summary = &quot;判断司机当日是否进行过人脸识别&quot;)  @LoginDetection  @GetMapping(&quot;/isFaceRecognition&quot;)  Result&lt;Boolean&gt; isFaceRecognition() &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(driverService.isFaceRecognition(driverId));  &#125;

service
// 判断司机当日是否进行过人脸识别  @Override  public Boolean isFaceRecognition(Long driverId) &#123;      Result&lt;Boolean&gt; faceRecognition = driverInfoFeignClient.isFaceRecognition(driverId);      return faceRecognition.getData();  &#125;

人脸识别接口
进行人脸识别，基于腾讯云实现

之前创建人脸识别模型，基于之前创建人脸模型完成当前识别功能

找到腾讯云文档1：照片比对https://console.cloud.tencent.com/api/explorer?Product=iai&amp;Version=2020-03-03&amp;Action=VerifyFace

找到腾讯云文档2：人脸静态活体检测https://console.cloud.tencent.com/api/explorer?Product=iai&amp;Version=2020-03-03&amp;Action=DetectLiveFace


service-driverDriverInfoController
@Operation(summary = &quot;验证司机人脸&quot;)@PostMapping(&quot;/verifyDriverFace&quot;)public Result&lt;Boolean&gt; verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm) &#123;    return Result.ok(driverInfoService.verifyDriverFace(driverFaceModelForm));&#125;

service
// 验证司机人脸  @Override  public Boolean verifyDriverFace(DriverFaceModelForm driverFaceModelForm) &#123;      // 照片比对      try&#123;          // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密          // 代码泄露可能会导致 SecretId 和 SecretKey 泄露，并威胁账号下所有资源的安全性          // 以下代码示例仅供参考，建议采用更安全的方式来使用密钥          // 请参见：https://cloud.tencent.com/document/product/1278/85305          // 密钥可前往官网控制台 https://console.cloud.tencent.com/cam/capi 进行获取          Credential cred = new Credential(tencentCloudProperties.getSecretId(),                  tencentCloudProperties.getSecretKey());          // 使用临时密钥示例          // Credential cred = new Credential(&quot;SecretId&quot;, &quot;SecretKey&quot;, &quot;Token&quot;);          // 实例化一个http选项，可选的，没有特殊需求可以跳过          HttpProfile httpProfile = new HttpProfile();          httpProfile.setEndpoint(&quot;iai.tencentcloudapi.com&quot;);          // 实例化一个client选项，可选的，没有特殊需求可以跳过          ClientProfile clientProfile = new ClientProfile();          clientProfile.setHttpProfile(httpProfile);            // 实例化要请求产品的client对象,clientProfile是可选的          IaiClient client = new IaiClient(cred,                  tencentCloudProperties.getRegion(), clientProfile);          // 实例化一个请求对象,每个接口都会对应一个request对象          VerifyFaceRequest req = new VerifyFaceRequest();          // 设置相关参数          req.setImage(driverFaceModelForm.getImageBase64());          req.setPersonId(String.valueOf(driverFaceModelForm.getDriverId()));            // 返回的resp是一个VerifyFaceResponse的实例，与请求对象对应          VerifyFaceResponse resp = client.VerifyFace(req);          // 输出json格式的字符串回包          System.out.println(AbstractModel.toJsonString(resp));          if(resp.getIsMatch())&#123;              // 静态活体检测              Boolean isSuccess = this.detectLiveFace(driverFaceModelForm.getImageBase64());              if(isSuccess)&#123;                  // 都没问题，添加塑胶到认证表中                  DriverFaceRecognition driverFaceRecognition = new DriverFaceRecognition();                  driverFaceRecognition.setDriverId(driverFaceModelForm.getDriverId());                  driverFaceRecognition.setFaceDate(new Date());                  driverFaceRecognitionMapper.insert(driverFaceRecognition);                  return true;              &#125;          &#125;      &#125; catch (TencentCloudSDKException e) &#123;          System.out.println(e.toString());      &#125;        throw new GuiguException(ResultCodeEnum.DATA_ERROR);  &#125;    //人脸静态活体检测  private Boolean detectLiveFace(String imageBase64) &#123;      try&#123;          // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密          // 代码泄露可能会导致 SecretId 和 SecretKey 泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考，建议采用更安全的方式来使用密钥，请参见：https://cloud.tencent.com/document/product/1278/85305          // 密钥可前往官网控制台 https://console.cloud.tencent.com/cam/capi 进行获取          Credential cred = new Credential(tencentCloudProperties.getSecretId(),                  tencentCloudProperties.getSecretKey());          // 实例化一个http选项，可选的，没有特殊需求可以跳过          HttpProfile httpProfile = new HttpProfile();          httpProfile.setEndpoint(&quot;iai.tencentcloudapi.com&quot;);          // 实例化一个client选项，可选的，没有特殊需求可以跳过          ClientProfile clientProfile = new ClientProfile();          clientProfile.setHttpProfile(httpProfile);          // 实例化要请求产品的client对象,clientProfile是可选的          IaiClient client = new IaiClient(cred, tencentCloudProperties.getRegion(),                  clientProfile);          // 实例化一个请求对象,每个接口都会对应一个request对象          DetectLiveFaceRequest req = new DetectLiveFaceRequest();          req.setImage(imageBase64);          // 返回的resp是一个DetectLiveFaceResponse的实例，与请求对象对应          DetectLiveFaceResponse resp = client.DetectLiveFace(req);          // 输出json格式的字符串回包          System.out.println(DetectLiveFaceResponse.toJsonString(resp));          if(resp.getIsLiveness()) &#123;              return true;          &#125;      &#125; catch (TencentCloudSDKException e) &#123;          System.out.println(e.toString());      &#125;      return false;  &#125;

远程调用 service-driver-clientDriverInfoFeignClient
// 验证司机人脸  @PostMapping(&quot;/driver/info/verifyDriverFace&quot;)  Result&lt;Boolean&gt; verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm);

web-driverDriverController
@Operation(summary = &quot;验证司机人脸&quot;)  @LoginDetection  @PostMapping(&quot;/verifyDriverFace&quot;)  public Result&lt;Boolean&gt; verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm) &#123;      driverFaceModelForm.setDriverId(AuthContextHolder.getUserId());      return Result.ok(driverService.verifyDriverFace(driverFaceModelForm));  &#125;

service
// 验证司机人脸  @Override  public Boolean verifyDriverFace(DriverFaceModelForm driverFaceModelForm) &#123;      Result&lt;Boolean&gt; booleanResult = driverInfoFeignClient.verifyDriverFace(driverFaceModelForm);      return booleanResult.getData();  &#125;


更新司机接单状态DriverInfoController
@Operation(summary = &quot;更新接单状态&quot;)  @GetMapping(&quot;/updateServiceStatus/&#123;driverId&#125;/&#123;status&#125;&quot;)  public Result&lt;Boolean&gt; updateServiceStatus(@PathVariable Long driverId, @PathVariable Integer status) &#123;      return Result.ok(driverInfoService.updateServiceStatus(driverId, status));  &#125;

service
@Override  public Boolean updateServiceStatus(Long driverId, Integer status) &#123;      LambdaQueryWrapper&lt;DriverSet&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(DriverSet::getDriverId,driverId);      DriverSet driverSet = new DriverSet();      driverSet.setServiceStatus(status);      driverSetMapper.update(driverSet,wrapper);      return true;  &#125;

远程调用DriverInfoFeignClient
// 更新接单状态  @GetMapping(&quot;/driver/info/updateServiceStatus/&#123;driverId&#125;/&#123;status&#125;&quot;)  Result&lt;Boolean&gt; updateServiceStatus(@PathVariable(&quot;driverId&quot;) Long driverId, @PathVariable(&quot;status&quot;) Integer status);

开启接单服务web接口在web-driver中进行编写
司机开启接单后，上传位置信息到redis的GEO，才能被任务调度搜索到司机信息，开始抢单
DriverController@Operation(summary = &quot;开始接单服务&quot;)  @LoginDetection  @GetMapping(&quot;/startService&quot;)  public Result&lt;Boolean&gt; startService() &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(driverService.startService(driverId));  &#125;

DriverServiceImpl@Autowired  private LocationFeignClient locationFeignClient;    @Autowired  private NewOrderFeignClient newOrderFeignClient;// 开始接单服务  @Override  public Boolean startService(Long driverId) &#123;      //1 判断完成认证      DriverLoginVo driverLoginVo = driverInfoFeignClient.getDriverLoginInfo(driverId).getData();      if(driverLoginVo.getAuthStatus()!=2) &#123;          throw new GuiguException(ResultCodeEnum.AUTH_ERROR);      &#125;        //2 判断当日是否人脸识别      Boolean isFace = driverInfoFeignClient.isFaceRecognition(driverId).getData();      if(!isFace) &#123;          throw new GuiguException(ResultCodeEnum.FACE_ERROR);      &#125;        //3 更新订单状态 1 开始接单      driverInfoFeignClient.updateServiceStatus(driverId,1);        //4 删除redis司机位置信息      locationFeignClient.removeDriverLocation(driverId);        //5 清空司机临时队列数据      newOrderFeignClient.clearNewOrderQueueData(driverId);      return true;  &#125;

停止接单服务web接口DriverController
@Operation(summary = &quot;停止接单服务&quot;)  @LoginDetection  @GetMapping(&quot;/stopService&quot;)  public Result&lt;Boolean&gt; stopService() &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(driverService.stopService(driverId));  &#125;

DriverServiceImpl
//停止接单服务  @Override  public Boolean stopService(Long driverId) &#123;      //更新司机的接单状态 0       driverInfoFeignClient.updateServiceStatus(driverId,0);        //删除司机位置信息      locationFeignClient.removeDriverLocation(driverId);        //清空司机临时队列      newOrderFeignClient.clearNewOrderQueueData(driverId);      return true;  &#125;


司机抢单抢单接口微服务抢单接口service-order模块内
OrderInfoController
@Operation(summary = &quot;司机抢单&quot;)  @GetMapping(&quot;/robNewOrder/&#123;driverId&#125;/&#123;orderId&#125;&quot;)  public Result&lt;Boolean&gt; robNewOrder(@PathVariable Long driverId, @PathVariable Long orderId) &#123;      return Result.ok(orderInfoService.robNewOrder(driverId, orderId));  &#125;


在OrderInfoServiceImpl之前保存订单 方法修改
@Autowired  private RedisTemplate redisTemplate;//乘客下单  @Override  public Long saveOrderInfo(OrderInfoForm orderInfoForm) &#123;      //order_info添加订单数据      OrderInfo orderInfo = new OrderInfo();      BeanUtils.copyProperties(orderInfoForm,orderInfo);      //订单号      String orderNo = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);      orderInfo.setOrderNo(orderNo);      //订单状态      orderInfo.setStatus(OrderStatus.WAITING_ACCEPT.getStatus());      orderInfoMapper.insert(orderInfo);        //记录日志      this.log(orderInfo.getId(),orderInfo.getStatus());        //向redis添加标识      //接单标识，标识不存在了说明不在等待接单状态了      redisTemplate.opsForValue().set(RedisConstant.ORDER_ACCEPT_MARK,              &quot;0&quot;, RedisConstant.ORDER_ACCEPT_MARK_EXPIRES_TIME, TimeUnit.MINUTES);        return orderInfo.getId();  &#125;

OrderInfoServiceImpl新增司机抢单方法
//司机抢单  @Override  public Boolean robNewOrder(Long driverId, Long orderId) &#123;      //判断订单是否存在，通过Redis，减少数据库压力      if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) &#123;          //抢单失败          throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);      &#125;        //司机抢单      //修改order_info表订单状态值2：已经接单 + 司机id + 司机接单时间      //修改条件：根据订单id      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId,orderId);      OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);      //设置      orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());      orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());      orderInfo.setDriverId(driverId);      orderInfo.setAcceptTime(new Date());      //调用方法修改      int rows = orderInfoMapper.updateById(orderInfo);      if(rows != 1) &#123;          //抢单失败          throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);      &#125;        //删除抢单标识      redisTemplate.delete(RedisConstant.ORDER_ACCEPT_MARK);      return true;  &#125;


远程调用
/**   * 司机抢单   * @param driverId   * @param orderId   * @return   */  @GetMapping(&quot;/order/info/robNewOrder/&#123;driverId&#125;/&#123;orderId&#125;&quot;)  Result&lt;Boolean&gt; robNewOrder(@PathVariable(&quot;driverId&quot;) Long driverId, @PathVariable(&quot;orderId&quot;) Long orderId);

司机web端接口OrderController
@Operation(summary = &quot;司机抢单&quot;)  @LoginDetection  @GetMapping(&quot;/robNewOrder/&#123;orderId&#125;&quot;)  public Result&lt;Boolean&gt; robNewOrder(@PathVariable Long orderId) &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.robNewOrder(driverId, orderId));  &#125;

service
// 司机抢单  @Override  public Boolean robNewOrder(Long driverId, Long orderId) &#123;      Result&lt;Boolean&gt; booleanResult = orderInfoFeignClient.robNewOrder(driverId, orderId);      return booleanResult.getData();  &#125;

添加Redisson分布式锁到司机抢单在service里service-order中OrderInfoServiceImpl添加分布式锁
修改之前写的robNewOrder
@Autowired  private RedissonClient redissonClient;//司机抢单  @Override  public Boolean robNewOrder(Long driverId, Long orderId) &#123;      //判断订单是否存在，通过Redis，减少数据库压力      if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) &#123;          //抢单失败          throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);      &#125;        //创建锁      RLock lock = redissonClient.getLock(RedisConstant.ROB_NEW_ORDER_LOCK + orderId);        try &#123;          //获取锁          boolean flag = lock.tryLock(RedisConstant.ROB_NEW_ORDER_LOCK_WAIT_TIME,                  RedisConstant.ROB_NEW_ORDER_LOCK_LEASE_TIME,                   TimeUnit.SECONDS);          if(flag) &#123;              if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) &#123;                  //抢单失败                  throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);              &#125;              //司机抢单              //修改order_info表订单状态值2：已经接单 + 司机id + 司机接单时间              //修改条件：根据订单id              LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();              wrapper.eq(OrderInfo::getId,orderId);              OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);              //设置              orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());              orderInfo.setDriverId(driverId);              orderInfo.setAcceptTime(new Date());              //调用方法修改              int rows = orderInfoMapper.updateById(orderInfo);              if(rows != 1) &#123;                  //抢单失败                  throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);              &#125;                //删除抢单标识              redisTemplate.delete(RedisConstant.ORDER_ACCEPT_MARK);          &#125;      &#125;catch (Exception e) &#123;          //抢单失败          throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);      &#125;finally &#123;          //释放          if(lock.isLocked()) &#123;              lock.unlock();          &#125;      &#125;      return true;  &#125;


订单执行（一）加载当前订单需求
无论是司机端，还是乘客端，遇到页面切换，重新登录小程序等，只要回到首页面，查看当前是否有正在执行的订单，如果有跳转到当前订单的执行页面

乘客端查找当前订单订单微服务接口
OrderInfoController@Operation(summary = &quot;乘客端查找当前订单&quot;)@GetMapping(&quot;/searchCustomerCurrentOrder/&#123;customerId&#125;&quot;)public Result&lt;CurrentOrderInfoVo&gt; searchCustomerCurrentOrder(@PathVariable Long customerId) &#123;    return Result.ok(orderInfoService.searchCustomerCurrentOrder(customerId));&#125;

OrderInfoServiceImpl
@Autowired  private RedissonClient redissonClient;//乘客端查找当前订单  @Override  public CurrentOrderInfoVo searchCustomerCurrentOrder(Long customerId) &#123;      //封装条件      //乘客id      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getCustomerId,customerId);        //各种状态      Integer[] statusArray = &#123;              OrderStatus.ACCEPTED.getStatus(),              OrderStatus.DRIVER_ARRIVED.getStatus(),              OrderStatus.UPDATE_CART_INFO.getStatus(),              OrderStatus.START_SERVICE.getStatus(),              OrderStatus.END_SERVICE.getStatus(),              OrderStatus.UNPAID.getStatus()      &#125;;      wrapper.in(OrderInfo::getStatus,statusArray);        //获取最新一条记录      wrapper.orderByDesc(OrderInfo::getId);      wrapper.last(&quot; limit 1&quot;);        //调用方法      OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);        //封装到CurrentOrderInfoVo      CurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();      if(orderInfo != null) &#123;          currentOrderInfoVo.setOrderId(orderInfo.getId());          currentOrderInfoVo.setStatus(orderInfo.getStatus());          currentOrderInfoVo.setIsHasCurrentOrder(true);      &#125; else &#123;          currentOrderInfoVo.setIsHasCurrentOrder(false);      &#125;      return currentOrderInfoVo;  &#125;

远程调用serivce-order-clientOrderInfoFeignClient
/**   * 乘客端查找当前订单   * @param customerId   * @return   */  @GetMapping(&quot;/order/info/searchCustomerCurrentOrder/&#123;customerId&#125;&quot;)  Result&lt;CurrentOrderInfoVo&gt; searchCustomerCurrentOrder(@PathVariable(&quot;customerId&quot;) Long customerId);

乘客web端接口web-customerOrderController
@Operation(summary = &quot;乘客端查找当前订单&quot;)  @LoginDetection  @GetMapping(&quot;/searchCustomerCurrentOrder&quot;)  public Result&lt;CurrentOrderInfoVo&gt; searchCustomerCurrentOrder() &#123;      Long customerId = AuthContextHolder.getUserId();      return Result.ok(orderService.searchCustomerCurrentOrder(customerId));  &#125;

OrderServiceImpl
// 乘客端查找当前订单  @Override  public CurrentOrderInfoVo searchCustomerCurrentOrder(Long customerId) &#123;      Result&lt;CurrentOrderInfoVo&gt; currentOrderInfoVoResult = orderInfoFeignClient.searchCustomerCurrentOrder(customerId);      return currentOrderInfoVoResult.getData();  &#125;

司机端查找当前订单订单微服务接口service-orderOrderInfoController
@Operation(summary = &quot;司机端查找当前订单&quot;)@GetMapping(&quot;/searchDriverCurrentOrder/&#123;driverId&#125;&quot;)public Result&lt;CurrentOrderInfoVo&gt; searchDriverCurrentOrder(@PathVariable Long driverId) &#123;    return Result.ok(orderInfoService.searchDriverCurrentOrder(driverId));&#125;

service
// 司机端查找当前订单@Overridepublic CurrentOrderInfoVo searchDriverCurrentOrder(Long driverId) &#123;	//封装条件	LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();	wrapper.eq(OrderInfo::getDriverId,driverId);	Integer[] statusArray = &#123;			OrderStatus.ACCEPTED.getStatus(),			OrderStatus.DRIVER_ARRIVED.getStatus(),			OrderStatus.UPDATE_CART_INFO.getStatus(),			OrderStatus.START_SERVICE.getStatus(),			OrderStatus.END_SERVICE.getStatus()	&#125;;	wrapper.in(OrderInfo::getStatus,statusArray);	wrapper.orderByDesc(OrderInfo::getId);	wrapper.last(&quot; limit 1&quot;);	OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);	//封装到vo	CurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();	if(null != orderInfo) &#123;		currentOrderInfoVo.setStatus(orderInfo.getStatus());		currentOrderInfoVo.setOrderId(orderInfo.getId());		currentOrderInfoVo.setIsHasCurrentOrder(true);	&#125; else &#123;		currentOrderInfoVo.setIsHasCurrentOrder(false);	&#125;	return currentOrderInfoVo;&#125;
远程调用service-order-clientOrderInfoFeignClient
/** * 司机端查找当前订单 * @param driverId * @return */@GetMapping(&quot;/order/info/searchDriverCurrentOrder/&#123;driverId&#125;&quot;)Result&lt;CurrentOrderInfoVo&gt; searchDriverCurrentOrder(@PathVariable(&quot;driverId&quot;) Long driverId);

司机端web接口web-driverOrderController
@Operation(summary = &quot;司机端查找当前订单&quot;)  @LoginDetection  @GetMapping(&quot;/searchDriverCurrentOrder&quot;)  public Result&lt;CurrentOrderInfoVo&gt; searchDriverCurrentOrder() &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.searchDriverCurrentOrder(driverId));  &#125;

service
// 司机端查找当前订单  @Override  public CurrentOrderInfoVo searchDriverCurrentOrder(Long driverId) &#123;      return orderInfoFeignClient.searchDriverCurrentOrder(driverId).getData();  &#125;

获取订单信息订单微服务接口service-orderOrderInfoController
@Operation(summary = &quot;根据订单id获取订单信息&quot;)@GetMapping(&quot;/getOrderInfo/&#123;orderId&#125;&quot;)public Result&lt;OrderInfo&gt; getOrderInfo(@PathVariable Long orderId) &#123;    return Result.ok(orderInfoService.getById(orderId));&#125;

远程调用OrderInfoFeignClient
/** * 根据订单id获取订单信息 * @param orderId * @return */@GetMapping(&quot;/order/info/getOrderInfo/&#123;orderId&#125;&quot;)Result&lt;OrderInfo&gt; getOrderInfo(@PathVariable(&quot;orderId&quot;) Long orderId);

乘客端web接口OrderController
@Operation(summary = &quot;获取订单信息&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderInfo/&#123;orderId&#125;&quot;)  public Result&lt;OrderInfoVo&gt; getOrderInfo(@PathVariable Long orderId) &#123;      Long customerId = AuthContextHolder.getUserId();      return Result.ok(orderService.getOrderInfo(orderId, customerId));  &#125;

service
// 获取订单信息  @Override  public OrderInfoVo getOrderInfo(Long orderId, Long customerId) &#123;      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();      //判断      if(orderInfo.getCustomerId() != customerId) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        OrderInfoVo orderInfoVo = new OrderInfoVo();      orderInfoVo.setOrderId(orderId);      BeanUtils.copyProperties(orderInfo,orderInfoVo);      return orderInfoVo;  &#125;

司机端web接口OrderController
@Operation(summary = &quot;获取订单账单详细信息&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderInfo/&#123;orderId&#125;&quot;)  public Result&lt;OrderInfoVo&gt; getOrderInfo(@PathVariable Long orderId) &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.getOrderInfo(orderId, driverId));  &#125;

service
@Overridepublic OrderInfoVo getOrderInfo(Long orderId, Long driverId) &#123;    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();    if(orderInfo.getDriverId() != driverId) &#123;        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);    &#125;    OrderInfoVo orderInfoVo = new OrderInfoVo();    orderInfoVo.setOrderId(orderId);    BeanUtils.copyProperties(orderInfo,orderInfoVo);    return orderInfoVo;&#125;

司乘同显司机端同显
司机所在地址就是司乘同显开始位置，订单地址就是司乘同显的终点
计算司机司乘同显最佳路线

司机端webOrderController
@Operation(summary = &quot;计算最佳驾驶线路&quot;)  @LoginDetection  @PostMapping(&quot;/calculateDrivingLine&quot;)  public Result&lt;DrivingLineVo&gt; calculateDrivingLine(@RequestBody CalculateDrivingLineForm calculateDrivingLineForm) &#123;      return Result.ok(orderService.calculateDrivingLine(calculateDrivingLineForm));  &#125;

service
@Autowired  private MapFeignClient mapFeignClient;// 计算最佳驾驶线路  @Override  public DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) &#123;      Result&lt;DrivingLineVo&gt; drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);      return drivingLineVoResult.getData();  &#125;

更新位置到redis
实时更新司机位置到redis

地图微服务接口service-mapLocationController
@Operation(summary = &quot;司机赶往代驾起始点：更新订单地址到缓存&quot;)  @PostMapping(&quot;/updateOrderLocationToCache&quot;)  public Result&lt;Boolean&gt; updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm) &#123;      return Result.ok(locationService.updateOrderLocationToCache(updateOrderLocationForm));  &#125;

service
// 司机赶往代驾起始点：更新订单地址到缓存  @Override  public Boolean updateOrderLocationToCache(UpdateOrderLocationForm updateOrderLocationForm) &#123;        OrderLocationVo orderLocationVo = new OrderLocationVo();      orderLocationVo.setLongitude(updateOrderLocationForm.getLongitude());      orderLocationVo.setLatitude(updateOrderLocationForm.getLatitude());        String key = RedisConstant.UPDATE_ORDER_LOCATION + updateOrderLocationForm.getOrderId();      redisTemplate.opsForValue().set(key, orderLocationVo);      return true;  &#125;

远程调用service-map-clientLocationFeignClient
/**   * 司机赶往代驾起始点：更新订单地址到缓存   * @param updateOrderLocationForm   * @return   */  @PostMapping(&quot;/map/location/updateOrderLocationToCache&quot;)  Result&lt;Boolean&gt; updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm);


司机web端LocationController
@Operation(summary = &quot;司机赶往代驾起始点：更新订单位置到Redis缓存&quot;)  @LoginDetection  @PostMapping(&quot;/updateOrderLocationToCache&quot;)  public Result updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm) &#123;      return Result.ok(locationService.updateOrderLocationToCache(updateOrderLocationForm));  &#125;

service
// 司机赶往代驾起始点：更新订单位置到Redis缓存  @Override  public Boolean updateOrderLocationToCache(UpdateOrderLocationForm updateOrderLocationForm) &#123;      return locationFeignClient.updateOrderLocationToCache(updateOrderLocationForm).getData();  &#125;

获取司机基本信息
乘客端进入司乘同显界面可以看到司机的基本信息.

司机微服务接口service-driverDriverInfoController
@Operation(summary = &quot;获取司机基本信息&quot;)  @GetMapping(&quot;/getDriverInfo/&#123;driverId&#125;&quot;)  public Result&lt;DriverInfoVo&gt; getDriverInfoOrder(@PathVariable Long driverId) &#123;      return Result.ok(driverInfoService.getDriverInfoOrder(driverId));  &#125;

service
//获取司机基本信息  @Override  public DriverInfoVo getDriverInfoOrder(Long driverId) &#123;      //司机id获取基本信息      DriverInfo driverInfo = driverInfoMapper.selectById(driverId);        //封装DriverInfoVo      DriverInfoVo driverInfoVo = new DriverInfoVo();      BeanUtils.copyProperties(driverInfo,driverInfoVo);        //计算驾龄      //获取当前年      int currentYear = new DateTime().getYear();      //获取驾驶证初次领证日期      //driver_license_issue_date      int firstYear = new DateTime(driverInfo.getDriverLicenseIssueDate()).getYear();      int driverLicenseAge = currentYear - firstYear;      driverInfoVo.setDriverLicenseAge(driverLicenseAge);        return driverInfoVo;  &#125;

远程调用DriverInfoFeignClient
/** * 获取司机基本信息 * @param driverId * @return */@GetMapping(&quot;/driver/info/getDriverInfo/&#123;driverId&#125;&quot;)Result&lt;DriverInfoVo&gt; getDriverInfo(@PathVariable(&quot;driverId&quot;) Long driverId);

乘客端web接口OrderController
@Operation(summary = &quot;根据订单id获取司机基本信息&quot;)  @LoginDetection  @GetMapping(&quot;/getDriverInfo/&#123;orderId&#125;&quot;)  public Result&lt;DriverInfoVo&gt; getDriverInfo(@PathVariable Long orderId) &#123;      Long customerId = AuthContextHolder.getUserId();      return Result.ok(orderService.getDriverInfo(orderId, customerId));  &#125;

service
// 根据订单id获取司机基本信息  @Override  public DriverInfoVo getDriverInfo(Long orderId, Long customerId) &#123;      //根据订单id获取订单信息      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();      if(orderInfo.getCustomerId() != customerId) &#123;          throw new GuiguException(ResultCodeEnum.DATA_ERROR);      &#125;      return driverInfoFeignClient.getDriverInfo(orderInfo.getDriverId()).getData();  &#125;

乘客端获取司机经纬度位置
乘客查看司机位置

地图微服务接口service-mapLocationController
@Operation(summary = &quot;司机赶往代驾起始点：获取订单经纬度位置&quot;)  @GetMapping(&quot;/getCacheOrderLocation/&#123;orderId&#125;&quot;)  public Result&lt;OrderLocationVo&gt; getCacheOrderLocation(@PathVariable Long orderId) &#123;     return Result.ok(locationService.getCacheOrderLocation(orderId));  &#125;

service
// 司机赶往代驾起始点：获取订单经纬度位置  @Override  public OrderLocationVo getCacheOrderLocation(Long orderId) &#123;      String key = RedisConstant.UPDATE_ORDER_LOCATION + orderId;      OrderLocationVo orderLocationVo = (OrderLocationVo)redisTemplate.opsForValue().get(key);      return orderLocationVo;  &#125;

远程调用LocationFeignClient
/**   * 司机赶往代驾起始点：获取订单经纬度位置   * @param orderId   * @return   */  @GetMapping(&quot;/map/location/getCacheOrderLocation/&#123;orderId&#125;&quot;)  Result&lt;OrderLocationVo&gt; getCacheOrderLocation(@PathVariable(&quot;orderId&quot;) Long orderId);

乘客端web接口OrderController
@Operation(summary = &quot;司机赶往代驾起始点：获取订单经纬度位置&quot;)  @GetMapping(&quot;/getCacheOrderLocation/&#123;orderId&#125;&quot;)  public Result&lt;OrderLocationVo&gt; getCacheOrderLocation(@PathVariable Long orderId) &#123;      return Result.ok(orderService.getCacheOrderLocation(orderId));  &#125;

service
// 司机赶往代驾起始点：获取订单经纬度位置  @Override  public OrderLocationVo getCacheOrderLocation(Long orderId) &#123;      return locationFeignClient.getCacheOrderLocation(orderId).getData();  &#125;

乘客端同显乘客端web接口OrderController
@Operation(summary = &quot;计算最佳驾驶线路&quot;)  @LoginDetection  @PostMapping(&quot;/calculateDrivingLine&quot;)  public Result&lt;DrivingLineVo&gt; calculateDrivingLine(@RequestBody CalculateDrivingLineForm calculateDrivingLineForm) &#123;      return Result.ok(orderService.calculateDrivingLine(calculateDrivingLineForm));  &#125;

service
// 计算最佳驾驶线路  @Override  public DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) &#123;      return mapFeignClient.calculateDrivingLine(calculateDrivingLineForm).getData();  &#125;


司机到达起始点
司机到达起始点后更新订单数据
更新订单状态：司机已到达
更新订单到达时间

订单微服务接口service-orderOrderInfoController
@Operation(summary = &quot;司机到达起始点&quot;)  @GetMapping(&quot;/driverArriveStartLocation/&#123;orderId&#125;/&#123;driverId&#125;&quot;)  public Result&lt;Boolean&gt; driverArriveStartLocation(@PathVariable Long orderId, @PathVariable Long driverId) &#123;      return Result.ok(orderInfoService.driverArriveStartLocation(orderId, driverId));  &#125;

service
//司机到达起始点  @Override  public Boolean driverArriveStartLocation(Long orderId, Long driverId) &#123;      // 更新订单状态和到达时间，条件：orderId + driverId      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId,orderId);      wrapper.eq(OrderInfo::getDriverId,driverId);        OrderInfo orderInfo = new OrderInfo();      orderInfo.setStatus(OrderStatus.DRIVER_ARRIVED.getStatus());      orderInfo.setArriveTime(new Date());        int rows = orderInfoMapper.update(orderInfo, wrapper);        if(rows == 1) &#123;          return true;      &#125; else &#123;          throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);      &#125;  &#125;

远程调用service-order-clientOrderInfoFeignClient
/** * 司机到达起始点 * @param orderId * @param driverId * @return */@GetMapping(&quot;/order/info/driverArriveStartLocation/&#123;orderId&#125;/&#123;driverId&#125;&quot;)Result&lt;Boolean&gt; driverArriveStartLocation(@PathVariable(&quot;orderId&quot;) Long orderId, @PathVariable(&quot;driverId&quot;) Long driverId);

司机web调用OrderController
@Operation(summary = &quot;司机到达代驾起始地点&quot;)  @LoginDetection  @GetMapping(&quot;/driverArriveStartLocation/&#123;orderId&#125;&quot;)  public Result&lt;Boolean&gt; driverArriveStartLocation(@PathVariable Long orderId) &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.driverArriveStartLocation(orderId, driverId));  &#125;

// 司机到达代驾起始地点  @Override  public Boolean driverArriveStartLocation(Long orderId, Long driverId) &#123;      return orderInfoFeignClient.driverArriveStartLocation(orderId, driverId).getData();  &#125;

司机更新代驾车辆信息订单微服务接口service-orderOrderInfoController
@Operation(summary = &quot;更新代驾车辆信息&quot;)  @PostMapping(&quot;/updateOrderCart&quot;)  public Result&lt;Boolean&gt; updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm) &#123;      return Result.ok(orderInfoService.updateOrderCart(updateOrderCartForm));  &#125;

service
// 更新代驾车辆信息  @Override  public Boolean updateOrderCart(UpdateOrderCartForm updateOrderCartForm) &#123;      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId,updateOrderCartForm.getOrderId());      wrapper.eq(OrderInfo::getDriverId,updateOrderCartForm.getDriverId());        OrderInfo orderInfo = new OrderInfo();      BeanUtils.copyProperties(updateOrderCartForm,orderInfo);      orderInfo.setStatus(OrderStatus.UPDATE_CART_INFO.getStatus());        int rows = orderInfoMapper.update(orderInfo, wrapper);      if(rows == 1) &#123;          return true;      &#125; else &#123;          throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);      &#125;  &#125;

远程调用OrderInfoFeignClient
/**   * 更新代驾车辆信息   * @param updateOrderCartForm   * @return   */  @PostMapping(&quot;/order/info//updateOrderCart&quot;)  Result&lt;Boolean&gt; updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm);


司机web端接口OrderController
@Operation(summary = &quot;更新代驾车辆信息&quot;)  @LoginDetection  @PostMapping(&quot;/updateOrderCart&quot;)  public Result&lt;Boolean&gt; updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm) &#123;      Long driverId = AuthContextHolder.getUserId();      updateOrderCartForm.setDriverId(driverId);      return Result.ok(orderService.updateOrderCart(updateOrderCartForm));  &#125;

service
// 更新代驾车辆信息  @Override  public Boolean updateOrderCart(UpdateOrderCartForm updateOrderCartForm) &#123;      return orderInfoFeignClient.updateOrderCart(updateOrderCartForm).getData();  &#125;

测试
启动项目：

XxlJobAdminApplication
ServerGatewayApplication :8600&#x2F;
ServiceCustomerApplication :8501&#x2F;
ServiceDispatchApplication :8509&#x2F;
ServiceDriverApplication :8502&#x2F;
ServiceMapApplication :8503&#x2F;
ServiceOrderApplication:8505&#x2F;
ServiceRulesApplication :8504&#x2F;
WebCustomerApplication :8601&#x2F;
WebDriverApplication :8602&#x2F;


清除之前的数据

启动微信开发者工具


修改前面的代码web-driver
FileController
@Autowired  private CosService cosService;    //文件上传接口  @Operation(summary = &quot;上传&quot;)  //@LoginDetection  @PostMapping(&quot;/upload&quot;)  public Result&lt;String&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file,                                    @RequestParam(name = &quot;path&quot;,defaultValue = &quot;auth&quot;) String path) &#123;      CosUploadVo cosUploadVo = cosService.uploadFile(file,path);      String showUrl = cosUploadVo.getShowUrl();      return Result.ok(showUrl);  &#125;


订单执行（二）开始服务
更新订单状态

订单微服务接口OrderInfoController
@Operation(summary = &quot;开始服务&quot;)  @PostMapping(&quot;/startDrive&quot;)  public Result&lt;Boolean&gt; startDriver(@RequestBody StartDriveForm startDriveForm) &#123;      Boolean flag = orderInfoService.startDriver(startDriveForm);      return Result.ok(flag);  &#125;

service
//开始代驾服务  @Override  public Boolean startDriver(StartDriveForm startDriveForm) &#123;      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId,startDriveForm.getOrderId());      wrapper.eq(OrderInfo::getDriverId,startDriveForm.getDriverId());        OrderInfo orderInfo = new OrderInfo();      orderInfo.setStatus(OrderStatus.START_SERVICE.getStatus());      orderInfo.setStartServiceTime(new Date());        int rows = orderInfoMapper.update(orderInfo, wrapper);      if(rows == 1) &#123;          return true;      &#125; else &#123;          throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);      &#125;  &#125;


远程调用OrderInfoFeignClient
/**   * 开始代驾服务   * @param startDriveForm   * @return   */  @PostMapping(&quot;/order/info/startDrive&quot;)  Result&lt;Boolean&gt; startDrive(@RequestBody StartDriveForm startDriveForm);

司机web端调用OrderController
@Operation(summary = &quot;开始代驾服务&quot;)  @LoginDetection  @PostMapping(&quot;/startDrive&quot;)  public Result&lt;Boolean&gt; startDrive(@RequestBody StartDriveForm startDriveForm) &#123;      Long driverId = AuthContextHolder.getUserId();      startDriveForm.setDriverId(driverId);      return Result.ok(orderService.startDrive(startDriveForm));  &#125;

service
// 开始代驾服务  @Override  public Boolean startDrive(StartDriveForm startDriveForm) &#123;      return orderInfoFeignClient.startDrive(startDriveForm).getData();  &#125;

批量保存订单位置信息
开始服务后，司机端会实时收集司机位置
定时批量上传位置到后台服务保存到MongoDB

地图微服务接口LocationController
@Operation(summary = &quot;批量保存代驾服务订单位置&quot;)  @PostMapping(&quot;/saveOrderServiceLocation&quot;)  public Result&lt;Boolean&gt; saveOrderServiceLocation(@RequestBody List&lt;OrderServiceLocationForm&gt; orderLocationServiceFormList) &#123;      return Result.ok(locationService.saveOrderServiceLocation(orderLocationServiceFormList));  &#125;

编写接口
@Repository  public interface OrderServiceLocationRepository extends MongoRepository&lt;OrderServiceLocation, String&gt; &#123;  &#125;

导入依赖
&lt;!--mongodb--&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;

service
@Autowired  private OrderServiceLocationRepository orderServiceLocationRepository;@Override  public Boolean saveOrderServiceLocation(List&lt;OrderServiceLocationForm&gt; orderLocationServiceFormList) &#123;      List&lt;OrderServiceLocation&gt; list = new ArrayList&lt;&gt;();      // 遍历，变成OrderServiceLocation      orderLocationServiceFormList.forEach(orderServiceLocationForm-&gt;&#123;          //orderServiceLocationForm -- OrderServiceLocation          OrderServiceLocation orderServiceLocation = new OrderServiceLocation();          BeanUtils.copyProperties(orderServiceLocationForm,orderServiceLocation);          orderServiceLocation.setId(ObjectId.get().toString());          orderServiceLocation.setCreateTime(new Date());            list.add(orderServiceLocation);      &#125;);      //批量添加到MongoDB      orderServiceLocationRepository.saveAll(list);      return true;  &#125;


远程调用LocationFeignClient
/**   * 开始代驾服务：保存代驾服务订单位置   * @param orderLocationServiceFormList   * @return   */  @PostMapping(&quot;/map/location/saveOrderServiceLocation&quot;)  Result&lt;Boolean&gt; saveOrderServiceLocation(@RequestBody List&lt;OrderServiceLocationForm&gt; orderLocationServiceFormList);

司机web端调用LocationController
@Operation(summary = &quot;开始代驾服务：保存代驾服务订单位置&quot;)  @PostMapping(&quot;/saveOrderServiceLocation&quot;)  public Result&lt;Boolean&gt; saveOrderServiceLocation(@RequestBody List&lt;OrderServiceLocationForm&gt; orderLocationServiceFormList) &#123;      return Result.ok(locationService.saveOrderServiceLocation(orderLocationServiceFormList));  &#125;

service
// 始代驾服务：保存代驾服务订单位置  @Override  public Boolean saveOrderServiceLocation(List&lt;OrderServiceLocationForm&gt; orderLocationServiceFormList) &#123;      return locationFeignClient.saveOrderServiceLocation(orderLocationServiceFormList).getData();  &#125;


获取订单最后一个位置
司机开始服务后，乘客端获取司机的最新动向

地图微服务接口LocationController
@Operation(summary = &quot;代驾服务：获取订单服务最后一个位置信息&quot;)  @GetMapping(&quot;/getOrderServiceLastLocation/&#123;orderId&#125;&quot;)  public Result&lt;OrderServiceLastLocationVo&gt; getOrderServiceLastLocation(@PathVariable Long orderId) &#123;      return Result.ok(locationService.getOrderServiceLastLocation(orderId));  &#125;

service
@Autowired  private MongoTemplate mongoTemplate;// 代驾服务：获取订单服务最后一个位置信息  @Override  public OrderServiceLastLocationVo getOrderServiceLastLocation(Long orderId) &#123;      //查询MongoDB,查询条件 ：orderId      Query query = new Query();      query.addCriteria(Criteria.where(&quot;orderId&quot;).is(orderId));      //根据创建时间降序排列      query.with(Sort.by(Sort.Order.desc(&quot;createTime&quot;)));      //只取一条数据      query.limit(1);        OrderServiceLocation orderServiceLocation =              mongoTemplate.findOne(query, OrderServiceLocation.class);      OrderServiceLastLocationVo orderServiceLastLocationVo = new OrderServiceLastLocationVo();      BeanUtils.copyProperties(orderServiceLocation,orderServiceLastLocationVo);      return orderServiceLastLocationVo;  &#125;

远程调用LocationFeignClient
/**   * 代驾服务：获取订单服务最后一个位置信息   * @param orderId   * @return   */  @GetMapping(&quot;/map/location/getOrderServiceLastLocation/&#123;orderId&#125;&quot;)  Result&lt;OrderServiceLastLocationVo&gt; getOrderServiceLastLocation(@PathVariable Long orderId);

乘客web端调用OrderController
@Operation(summary = &quot;代驾服务：获取订单服务最后一个位置信息&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderServiceLastLocation/&#123;orderId&#125;&quot;)  public Result&lt;OrderServiceLastLocationVo&gt; getOrderServiceLastLocation(@PathVariable Long orderId) &#123;      return Result.ok(orderService.getOrderServiceLastLocation(orderId));  &#125;

service
// 代驾服务：获取订单服务最后一个位置信息  @Override  public OrderServiceLastLocationVo getOrderServiceLastLocation(Long orderId) &#123;      return locationFeignClient.getOrderServiceLastLocation(orderId).getData();  &#125;

Minio上传接口
司机服务过程中，司机端小程序实时采集录音，把录音和对话文本上传到后台服务，把完整监控保存到Minio

Minio安装使用docker安装
// 创建数据存储目录mkdir -p ~/minio/data// 创建miniodocker run \   -p 9000:9000 \   -p 9090:9090 \   --name minio \   -v ~/minio/data:/data \   -e &quot;MINIO_ROOT_USER=admin&quot; \   -e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \   -d \   quay.io/minio/minio server /data --console-address &quot;:9090&quot;

2 安装到windows里面

找到minio安装文件，放到没有中文没有空格目录

创建空文件夹，作为数据存储目录

在windows使用命令启动Minio服务


– minio.exe server D:\Desktop\hhsqdmz\sort\minio\data
Minio启动
访问Minio控制台：ip:9000

默认控制台用户名和密码都是：minioadmin

在minio控制台里创建buckets

创建buckets后记得把Access Policy设为public


司机端web接口导入依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;

修改配置文件common-account.yaml
minio:  endpointUrl: http://localhost:9000  accessKey: minioadmin  secreKey: minioadmin  bucketName: daijia

创建配置类，读取minio的值
@Configuration  @ConfigurationProperties(prefix=&quot;minio&quot;) //读取节点  @Data  public class MinioProperties &#123;        private String endpointUrl;      private String accessKey;      private String secreKey;      private String bucketName;  &#125;

FileController
@Autowired  private FileService fileService;@Operation(summary = &quot;上传&quot;)  @PostMapping(&quot;/upload&quot;)  public Result&lt;String&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file) &#123;      String url = fileService.upload(file);      return Result.ok(url);  &#125;

service
@Autowired  private MinioProperties minioProperties;    // 上传  @Override  public String upload(MultipartFile file) &#123;      try &#123;          // 创建一个Minio的客户端对象          MinioClient minioClient = MinioClient.builder()                  .endpoint(minioProperties.getEndpointUrl())                  .credentials(minioProperties.getAccessKey(), minioProperties.getSecreKey())                  .build();            // 判断桶是否存在          boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(minioProperties.getBucketName()).build());          if (!found) &#123;       // 如果不存在，那么此时就创建一个新的桶              minioClient.makeBucket(MakeBucketArgs.builder().bucket(minioProperties.getBucketName()).build());          &#125; else &#123;  // 如果存在打印信息              System.out.println(&quot;Bucket &#x27;daijia&#x27; already exists.&quot;);          &#125;            // 设置存储对象名称          String extFileName = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));          String fileName = new SimpleDateFormat(&quot;yyyyMMdd&quot;)                  .format(new Date()) + &quot;/&quot; + UUID.randomUUID().toString().replace(&quot;-&quot; , &quot;&quot;) + &quot;.&quot; + extFileName;            PutObjectArgs putObjectArgs = PutObjectArgs.builder()                  .bucket(minioProperties.getBucketName())                  .stream(file.getInputStream(), file.getSize(), -1)                  .object(fileName)                  .build();          minioClient.putObject(putObjectArgs) ;            return minioProperties.getEndpointUrl() + &quot;/&quot; + minioProperties.getBucketName() + &quot;/&quot; + fileName ;        &#125; catch (Exception e) &#123;          throw new GuiguException(ResultCodeEnum.DATA_ERROR);      &#125;  &#125;

保存订单监控记录数据
订单执行过程中，记录对话信息
在前端小程序，同声传译，把录音转换文本，保存文本内存

订单微服务接口.导入依赖
&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;  &lt;/dependency&gt;

添加MongoRepository
@Repository  public interface OrderMonitorRecordRepository extends MongoRepository&lt;OrderMonitorRecord, String&gt; &#123;  &#125;

OrderMonitorController
@Autowired  private OrderMonitorService orderMonitorService;    @Operation(summary = &quot;保存订单监控记录数据&quot;)  @PostMapping(&quot;/saveOrderMonitorRecord&quot;)  public Result&lt;Boolean&gt; saveMonitorRecord(@RequestBody OrderMonitorRecord orderMonitorRecord) &#123;      return Result.ok(orderMonitorService.saveOrderMonitorRecord(orderMonitorRecord));  &#125;

service
@Autowired  private OrderMonitorRecordRepository orderMonitorRecordRepository;    // 保存订单监控记录数据  @Override  public Boolean saveOrderMonitorRecord(OrderMonitorRecord orderMonitorRecord) &#123;      orderMonitorRecordRepository.save(orderMonitorRecord);      return true;  &#125;

远程调用OrderMonitorFeignClient
/**   * 保存订单监控记录数据   * @param orderMonitorRecord   * @return   */  @PostMapping(&quot;/order/monitor/saveOrderMonitorRecord&quot;)  Result&lt;Boolean&gt; saveMonitorRecord(@RequestBody OrderMonitorRecord orderMonitorRecord);

司机端web调用MonitorController
@Autowired  private MonitorService monitorService;    @Operation(summary = &quot;上传录音&quot;)  @PostMapping(&quot;/upload&quot;)  public Result&lt;Boolean&gt; upload(@RequestParam(&quot;file&quot;) MultipartFile file,                                OrderMonitorForm orderMonitorForm) &#123;        return Result.ok(monitorService.upload(file, orderMonitorForm));  &#125;

service
@Autowired  private FileService fileService;    @Autowired  private OrderMonitorFeignClient orderMonitorFeignClient;    // 上传录音  @Override  public Boolean upload(MultipartFile file, OrderMonitorForm orderMonitorForm) &#123;      //上传文件      String url = fileService.upload(file);        OrderMonitorRecord orderMonitorRecord = new OrderMonitorRecord();      orderMonitorRecord.setOrderId(orderMonitorForm.getOrderId());      orderMonitorRecord.setFileUrl(url);      orderMonitorRecord.setContent(orderMonitorForm.getContent());      orderMonitorFeignClient.saveMonitorRecord(orderMonitorRecord);        return true;  &#125;


订单监控审核使用腾讯云数据万象实现自动审核

官方网址：https://cloud.tencent.com/product/ci

腾讯云COS图片审核封装图片审核方法在service-driver的CiService
Boolean imageAuditing(String path);

CiServiceImpl
@Service  public class CiServiceImpl implements CiService &#123;        @Autowired      private TencentCloudProperties tencentCloudProperties;        //图片审核      @Override      public Boolean imageAuditing(String path) &#123;            //1.创建任务请求对象          ImageAuditingRequest request = new ImageAuditingRequest();          //2.添加请求参数 参数详情请见 API 接口文档          //2.1设置请求 bucket        request.setBucketName(tencentCloudProperties.getBucketPrivate());          //2.2设置审核策略 不传则为默认策略（预设）          //request.setBizType(&quot;&quot;);          //2.3设置 bucket 中的图片位置          request.setObjectKey(path);          //3.调用接口,获取任务响应对象          COSClient client = this.getCosClient();          ImageAuditingResponse response = client.imageAuditing(request);          client.shutdown();          //用于返回该审核场景的审核结果，返回值：0：正常。1：确认为当前场景的违规内容。2：疑似为当前场景的违规内容。          if (!response.getPornInfo().getHitFlag().equals(&quot;0&quot;)                  || !response.getAdsInfo().getHitFlag().equals(&quot;0&quot;)                  || !response.getTerroristInfo().getHitFlag().equals(&quot;0&quot;)                  || !response.getPoliticsInfo().getHitFlag().equals(&quot;0&quot;)          ) &#123;              return false;          &#125;          return true;      &#125;        public COSClient getCosClient() &#123;          String secretId = tencentCloudProperties.getSecretId();          String secretKey = tencentCloudProperties.getSecretKey();          COSCredentials cred = new BasicCOSCredentials(secretId, secretKey);          // 2 设置 bucket 的地域, COS 地域          Region region = new Region(tencentCloudProperties.getRegion());          ClientConfig clientConfig = new ClientConfig(region);          // 这里建议设置使用 https 协议          clientConfig.setHttpProtocol(HttpProtocol.https);          // 3 生成 cos 客户端。          COSClient cosClient = new COSClient(cred, clientConfig);          return cosClient;      &#125;  &#125;

腾讯云COS图片添加审核CosServiceImpl
@Autowired  private CiService ciService;    @Override  public CosUploadVo upload(MultipartFile file, String path) &#123;      //获取cosClient对象      COSClient cosClient = this.getCosClient();      //文件上传      //元数据信息      ObjectMetadata meta = new ObjectMetadata();      meta.setContentLength(file.getSize());      meta.setContentEncoding(&quot;UTF-8&quot;);      meta.setContentType(file.getContentType());        //向存储桶中保存文件      String fileType = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); //文件后缀名      String uploadPath = &quot;/driver/&quot; + path + &quot;/&quot; + UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + fileType;      // 01.jpg      // /driver/auth/0o98754.jpg    PutObjectRequest putObjectRequest = null;      try &#123;          //1 bucket名称          //2          putObjectRequest = new PutObjectRequest(tencentCloudProperties.getBucketPrivate(),                  uploadPath,                  file.getInputStream(),                  meta);      &#125; catch (IOException e) &#123;          throw new RuntimeException(e);      &#125;      putObjectRequest.setStorageClass(StorageClass.Standard);      PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); //上传文件      cosClient.shutdown();        // 图片审核      Boolean imageAuditing = ciService.imageAuditing(uploadPath);      if(!imageAuditing)&#123;          cosClient.deleteObject(tencentCloudProperties.getBucketPrivate(), uploadPath);          throw new GuiguException(ResultCodeEnum.IMAGE_AUDITION_FAIL);      &#125;        //返回vo对象      CosUploadVo cosUploadVo = new CosUploadVo();      cosUploadVo.setUrl(uploadPath);      //图片临时访问url，回显使用      String imageUrl = this.getImageUrl(uploadPath);      cosUploadVo.setShowUrl(imageUrl);      return cosUploadVo;  &#125;

封装文本审核接口司机微服务接口CiController
@Autowired  private CiService ciService;    @Operation(summary = &quot;文本审核&quot;)  @PostMapping(&quot;/textAuditing&quot;)  public Result&lt;TextAuditingVo&gt; textAuditing(@RequestBody String content) &#123;      return Result.ok(ciService.textAuditing(content));  &#125;

service
// 文本审核  @Override  public TextAuditingVo textAuditing(String content) &#123;      if(!StringUtils.hasText(content)) &#123;          TextAuditingVo textAuditingVo = new TextAuditingVo();          textAuditingVo.setResult(&quot;0&quot;);          return textAuditingVo;      &#125;        COSClient cosClient = this.getCosClient();        //1.创建任务请求对象      TextAuditingRequest request = new TextAuditingRequest();      //2.添加请求参数 参数详情请见 API 接口文档      request.setBucketName(tencentCloudProperties.getBucketPrivate());      //2.1.1设置请求内容,文本内容的Base64编码      byte[] encoder = org.apache.commons.codec.binary.Base64.encodeBase64(content.getBytes());      String contentBase64 = new String(encoder);      request.getInput().setContent(contentBase64);      request.getConf().setDetectType(&quot;all&quot;);        //3.调用接口,获取任务响应对象      TextAuditingResponse response = cosClient.createAuditingTextJobs(request);      AuditingJobsDetail detail = response.getJobsDetail();      TextAuditingVo textAuditingVo = new TextAuditingVo();      if (&quot;Success&quot;.equals(detail.getState())) &#123;          //检测结果: 0（审核正常），1 （判定为违规敏感文件），2（疑似敏感，建议人工复核）。          String result = detail.getResult();            //违规关键词          StringBuffer keywords = new StringBuffer();          List&lt;SectionInfo&gt; sectionInfoList = detail.getSectionList();          for (SectionInfo info : sectionInfoList) &#123;                String pornInfoKeyword = info.getPornInfo().getKeywords();              String illegalInfoKeyword = info.getIllegalInfo().getKeywords();              String abuseInfoKeyword = info.getAbuseInfo().getKeywords();                if (pornInfoKeyword.length() &gt; 0) &#123;                  keywords.append(pornInfoKeyword).append(&quot;,&quot;);              &#125;              if (illegalInfoKeyword.length() &gt; 0) &#123;                  keywords.append(illegalInfoKeyword).append(&quot;,&quot;);              &#125;              if (abuseInfoKeyword.length() &gt; 0) &#123;                  keywords.append(abuseInfoKeyword).append(&quot;,&quot;);              &#125;          &#125;          textAuditingVo.setResult(result);          textAuditingVo.setKeywords(keywords.toString());      &#125;      return textAuditingVo;  &#125;

远程调用CiFeignClient
/**   * 文本审核   * @param content   * @return   */  @PostMapping(&quot;/ci/textAuditing&quot;)  Result&lt;TextAuditingVo&gt; textAuditing(@RequestBody String content);


订单监控接口完善修改web-driver的MonitorServiceImpl
@Autowired  private FileService fileService;    @Autowired  private OrderMonitorFeignClient orderMonitorFeignClient;    @Autowired  private CiFeignClient ciFeignClient;    // 上传录音  @Override  public Boolean upload(MultipartFile file, OrderMonitorForm orderMonitorForm) &#123;      //上传文件      String url = fileService.upload(file);        OrderMonitorRecord orderMonitorRecord = new OrderMonitorRecord();      orderMonitorRecord.setOrderId(orderMonitorForm.getOrderId());      orderMonitorRecord.setFileUrl(url);      orderMonitorRecord.setContent(orderMonitorForm.getContent());        // 文本审核      TextAuditingVo textAuditingVo = ciFeignClient.textAuditing(orderMonitorForm.getContent()).getData();      orderMonitorRecord.setResult(textAuditingVo.getResult());      orderMonitorRecord.setKeywords(textAuditingVo.getKeywords());        orderMonitorFeignClient.saveMonitorRecord(orderMonitorRecord);        return true;  &#125;


订单执行（三）计算订单实际里程
在MongoDB保存订单过程中司机位置信息，把MongoDB存储司机位置信息获取出来，以时间排序，连接每个点，成为实际距离

准备计算距离工具类common-util中的LocationUtil
public static double getDistance(double lat1, double lng1, double lat2,                                   double lng2) &#123;      double radLat1 = rad(lat1);      double radLat2 = rad(lat2);      double a = radLat1 - radLat2;      double b = rad(lng1) - rad(lng2);      double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2)              + Math.cos(radLat1) * Math.cos(radLat2)              * Math.pow(Math.sin(b / 2), 2)));      s = s * EARTH_RADIUS;      s = Math.round(s * 10000d) / 10000d;      s = s * 1000;      return s;  &#125;

地图微服务接口LocationController
@Operation(summary = &quot;代驾服务：计算订单实际里程&quot;)  @GetMapping(&quot;/calculateOrderRealDistance/&#123;orderId&#125;&quot;)  public Result&lt;BigDecimal&gt; calculateOrderRealDistance(@PathVariable Long orderId) &#123;      return Result.ok(locationService.calculateOrderRealDistance(orderId));  &#125;

service
// 代驾服务：计算订单实际里程  @Override  public BigDecimal calculateOrderRealDistance(Long orderId) &#123;      // 根据订单id获取位置信息，按照创建时间排序      List&lt;OrderServiceLocation&gt; list =              orderServiceLocationRepository.findByOrderIdOrderByCreateTimeAsc(orderId);        // 第一步查询返回订单位置信息list集合      // 把list集合遍历，得到每个位置信息，计算两个位置距离，把计算所有距离相加操作      double realDistance = 0;      if(!CollectionUtils.isEmpty(list)) &#123;          for (int i = 0,size = list.size()-1; i &lt; size; i++) &#123;              OrderServiceLocation location1 = list.get(i);              OrderServiceLocation location2 = list.get(i + 1);                //计算位置距离              double distance = LocationUtil.getDistance(location1.getLatitude().doubleValue(),                      location1.getLongitude().doubleValue(),                      location2.getLatitude().doubleValue(),                      location2.getLongitude().doubleValue());                realDistance += distance;          &#125;      &#125;            return new BigDecimal(realDistance);  &#125;

远程调用LocationFeignClient
/** * 代驾服务：计算订单实际里程 * @param orderId * @return */@GetMapping(&quot;/map/location/calculateOrderRealDistance/&#123;orderId&#125;&quot;)Result&lt;BigDecimal&gt; calculateOrderRealDistance(@PathVariable Long orderId);


计算系统奖励创建规则文件//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问  package  com.atguigu.daijia    import com.atguigu.daijia.model.form.rules.RewardRuleRequest;  import java.math.BigDecimal;  import java.math.RoundingMode;    global com.atguigu.daijia.model.vo.rules.RewardRuleResponse rewardRuleResponse;    /**  系统奖励      00:00:00-06:59:59  完成5单后 奖励5元      07:00:00-23:59:59  完成10单后 奖励2元  */  rule &quot;00:00:00-06:59:59  完成5单后 每单奖励5元&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:RewardRuleRequest(startTime &gt;= &quot;00:00:00&quot; &amp;&amp; startTime &lt;= &quot;06:59:59&quot; &amp;&amp; orderNum &gt; 5)      then          rewardRuleResponse.setRewardAmount(new BigDecimal(&quot;5.0&quot;));          System.out.println(&quot;00:00:00-06:59:59 奖励：&quot; + rewardRuleResponse.getRewardAmount() + &quot;元&quot;);  end  rule &quot;07:00:00-23:59:59  完成10单后 每单奖励2元&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:RewardRuleRequest(startTime &gt;= &quot;07:00:00&quot; &amp;&amp; startTime &lt;= &quot;23:59:59&quot; &amp;&amp; orderNum &gt; 10)      then          rewardRuleResponse.setRewardAmount(new BigDecimal(&quot;2.0&quot;));          System.out.println(&quot;00:00:00-06:59:59 奖励：&quot; + rewardRuleResponse.getRewardAmount() + &quot;元&quot;);  end

添加规则引擎工具类在service-rules中utils包下创建
public class DroolsHelper &#123;        private static final String RULES_CUSTOMER_RULES_DRL = &quot;rules/FeeRule.drl&quot;;        public static KieSession loadForRule(String drlStr) &#123;          KieServices kieServices = KieServices.Factory.get();            KieFileSystem kieFileSystem = kieServices.newKieFileSystem();          kieFileSystem.write(                  ResourceFactory.newClassPathResource(drlStr));            KieBuilder kb = kieServices.newKieBuilder(kieFileSystem);          kb.buildAll();            KieModule kieModule = kb.getKieModule();          KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());          return kieContainer.newKieSession();      &#125;  &#125;

规则微服务接口RewardRuleController
@Autowired  private RewardRuleService rewardRuleService;    @Operation(summary = &quot;计算订单奖励费用&quot;)  @PostMapping(&quot;/calculateOrderRewardFee&quot;)  public Result&lt;RewardRuleResponseVo&gt;  calculateOrderRewardFee(@RequestBody RewardRuleRequestForm rewardRuleRequestForm) &#123;      return Result.ok(rewardRuleService.calculateOrderRewardFee(rewardRuleRequestForm));  &#125;

service
// 计算订单奖励费用  @Override  public RewardRuleResponseVo calculateOrderRewardFee(RewardRuleRequestForm rewardRuleRequestForm) &#123;      //封装传入参数对象      RewardRuleRequest rewardRuleRequest = new RewardRuleRequest();      rewardRuleRequest.setOrderNum(rewardRuleRequestForm.getOrderNum());        //创建规则引擎对象      KieSession kieSession = DroolsHelper.loadForRule(RULES_CUSTOMER_RULES_DRL);        //封装返回对象      RewardRuleResponse rewardRuleResponse = new RewardRuleResponse();      kieSession.setGlobal(&quot;rewardRuleResponse&quot;,rewardRuleResponse);        //设置对象，触发规则      kieSession.insert(rewardRuleRequest);      kieSession.fireAllRules();        //终止会话      kieSession.dispose();        //封装RewardRuleResponseVo      RewardRuleResponseVo rewardRuleResponseVo = new RewardRuleResponseVo();      rewardRuleResponseVo.setRewardAmount(rewardRuleResponse.getRewardAmount());      return rewardRuleResponseVo;  &#125;

远程调用RewardRuleFeignClient
/** * 计算订单奖励费用 * @param rewardRuleRequestForm * @return */@PostMapping(&quot;/rules/reward/calculateOrderRewardFee&quot;)Result&lt;RewardRuleResponseVo&gt; calculateOrderRewardFee(@RequestBody RewardRuleRequestForm rewardRuleRequestForm);

根据时间段获取订单数量订单微服务接口OrderInfoController
@Operation(summary = &quot;根据时间段获取订单数&quot;)  @GetMapping(&quot;/getOrderNumByTime/&#123;startTime&#125;/&#123;endTime&#125;&quot;)  public Result&lt;Long&gt; getOrderNumByTime(@PathVariable String startTime, @PathVariable String endTime) &#123;      return Result.ok(orderInfoService.getOrderNumByTime(startTime, endTime));  &#125;

service
// 根据时间段获取订单数  @Override  public Long getOrderNumByTime(String startTime, String endTime) &#123;      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.ge(OrderInfo::getStartServiceTime,startTime);      wrapper.lt(OrderInfo::getStartServiceTime,endTime);      Long count = orderInfoMapper.selectCount(wrapper);      return count;  &#125;

远程调用OrderInfoFeignClient
/**   *  根据时间段获取订单数   * @param startTime   * @param endTime   * @return   */  @GetMapping(&quot;/order/info/getOrderNumByTime/&#123;startTime&#125;/&#123;endTime&#125;&quot;)  Result&lt;Long&gt; getOrderNumByTime(@PathVariable(&quot;startTime&quot;) String startTime, @PathVariable(&quot;endTime&quot;) String endTime);

计算分账信息创建规则文件//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问  package  com.atguigu.daijia    import com.atguigu.daijia.model.form.rules.ProfitsharingRuleRequest;  import java.math.BigDecimal;  import java.math.RoundingMode;    global com.atguigu.daijia.model.vo.rules.ProfitsharingRuleResponse profitsharingRuleResponse;  //支付微信平台费率：0.6%  //global BigDecimal paymentRate = new BigDecimal(0.006);  /**  支付微信平台费用      平台费率：0.6%  */  rule &quot;支付微信平台费用 平台费率：0.6%&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:ProfitsharingRuleRequest()      then          profitsharingRuleResponse.setOrderAmount($rule.getOrderAmount());          profitsharingRuleResponse.setPaymentRate(new BigDecimal(&quot;0.006&quot;));          BigDecimal paymentFee = profitsharingRuleResponse.getOrderAmount().multiply(profitsharingRuleResponse.getPaymentRate()).setScale(2, RoundingMode.HALF_UP);          profitsharingRuleResponse.setPaymentFee(paymentFee);          System.out.println(&quot;支付微信平台费用：&quot; + profitsharingRuleResponse.getPaymentFee() + &quot;元&quot;);  end    /**  订单金额小于等于100      当天完成订单小于等于10单 平台抽成 20%      当天完成订单大于10单 平台抽成 18%  */  rule &quot;订单金额小于等于100 当天完成订单小于等于10单&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() &lt;= 100.0 &amp;&amp; orderNum &lt;= 10)      then          BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());          BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(&quot;0.2&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);          //代驾司机个税，税率：10%          BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);          profitsharingRuleResponse.setPlatformIncome(platformIncome);          profitsharingRuleResponse.setDriverIncome(driverIncome);          profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(&quot;0.1&quot;));          profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);          System.out.println(&quot;平台分账收入：&quot; + platformIncome + &quot;元&quot; + &quot;，司机分账收入：&quot; + driverIncome + &quot;元&quot; + &quot;，司机个税：&quot; + driverTaxFee + &quot;元&quot;);  end  rule &quot;订单金额小于等于100 天完成订单大于10单&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() &lt;= 100.0 &amp;&amp; orderNum &gt; 10)      then          BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());          BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(&quot;0.18&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);          //代驾司机个税，税率：10%          BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);          profitsharingRuleResponse.setPlatformIncome(platformIncome);          profitsharingRuleResponse.setDriverIncome(driverIncome);          profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(&quot;0.1&quot;));          profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);          System.out.println(&quot;平台分账收入：&quot; + platformIncome + &quot;元&quot; + &quot;，司机分账收入：&quot; + driverIncome + &quot;元&quot; + &quot;，司机个税：&quot; + driverTaxFee + &quot;元&quot;);  end    /**  订单金额大于100      当天完成订单小于等于10单 平台抽成 18%      当天完成订单大于10单 平台抽成 16%  */  rule &quot;订单金额大于100 当天完成订单小于等于10单&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() &gt; 100.0 &amp;&amp; orderNum &lt;= 10)      then          BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());          BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(&quot;0.18&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);          //代驾司机个税，税率：10%          BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);          profitsharingRuleResponse.setPlatformIncome(platformIncome);          profitsharingRuleResponse.setDriverIncome(driverIncome);          profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(&quot;0.1&quot;));          profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);          System.out.println(&quot;平台分账收入：&quot; + platformIncome + &quot;元&quot; + &quot;，司机分账收入：&quot; + driverIncome + &quot;元&quot; + &quot;，司机个税：&quot; + driverTaxFee + &quot;元&quot;);  end  rule &quot;订单金额大于100 天完成订单大于10单&quot;      salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行      no-loop true         //防止陷入死循环      when          /*规则条件，到工作内存中查找FeeRuleRequest对象          里面出来的结果只能是ture或者false          $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/          $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() &gt; 100.0 &amp;&amp; orderNum &gt; 10)      then          BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());          BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(&quot;0.18&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);          //代驾司机个税，税率：10%          BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(&quot;0.1&quot;)).setScale(2, RoundingMode.HALF_UP);          BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);          profitsharingRuleResponse.setPlatformIncome(platformIncome);          profitsharingRuleResponse.setDriverIncome(driverIncome);          profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(&quot;0.1&quot;));          profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);          System.out.println(&quot;平台分账收入：&quot; + platformIncome + &quot;元&quot; + &quot;，司机分账收入：&quot; + driverIncome + &quot;元&quot; + &quot;，司机个税：&quot; + driverTaxFee + &quot;元&quot;);  end

规则微服务接口ProfitsharingRuleController
@Autowired  private ProfitsharingRuleService profitsharingRuleService;    @Operation(summary = &quot;计算系统分账费用&quot;)  @PostMapping(&quot;/calculateOrderProfitsharingFee&quot;)  public Result&lt;ProfitsharingRuleResponseVo&gt; calculateOrderProfitsharingFee(@RequestBody ProfitsharingRuleRequestForm profitsharingRuleRequestForm) &#123;      return Result.ok(profitsharingRuleService.calculateOrderProfitsharingFee(profitsharingRuleRequestForm));  &#125;

service
@Autowired  private ProfitsharingRuleMapper rewardRuleMapper;    private static final String RULES_CUSTOMER_RULES_DRL = &quot;rules/ProfitsharingRule.drl&quot;;    @Override  public ProfitsharingRuleResponseVo calculateOrderProfitsharingFee(ProfitsharingRuleRequestForm profitsharingRuleRequestForm) &#123;      //传入参数对象封装      ProfitsharingRuleRequest profitsharingRuleRequest = new ProfitsharingRuleRequest();      profitsharingRuleRequest.setOrderAmount(profitsharingRuleRequestForm.getOrderAmount());      profitsharingRuleRequest.setOrderNum(profitsharingRuleRequestForm.getOrderNum());        //创建kieSession      KieSession kieSession = DroolsHelper.loadForRule(RULES_CUSTOMER_RULES_DRL);        //封装返回对象      ProfitsharingRuleResponse profitsharingRuleResponse = new ProfitsharingRuleResponse();      kieSession.setGlobal(&quot;profitsharingRuleResponse&quot;,profitsharingRuleResponse);        //触发规则，返回vo对象      kieSession.insert(profitsharingRuleRequest);      kieSession.fireAllRules();      kieSession.dispose();        ProfitsharingRuleResponseVo profitsharingRuleResponseVo = new ProfitsharingRuleResponseVo();      BeanUtils.copyProperties(profitsharingRuleResponse,profitsharingRuleResponseVo);        return profitsharingRuleResponseVo;  &#125;

远程调用ProfitsharingRuleFeignClient
/**   * 计算订单分账数据   * @param profitsharingRuleRequestForm   * @return   */  @PostMapping(&quot;/rules/profitsharing/calculateOrderProfitsharingFee&quot;)  Result&lt;ProfitsharingRuleResponseVo&gt; calculateOrderProfitsharingFee(@RequestBody ProfitsharingRuleRequestForm profitsharingRuleRequestForm);

结束服务更新订单
更新订单数据：订单状态、订单实际距离、订单实际金额等
添加实际账单信息
添加分账信息

订单微服务接口OrderInfoController
@Operation(summary = &quot;结束代驾服务更新订单账单&quot;)  @PostMapping(&quot;/endDrive&quot;)  public Result&lt;Boolean&gt; endDrive(@RequestBody UpdateOrderBillForm updateOrderBillForm) &#123;      return Result.ok(orderInfoService.endDrive(updateOrderBillForm));  &#125;

service
@Autowired  private OrderBillMapper orderBillMapper;@Autowired  private OrderProfitsharingMapper orderProfitsharingMapper;// 结束代驾服务更新订单账单  @Override  public Boolean endDrive(UpdateOrderBillForm updateOrderBillForm) &#123;      // 更新订单信息      LambdaQueryWrapper&lt;OrderInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderInfo::getId,updateOrderBillForm.getOrderId());      wrapper.eq(OrderInfo::getDriverId,updateOrderBillForm.getDriverId());        OrderInfo orderInfo = new OrderInfo();      orderInfo.setStatus(OrderStatus.END_SERVICE.getStatus());      orderInfo.setRealAmount(updateOrderBillForm.getTotalAmount());      orderInfo.setFavourFee(updateOrderBillForm.getFavourFee());      orderInfo.setRealDistance(updateOrderBillForm.getRealDistance());      orderInfo.setEndServiceTime(new Date());        int rows = orderInfoMapper.update(orderInfo, wrapper);        if(rows == 1) &#123;          //添加账单数据          OrderBill orderBill = new OrderBill();          BeanUtils.copyProperties(updateOrderBillForm,orderBill);          orderBill.setOrderId(updateOrderBillForm.getOrderId());          orderBill.setPayAmount(updateOrderBillForm.getTotalAmount());          orderBillMapper.insert(orderBill);            //添加分账信息          OrderProfitsharing orderProfitsharing = new OrderProfitsharing();          BeanUtils.copyProperties(updateOrderBillForm, orderProfitsharing);          orderProfitsharing.setOrderId(updateOrderBillForm.getOrderId());          orderProfitsharing.setRuleId(updateOrderBillForm.getProfitsharingRuleId());          orderProfitsharing.setStatus(1);          orderProfitsharingMapper.insert(orderProfitsharing);        &#125; else &#123;          throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);      &#125;      return true;  &#125;

远程调用OrderInfoFeignClient
/**   * 结束代驾服务更新订单账单   * @param updateOrderBillForm   * @return   */  @PostMapping(&quot;/order/info/endDrive&quot;)  Result&lt;Boolean&gt; endDrive(@RequestBody UpdateOrderBillForm updateOrderBillForm);

结束服务web-driver中的OrderController
@Operation(summary = &quot;结束代驾服务更新订单账单&quot;)  @LoginDetection  @PostMapping(&quot;/endDrive&quot;)  public Result&lt;Boolean&gt; endDrive(@RequestBody OrderFeeForm orderFeeForm) &#123;      Long driverId = AuthContextHolder.getUserId();      orderFeeForm.setDriverId(driverId);      return Result.ok(orderService.endDrive(orderFeeForm));  &#125;

service
@Autowired  private LocationFeignClient locationFeignClient;    @Autowired  private FeeRuleFeignClient feeRuleFeignClient;    @Autowired  private RewardRuleFeignClient rewardRuleFeignClient;    @Autowired  private ProfitsharingRuleFeignClient profitsharingRuleFeignClient;// 结束代驾服务更新订单账单  @Override  public Boolean endDrive(OrderFeeForm orderFeeForm) &#123;      // 根据orderId获取订单信息，判断当前订单是否司机接单      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();      if(orderInfo.getDriverId() != orderFeeForm.getDriverId()) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        // 计算订单实际里程      BigDecimal realDistance =              locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();        // 计算代驾实际费用      //封装FeeRuleRequestForm      FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();      feeRuleRequestForm.setDistance(realDistance);      feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());        //计算司机到达代驾开始位置时间      Integer waitMinute =              Math.abs((int)((orderInfo.getStartServiceTime().getTime()-orderInfo.getArriveTime().getTime())/(1000 * 60)));      feeRuleRequestForm.setWaitMinute(waitMinute);      //远程调用 代驾费用      FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();      //实际费用 = 代驾费用 + 其他费用（停车费）      BigDecimal totalAmount =              feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())                      .add(orderFeeForm.getParkingFee())                      .add(orderFeeForm.getOtherFee())                      .add(orderInfo.getFavourFee());      feeRuleResponseVo.setTotalAmount(totalAmount);        // 计算系统奖励      String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 00:00:00&quot;;      String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 24:00:00&quot;;      Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();        RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();      rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());      rewardRuleRequestForm.setOrderNum(orderNum);        RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();        // 计算分账信息      ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();      profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());      profitsharingRuleRequestForm.setOrderNum(orderNum);        ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();        // 封装实体类，结束代驾更新订单，添加账单和分账信息      UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();      updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());      updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());      //路桥费、停车费、其他费用      updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());      updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());      updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());      //乘客好处费      updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());        //实际里程      updateOrderBillForm.setRealDistance(realDistance);      //订单奖励信息      BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);      //代驾费用信息      BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);      //分账相关信息      BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);      updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());      orderInfoFeignClient.endDrive(updateOrderBillForm);        return true;  &#125;

添加位置限定修改之前web-driver中OrderServiceImpl编写的方法，在开始订单做判断
//司机到达代驾起始地点  @Override  public Boolean driverArriveStartLocation(Long orderId, Long driverId) &#123;      //判断      // orderInfo有代驾开始位置      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();        //司机当前位置      OrderLocationVo orderLocationVo = locationFeignClient.getCacheOrderLocation(orderId).getData();        //司机当前位置 和 代驾开始位置距离      double distance = LocationUtil.getDistance(orderInfo.getStartPointLatitude().doubleValue(),              orderInfo.getStartPointLongitude().doubleValue(),              orderLocationVo.getLatitude().doubleValue(),              orderLocationVo.getLongitude().doubleValue());      if(distance &gt; SystemConstant.DRIVER_START_LOCATION_DISTION) &#123;          throw new GuiguException(ResultCodeEnum.DRIVER_START_LOCATION_DISTION_ERROR);      &#125;        return orderInfoFeignClient.driverArriveStartLocation(orderId,driverId).getData();  &#125;

结束订单也是一样
// 结束代驾服务更新订单账单  @Override  public Boolean endDrive(OrderFeeForm orderFeeForm) &#123;      // 根据orderId获取订单信息，判断当前订单是否司机接单      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();      if(orderInfo.getDriverId() != orderFeeForm.getDriverId()) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        // 判断距离      OrderServiceLastLocationVo orderServiceLastLocationVo = locationFeignClient.getOrderServiceLastLocation(orderFeeForm.getOrderId()).getData();        //司机当前位置 距离 结束代驾位置      double distance = LocationUtil.getDistance(orderInfo.getEndPointLatitude().doubleValue(),              orderInfo.getEndPointLongitude().doubleValue(),              orderServiceLastLocationVo.getLatitude().doubleValue(),              orderServiceLastLocationVo.getLongitude().doubleValue());      if(distance &gt; SystemConstant.DRIVER_END_LOCATION_DISTION) &#123;          throw new GuiguException(ResultCodeEnum.DRIVER_END_LOCATION_DISTION_ERROR);      &#125;        // 计算订单实际里程      BigDecimal realDistance =              locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();        // 计算代驾实际费用      //封装FeeRuleRequestForm      FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();      feeRuleRequestForm.setDistance(realDistance);      feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());        //计算司机到达代驾开始位置时间      Integer waitMinute =              Math.abs((int)((orderInfo.getStartServiceTime().getTime()-orderInfo.getArriveTime().getTime())/(1000 * 60)));      feeRuleRequestForm.setWaitMinute(waitMinute);      //远程调用 代驾费用      FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();      //实际费用 = 代驾费用 + 其他费用（停车费）      BigDecimal totalAmount =              feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())                      .add(orderFeeForm.getParkingFee())                      .add(orderFeeForm.getOtherFee())                      .add(orderInfo.getFavourFee());      feeRuleResponseVo.setTotalAmount(totalAmount);        // 计算系统奖励      String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 00:00:00&quot;;      String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 24:00:00&quot;;      Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();        RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();      rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());      rewardRuleRequestForm.setOrderNum(orderNum);        RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();        // 计算分账信息      ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();      profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());      profitsharingRuleRequestForm.setOrderNum(orderNum);        ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();        // 封装实体类，结束代驾更新订单，添加账单和分账信息      UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();      updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());      updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());      //路桥费、停车费、其他费用      updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());      updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());      updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());      //乘客好处费      updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());        //实际里程      updateOrderBillForm.setRealDistance(realDistance);      //订单奖励信息      BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);      //代驾费用信息      BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);      //分账相关信息      BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);      updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());      orderInfoFeignClient.endDrive(updateOrderBillForm);        return true;  &#125;


我的订单和异步编排我的订单
乘客端或司机端，都有我的订单，都可以查看用户所有的订单

乘客端我的订单订单微服务接口OrderInfoController
@Operation(summary = &quot;获取乘客订单分页列表&quot;)  @GetMapping(&quot;/findCustomerOrderPage/&#123;customerId&#125;/&#123;page&#125;/&#123;limit&#125;&quot;)  public Result&lt;PageVo&gt; findCustomerOrderPage(@PathVariable Long customerId,                                              @PathVariable Long page,                                              @PathVariable Long limit) &#123;      //创建page对象      Page&lt;OrderInfo&gt; pageParam = new Page&lt;&gt;(page,limit);      //调用service方法实现分页条件查询      PageVo pageVo = orderInfoService.findCustomerOrderPage(pageParam,customerId);      pageVo.setPage(page);      pageVo.setLimit(limit);      return Result.ok(pageVo);  &#125;

service
//获取乘客订单分页列表  @Override  public PageVo findCustomerOrderPage(Page&lt;OrderInfo&gt; pageParam, Long customerId) &#123;      IPage&lt;OrderListVo&gt; pageInfo =  orderInfoMapper.selectCustomerOrderPage(pageParam,customerId);      return new PageVo&lt;&gt;(pageInfo.getRecords(),pageInfo.getPages(),pageInfo.getTotal());  &#125;

远程调用OrderInfoFeignClient
/**   * 获取乘客订单分页列表   * @param customerId   * @param page   * @param limit   * @return   */  @GetMapping(&quot;/order/info/findCustomerOrderPage/&#123;customerId&#125;/&#123;page&#125;/&#123;limit&#125;&quot;)  Result&lt;PageVo&gt; findCustomerOrderPage(@PathVariable(&quot;customerId&quot;) Long customerId,                                       @PathVariable(&quot;page&quot;) Long page,                                       @PathVariable(&quot;limit&quot;) Long limit);

乘客web端调用OrderController
@Operation(summary = &quot;获取乘客订单分页列表&quot;)  @LoginDetection  @GetMapping(&quot;findCustomerOrderPage/&#123;page&#125;/&#123;limit&#125;&quot;)  public Result&lt;PageVo&gt; findCustomerOrderPage(          @Parameter(name = &quot;page&quot;, description = &quot;当前页码&quot;, required = true)          @PathVariable Long page,            @Parameter(name = &quot;limit&quot;, description = &quot;每页记录数&quot;, required = true)          @PathVariable Long limit) &#123;      Long customerId = AuthContextHolder.getUserId();      PageVo pageVo = orderService.findCustomerOrderPage(customerId, page, limit);      return Result.ok(pageVo);  &#125;

service
// 获取乘客订单分页列表  @Override  public PageVo findCustomerOrderPage(Long customerId, Long page, Long limit) &#123;      return orderInfoFeignClient.findCustomerOrderPage(customerId,page,limit).getData();  &#125;

xml
&lt;!--查询乘客订单分页--&gt;&lt;select id=&quot;selectCustomerOrderPage&quot; resultType=&quot;com.atguigu.daijia.model.vo.order.OrderListVo&quot;&gt;    select        info.id,        info.order_no,        info.start_location,        info.end_location,        if(info.status &amp;lt; 7, info.expect_amount, bill.pay_amount) as amount,        info.status,        info.create_time    from order_info info left join order_bill bill on info.id = bill.order_id    where info.customer_id = #&#123;customerId&#125;      and info.is_deleted =0    order by info.create_time desc&lt;/select&gt;

司机端我的订单订单微服务接口OrderInfoController
@Operation(summary = &quot;获取司机订单分页列表&quot;)  @GetMapping(&quot;/findDriverOrderPage/&#123;driverId&#125;/&#123;page&#125;/&#123;limit&#125;&quot;)  public Result&lt;PageVo&gt; findDriverOrderPage(          @Parameter(name = &quot;driverId&quot;, description = &quot;司机id&quot;, required = true)          @PathVariable Long driverId,          @Parameter(name = &quot;page&quot;, description = &quot;当前页码&quot;, required = true)          @PathVariable Long page,          @Parameter(name = &quot;limit&quot;, description = &quot;每页记录数&quot;, required = true)          @PathVariable Long limit) &#123;      Page&lt;OrderInfo&gt; pageParam = new Page&lt;&gt;(page, limit);      PageVo pageVo = orderInfoService.findDriverOrderPage(pageParam, driverId);      pageVo.setPage(page);      pageVo.setLimit(limit);      return Result.ok(pageVo);  &#125;

service
// 获取司机订单分页列表  @Override  public PageVo findDriverOrderPage(Page&lt;OrderInfo&gt; pageParam, Long driverId) &#123;      IPage&lt;OrderListVo&gt; pageInfo =  orderInfoMapper.selectDriverOrderPage(pageParam,driverId);      return new PageVo&lt;&gt;(pageInfo.getRecords(),pageInfo.getPages(),pageInfo.getTotal());  &#125;

xml
&lt;select id=&quot;selectDriverOrderPage&quot; resultType=&quot;com.atguigu.daijia.model.vo.order.OrderListVo&quot;&gt;    select        info.id,        info.order_no,        info.start_location,        info.end_location,        real_amount as pay_amount,        if(info.status &amp;lt; 7, info.expect_amount, info.real_amount) as amount,        info.status,        info.create_time    from order_info info    where info.driver_id = #&#123;driverId&#125;    and info.is_deleted =0    order by info.create_time desc&lt;/select&gt;

远程调用OrderInfoFeignClient
/**   * 获取司机订单分页列表   * @param driverId   * @param page   * @param limit   * @return   */  @GetMapping(&quot;/order/info/findDriverOrderPage/&#123;driverId&#125;/&#123;page&#125;/&#123;limit&#125;&quot;)  Result&lt;PageVo&gt; findDriverOrderPage(@PathVariable(&quot;driverId&quot;) Long driverId,                                     @PathVariable(&quot;page&quot;) Long page,                                     @PathVariable(&quot;limit&quot;) Long limit);

司机端web接口OrderController
@Operation(summary = &quot;获取司机订单分页列表&quot;)  @LoginDetection  @GetMapping(&quot;findDriverOrderPage/&#123;page&#125;/&#123;limit&#125;&quot;)  public Result&lt;PageVo&gt; findDriverOrderPage(          @Parameter(name = &quot;page&quot;, description = &quot;当前页码&quot;, required = true)          @PathVariable Long page,          @Parameter(name = &quot;limit&quot;, description = &quot;每页记录数&quot;, required = true)          @PathVariable Long limit) &#123;      Long driverId = AuthContextHolder.getUserId();      PageVo pageVo = orderService.findDriverOrderPage(driverId, page, limit);      return Result.ok(pageVo);  &#125;

service
// 获取司机订单分页列表  @Override  public PageVo findDriverOrderPage(Long driverId, Long page, Long limit) &#123;      return orderInfoFeignClient.findDriverOrderPage(driverId,page,limit).getData();  &#125;

异步编排
问题：司机结束订单后会有大量的远程调用，如果按照流程来会浪费大量时间
解决：使用多线程方式来完成这些操作

创建自定义线程池在config包下创建类ThreadPoolConfig
@Configuration  public class ThreadPoolConfig &#123;        @Bean      public ThreadPoolExecutor threadPoolExecutor() &#123;            //动态获取服务器核数          int processors = Runtime.getRuntime().availableProcessors();          ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(                  processors+1, // 核心线程个数 io:2n ,cpu: n+1  n:内核数据                  processors+1,                  0,                  TimeUnit.SECONDS,                  new ArrayBlockingQueue&lt;&gt;(3),                  Executors.defaultThreadFactory(),                  new ThreadPoolExecutor.AbortPolicy()          );          return threadPoolExecutor;      &#125;  &#125;

修改web-driver之前的代码修改前面driver-web里OrderServiceImpl的endDrive方法
//使用多线程CompletableFuture实现  @SneakyThrows  public Boolean endDrive(OrderFeeForm orderFeeForm) &#123;        //1 根据orderId获取订单信息，判断当前订单是否司机接单      CompletableFuture&lt;OrderInfo&gt; orderInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;          OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();          if (orderInfo.getDriverId() != orderFeeForm.getDriverId()) &#123;              throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);          &#125;          return orderInfo;      &#125;);        //防止刷单      CompletableFuture&lt;OrderServiceLastLocationVo&gt; orderServiceLastLocationVoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;          OrderServiceLastLocationVo orderServiceLastLocationVo = locationFeignClient.getOrderServiceLastLocation(orderFeeForm.getOrderId()).getData();          return orderServiceLastLocationVo;      &#125;);        //上面两个合并      CompletableFuture.allOf(orderInfoCompletableFuture,              orderServiceLastLocationVoCompletableFuture).join();        //获取两个线程执行结果      OrderInfo orderInfo = orderInfoCompletableFuture.get();        OrderServiceLastLocationVo orderServiceLastLocationVo = orderServiceLastLocationVoCompletableFuture.get();        //司机当前位置 距离 结束代驾位置      double distance = LocationUtil.getDistance(orderInfo.getEndPointLatitude().doubleValue(),              orderInfo.getEndPointLongitude().doubleValue(),              orderServiceLastLocationVo.getLatitude().doubleValue(),              orderServiceLastLocationVo.getLongitude().doubleValue());      if(distance &gt; SystemConstant.DRIVER_END_LOCATION_DISTION) &#123;          throw new GuiguException(ResultCodeEnum.DRIVER_END_LOCATION_DISTION_ERROR);      &#125;        //2 计算订单实际里程      CompletableFuture&lt;BigDecimal&gt; realDistanceCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;          BigDecimal realDistance =                  locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();          return realDistance;      &#125;);        //3 计算代驾实际费用      CompletableFuture&lt;FeeRuleResponseVo&gt; feeRuleResponseVoCompletableFuture =              realDistanceCompletableFuture.thenApplyAsync((realDistance) -&gt; &#123;                  //远程调用，计算代驾费用                  //封装FeeRuleRequestForm                  FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();                  feeRuleRequestForm.setDistance(realDistance);                  feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());                    //计算司机到达代驾开始位置时间                  //orderInfo.getArriveTime() - orderInfo.getAcceptTime()                  // 分钟 = 毫秒 / 1000 * 60                Integer waitMinute =                          Math.abs((int) ((orderInfo.getArriveTime().getTime() - orderInfo.getAcceptTime().getTime()) / (1000 * 60)));                  feeRuleRequestForm.setWaitMinute(waitMinute);                  //远程调用 代驾费用                  FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();                  //实际费用 = 代驾费用 + 其他费用（停车费）                  BigDecimal totalAmount =                          feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())                                  .add(orderFeeForm.getParkingFee())                                  .add(orderFeeForm.getOtherFee())                                  .add(orderInfo.getFavourFee());                  feeRuleResponseVo.setTotalAmount(totalAmount);                  return feeRuleResponseVo;              &#125;);        //4 计算系统奖励      CompletableFuture&lt;Long&gt; orderNumCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;          String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 00:00:00&quot;;          String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(&quot;yyyy-MM-dd&quot;) + &quot; 24:00:00&quot;;          Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();          return orderNum;      &#125;);        CompletableFuture&lt;RewardRuleResponseVo&gt; rewardRuleResponseVoCompletableFuture =              orderNumCompletableFuture.thenApplyAsync((orderNum) -&gt; &#123;                  //4.2.封装参数                  RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();                  rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());                  rewardRuleRequestForm.setOrderNum(orderNum);                  RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();                    return rewardRuleResponseVo;              &#125;);          //5 计算分账信息      CompletableFuture&lt;ProfitsharingRuleResponseVo&gt; profitsharingRuleResponseVoCompletableFuture = feeRuleResponseVoCompletableFuture.thenCombineAsync(orderNumCompletableFuture,              (feeRuleResponseVo, orderNum) -&gt; &#123;                  ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();                  profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());                  profitsharingRuleRequestForm.setOrderNum(orderNum);                    ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();                  return profitsharingRuleResponseVo;              &#125;);        //合并      CompletableFuture.allOf(              orderInfoCompletableFuture,              realDistanceCompletableFuture,              feeRuleResponseVoCompletableFuture,              orderNumCompletableFuture,              rewardRuleResponseVoCompletableFuture,              profitsharingRuleResponseVoCompletableFuture      ).join();        //获取执行结果      BigDecimal realDistance = realDistanceCompletableFuture.get();      FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoCompletableFuture.get();      RewardRuleResponseVo rewardRuleResponseVo = rewardRuleResponseVoCompletableFuture.get();      ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleResponseVoCompletableFuture.get();        //6 封装实体类，结束代驾更新订单，添加账单和分账信息      UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();      updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());      updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());      //路桥费、停车费、其他费用      updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());      updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());      updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());      //乘客好处费      updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());        //实际里程      updateOrderBillForm.setRealDistance(realDistance);      //订单奖励信息      BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);      //代驾费用信息      BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);      //分账相关信息      BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);      updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());      orderInfoFeignClient.endDrive(updateOrderBillForm);        return true;  &#125;

订单支付账单信息
司机结束代价后，生成账单（包含账单信息和分账信息）

获取账单信息订单微服务接口OrderInfoController
@Operation(summary = &quot;根据订单id获取实际账单信息&quot;)  @GetMapping(&quot;/getOrderBillInfo/&#123;orderId&#125;&quot;)  public Result&lt;OrderBillVo&gt; getOrderBillInfo(@PathVariable Long orderId) &#123;      return Result.ok(orderInfoService.getOrderBillInfo(orderId));  &#125;

service
// 根据订单id获取实际账单信息  @Override  public OrderBillVo getOrderBillInfo(Long orderId) &#123;      LambdaQueryWrapper&lt;OrderBill&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderBill::getOrderId,orderId);      OrderBill orderBill = orderBillMapper.selectOne(wrapper);        OrderBillVo orderBillVo = new OrderBillVo();      BeanUtils.copyProperties(orderBill,orderBillVo);      return orderBillVo;  &#125;

远程调用OrderInfoFeignClient
/**   * 根据订单id获取实际账单信息   * @param orderId   * @return   */  @GetMapping(&quot;/order/info/getOrderBillInfo/&#123;orderId&#125;&quot;)  Result&lt;OrderBillVo&gt; getOrderBillInfo(@PathVariable(&quot;orderId&quot;) Long orderId);

获取分账信息订单微服务接口OrderInfoController
@Operation(summary = &quot;根据订单id获取实际分账信息&quot;)  @GetMapping(&quot;/getOrderProfitsharing/&#123;orderId&#125;&quot;)  public Result&lt;OrderProfitsharingVo&gt; getOrderProfitsharing(@PathVariable Long orderId) &#123;      return Result.ok(orderInfoService.getOrderProfitsharing(orderId));  &#125;

service
// 根据订单id获取实际分账信息  @Override  public OrderProfitsharingVo getOrderProfitsharing(Long orderId) &#123;      LambdaQueryWrapper&lt;OrderProfitsharing&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(OrderProfitsharing::getOrderId,orderId);      OrderProfitsharing orderProfitsharing = orderProfitsharingMapper.selectOne(wrapper);        OrderProfitsharingVo orderProfitsharingVo = new OrderProfitsharingVo();      BeanUtils.copyProperties(orderProfitsharing,orderProfitsharingVo);      return orderProfitsharingVo;  &#125;
远程调用OrderInfoFeignClient
/** * 根据订单id获取实际分账信息 * @param orderId * @return */@GetMapping(&quot;/order/info/getOrderProfitsharing/&#123;orderId&#125;&quot;)Result&lt;OrderProfitsharingVo&gt; getOrderProfitsharing(@PathVariable(&quot;orderId&quot;) Long orderId);

司机端获取账单信息方法之前有，只需要改serviceOrderController&#96;
@Operation(summary = &quot;获取订单账单详细信息&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderInfo/&#123;orderId&#125;&quot;)  public Result&lt;OrderInfoVo&gt; getOrderInfo(@PathVariable Long orderId) &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.getOrderInfo(orderId, driverId));  &#125;

service
// 获取订单账单详细信息  @Override  public OrderInfoVo getOrderInfo(Long orderId, Long driverId) &#123;      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();      if(orderInfo.getDriverId() != driverId) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        //获取账单和分账数据，封装到vo里面      OrderBillVo orderBillVo = null;      OrderProfitsharingVo orderProfitsharingVo = null;      //判断      if(orderInfo.getStatus() &gt;= OrderStatus.END_SERVICE.getStatus()) &#123;          //账单信息          orderBillVo = orderInfoFeignClient.getOrderBillInfo(orderId).getData();            //分账信息          orderProfitsharingVo = orderInfoFeignClient.getOrderProfitsharing(orderId).getData();      &#125;        OrderInfoVo orderInfoVo = new OrderInfoVo();      orderInfoVo.setOrderId(orderId);      BeanUtils.copyProperties(orderInfo,orderInfoVo);      orderInfoVo.setOrderBillVo(orderBillVo);      orderInfoVo.setOrderProfitsharingVo(orderProfitsharingVo);      return orderInfoVo;  &#125;

司机发送账单订单微服务接口OrderInfoController
@Operation(summary = &quot;发送账单信息&quot;)  @GetMapping(&quot;/sendOrderBillInfo/&#123;orderId&#125;/&#123;driverId&#125;&quot;)  Result&lt;Boolean&gt; sendOrderBillInfo(@PathVariable Long orderId, @PathVariable Long driverId) &#123;      return Result.ok(orderInfoService.sendOrderBillInfo(orderId, driverId));  &#125;

service
// 发送账单信息  @Override  public Boolean sendOrderBillInfo(Long orderId, Long driverId) &#123;      //更新订单信息      LambdaQueryWrapper&lt;OrderInfo&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();      queryWrapper.eq(OrderInfo::getId, orderId);      queryWrapper.eq(OrderInfo::getDriverId, driverId);      //更新字段      OrderInfo updateOrderInfo = new OrderInfo();      updateOrderInfo.setStatus(OrderStatus.UNPAID.getStatus());      //只能更新自己的订单      int row = orderInfoMapper.update(updateOrderInfo, queryWrapper);      if(row == 1) &#123;          return true;      &#125; else &#123;          throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);      &#125;  &#125;

远程调用OrderInfoFeignClient
/**   * 司机发送账单信息   * @param orderId   * @param driverId   * @return   */  @GetMapping(&quot;/order/info/sendOrderBillInfo/&#123;orderId&#125;/&#123;driverId&#125;&quot;)  Result&lt;Boolean&gt; sendOrderBillInfo(@PathVariable(&quot;orderId&quot;) Long orderId, @PathVariable(&quot;driverId&quot;) Long driverId);

司机web端调用OrderController
@Operation(summary = &quot;司机发送账单信息&quot;)  @LoginDetection  @GetMapping(&quot;/sendOrderBillInfo/&#123;orderId&#125;&quot;)  public Result&lt;Boolean&gt; sendOrderBillInfo(@PathVariable Long orderId) &#123;      Long driverId = AuthContextHolder.getUserId();      return Result.ok(orderService.sendOrderBillInfo(orderId, driverId));  &#125;

service
// 司机发送账单信息  @Override  public Boolean sendOrderBillInfo(Long orderId, Long driverId) &#123;      return orderInfoFeignClient.sendOrderBillInfo(orderId, driverId).getData();  &#125;

乘客获取账单也是修改之前写过的代码，只需要修改serviceOrderController
@Operation(summary = &quot;获取订单信息&quot;)  @LoginDetection  @GetMapping(&quot;/getOrderInfo/&#123;orderId&#125;&quot;)  public Result&lt;OrderInfoVo&gt; getOrderInfo(@PathVariable Long orderId) &#123;      Long customerId = AuthContextHolder.getUserId();      return Result.ok(orderService.getOrderInfo(orderId, customerId));  &#125;

service
// 获取订单信息  @Override  public OrderInfoVo getOrderInfo(Long orderId, Long customerId) &#123;      OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();      //判断      if(orderInfo.getCustomerId() != customerId) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        //获取司机信息      DriverInfoVo driverInfoVo = null;      Long driverId = orderInfo.getDriverId();      if(driverId != null) &#123;          driverInfoVo = driverInfoFeignClient.getDriverInfo(driverId).getData();      &#125;        //获取账单信息      OrderBillVo orderBillVo = null;      if(orderInfo.getStatus() &gt;= OrderStatus.UNPAID.getStatus()) &#123;          orderBillVo = orderInfoFeignClient.getOrderBillInfo(orderId).getData();      &#125;        OrderInfoVo orderInfoVo = new OrderInfoVo();      orderInfoVo.setOrderId(orderId);      BeanUtils.copyProperties(orderInfo,orderInfoVo);      orderInfoVo.setOrderBillVo(orderBillVo);      orderInfoVo.setDriverInfoVo(driverInfoVo);      return orderInfoVo;  &#125;

微信支付准备接口获取乘客openidservice-customer中的CustomerInfoController
@Operation(summary = &quot;获取客户OpenId&quot;)  @GetMapping(&quot;/getCustomerOpenId/&#123;customerId&#125;&quot;)  public Result&lt;String&gt; getCustomerOpenId(@PathVariable Long customerId) &#123;      return Result.ok(customerInfoService.getCustomerOpenId(customerId));  &#125;

service
// 获取客户OpenId  @Override  public String getCustomerOpenId(Long customerId) &#123;      LambdaQueryWrapper&lt;CustomerInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();      wrapper.eq(CustomerInfo::getId,customerId);      CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);      return customerInfo.getWxOpenId();  &#125;

远程调用
CustomerInfoFeignClient
/**   * 获取客户OpenId   * @param customerId   * @return   */  @GetMapping(&quot;/customer/info/getCustomerOpenId/&#123;customerId&#125;&quot;)  Result&lt;String&gt; getCustomerOpenId(@PathVariable(&quot;customerId&quot;) Long customerId);

获取司机openidservice-driver中DriverInfoController
@Operation(summary = &quot;获取司机OpenId&quot;)  @GetMapping(&quot;/getDriverOpenId/&#123;driverId&#125;&quot;)  public Result&lt;String&gt; getDriverOpenId(@PathVariable Long driverId) &#123;      return Result.ok(driverInfoService.getDriverOpenId(driverId));  &#125;

serivce
// 获取司机OpenId  @Override  public String getDriverOpenId(Long driverId) &#123;      DriverInfo driverInfo = this.getOne(new LambdaQueryWrapper&lt;DriverInfo&gt;().eq(DriverInfo::getId, driverId).select(DriverInfo::getWxOpenId));      return driverInfo.getWxOpenId();  &#125;

远程调用
DriverInfoFeignClient
/**   * 获取司机OpenId   * @param driverId   * @return   */  @GetMapping(&quot;/driver/info/getDriverOpenId/&#123;driverId&#125;&quot;)  Result&lt;String&gt; getDriverOpenId(@PathVariable(&quot;driverId&quot;) Long driverId);
获取支付信息service-order中OrderInfoController
@Operation(summary = &quot;获取订单支付信息&quot;)@GetMapping(&quot;/getOrderPayVo/&#123;orderNo&#125;/&#123;customerId&#125;&quot;)public Result&lt;OrderPayVo&gt; getOrderPayVo(@PathVariable String orderNo, @PathVariable Long customerId) &#123;    return Result.ok(orderInfoService.getOrderPayVo(orderNo, customerId));&#125;

service
// 获取订单支付信息  @Override  public OrderPayVo getOrderPayVo(String orderNo, Long customerId) &#123;      OrderPayVo orderPayVo = orderInfoMapper.selectOrderPayVo(orderNo,customerId);      if(orderPayVo != null) &#123;          String content = orderPayVo.getStartLocation() + &quot; 到 &quot;+orderPayVo.getEndLocation();          orderPayVo.setContent(content);      &#125;      return orderPayVo;  &#125;

远程调用
/**   * 获取订单支付信息   * @param orderNo   * @param customerId   * @return   */  @GetMapping(&quot;/order/info/getOrderPayVo/&#123;orderNo&#125;/&#123;customerId&#125;&quot;)  Result&lt;OrderPayVo&gt; getOrderPayVo(@PathVariable(&quot;orderNo&quot;) String orderNo, @PathVariable(&quot;customerId&quot;) Long customerId);


微信支付接口在service-payment下

导入依赖
&lt;dependency&gt;      &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt;      &lt;artifactId&gt;wechatpay-java&lt;/artifactId&gt;  &lt;/dependency&gt;

创建配置类
@Configuration  @ConfigurationProperties(prefix=&quot;wx.v3pay&quot;) //读取节点  @Data  public class WxPayV3Properties &#123;        private String appid;      /** 商户号 */      public String merchantId;      /** 商户API私钥路径 */      public String privateKeyPath;      /** 商户证书序列号 */      public String merchantSerialNumber;      /** 商户APIV3密钥 */      public String apiV3key;      /** 回调地址 */      private String notifyUrl;        @Bean      public RSAAutoCertificateConfig getConfig()&#123;          return new RSAAutoCertificateConfig.Builder()                  .merchantId(this.getMerchantId())                  .privateKeyFromPath(this.getPrivateKeyPath())                  .merchantSerialNumber(this.getMerchantSerialNumber())                  .apiV3Key(this.getApiV3key())                  .build();        &#125;  &#125;

WxPayController
@Autowired  private WxPayService wxPayService;    @Operation(summary = &quot;创建微信支付&quot;)  @PostMapping(&quot;/createJsapi&quot;)  public Result&lt;WxPrepayVo&gt; createWxPayment(@RequestBody PaymentInfoForm paymentInfoForm) &#123;      return Result.ok(wxPayService.createWxPayment(paymentInfoForm));  &#125;


远程调用

WxPayFeignClient
/**   * 创建微信支付   * @param paymentInfoForm   * @return   */  @PostMapping(&quot;/payment/wxPay/createWxPayment&quot;)  Result&lt;WxPrepayVo&gt; createWxPayment(@RequestBody PaymentInfoForm paymentInfoForm);


乘客web端调用

OrderController
@Operation(summary = &quot;创建微信支付&quot;)  @LoginDetection  @PostMapping(&quot;/createWxPayment&quot;)  public Result&lt;WxPrepayVo&gt; createWxPayment(@RequestBody CreateWxPaymentForm createWxPaymentForm) &#123;      Long customerId = AuthContextHolder.getUserId();      createWxPaymentForm.setCustomerId(customerId);      return Result.ok(orderService.createWxPayment(createWxPaymentForm));  &#125;

service
@Override  public WxPrepayVo createWxPayment(CreateWxPaymentForm createWxPaymentForm) &#123;      //获取订单支付信息      OrderPayVo orderPayVo = orderInfoFeignClient.getOrderPayVo(createWxPaymentForm.getOrderNo(),              createWxPaymentForm.getCustomerId()).getData();      //判断      if(orderPayVo.getStatus() != OrderStatus.UNPAID.getStatus()) &#123;          throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);      &#125;        //获取乘客和司机openid      String customerOpenId = customerInfoFeignClient.getCustomerOpenId(orderPayVo.getCustomerId()).getData();        String driverOpenId = driverInfoFeignClient.getDriverOpenId(orderPayVo.getDriverId()).getData();        //封装需要数据到实体类，远程调用发起微信支付      PaymentInfoForm paymentInfoForm = new PaymentInfoForm();      paymentInfoForm.setCustomerOpenId(customerOpenId);      paymentInfoForm.setDriverOpenId(driverOpenId);      paymentInfoForm.setOrderNo(orderPayVo.getOrderNo());      paymentInfoForm.setAmount(orderPayVo.getPayAmount());      paymentInfoForm.setContent(orderPayVo.getContent());      paymentInfoForm.setPayWay(1);        WxPrepayVo wxPrepayVo = wxPayFeignClient.createWxPayment(paymentInfoForm).getData();      return wxPrepayVo;  &#125;

支付结果查询]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>莫名其妙的报错</title>
    <url>/2025/05/03/articles/Substitute%20driver/%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[太吓人了可恶，今天写完运行的时候报了两个错
D:\Desktop\hhsqdmz\Project\Substitute driver\代码\daijia-parent\service-client\service-map-client\src\main\java\com\atguigu\daijia\map\client\MapFeignClient.java:19:5java: 找不到符号  符号:   类 Result  位置: 接口 com.atguigu.daijia.map.client.MapFeignClientD:\Desktop\hhsqdmz\Project\Substitute driver\代码\daijia-parent\service-client\service-map-client\src\main\java\com\atguigu\daijia\map\client\MapFeignClient.java:3:40 java: 程序包com.atguigu.daijia.common.result不存在

然后我按照报错原因按个排插，看了半天没发现问题，最后我使用了最原始的方法：回溯
我按照步骤挨个回退，一路删删删，最后发现问题居然是ALT+Enter，快速的加入了一个依赖在最外层父项目，然后那个依赖本身就存在，两个相同的依赖导致出错，并且报错原因和真实原因毫不相关
气煞我也！
]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收器</title>
    <url>/2025/05/13/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[**Java分配对象的过程以及新生代和老年代划分的目的
创建一个新的对象实例时，jvm首先会在堆内存分配内存空间，大部分情况下，新对象都会分配到新生代的Eden区，新生代有三个区，一个Eden区和两个survivor区，当Eden区满了以后会进行Minor GC（新生代GC，是指新生代的垃圾收集，一般Eden区满了就执行，非常频繁，回收速度快），在GC的过程中存活的对象会在两个survivor区中进行转移和交换，经过多次GC任然存活的对象会被放入老年代，老年代主要用于存储长期存活的对象或者是大对象。
新生代中如果有比较大的对象比如数组list那些，会直接放入老年代里面。
划分新生代和老年代的主要目的有两个：

新生代采用的是一种简单高效的复制算法进行垃圾回收，可以快速完成垃圾回收减少暂停时间，因为大部分对象都是暂时存在的，所有这种策略能够有效处理大量短暂对象的分配和回收
可以针对不同的对象采取不同的回收策略，新生代频繁回收，老年代较少回收，可以减少full GC（全面垃圾收集，清理新生代与老年代以及方法区，full GC通常比Minor GC慢很多，因为full GC涉及到整个栈的回收，并且在GC期间，应用程序的所有线程都会暂停）的频率，提升系统的整体性能

**标记清除、复制和标记压缩三种垃圾回收算法的基本原理
标记清除算法：遍历所有可达对象标记为存活的状态，然后遍历堆内存，把没有标记的对象全部视为垃圾进行清理

优点  简单，不需要额外的内存空间
缺点  会产生大量的内存碎片，而且效率很低

复制算法：把内存分为两个相等的区域，每次只使用其中一个区域，当这个区域满了以后，把存活的对象复制到另一个区域中并且清除原区域的所有对象

优点  每次垃圾回收后内存都是连续的，不存在内存碎片
缺点  需要额外的占用内存空间，并且对象频繁复制导致效率问题

标记压缩算法：先标记所有可达对象，然后把存活的对象向一端移动，然后直接清理边界外的内存区域，从而消除碎片![[Pasted image 20250513172753.png]]

优点  解决标记清除算法所造成的内存碎片问题，相对复制算法减少了内存空间占用
缺点  复杂度高，而且执行效率相对比较低，特别是压缩阶段需要移动对象，可能会引起程序暂停的时间较长

serial、Parallel、CMS和G1垃圾回收器的主要特点

serial GC是串行垃圾回收器，比较适用于单核处理器或者对响应时间要求不高的场景

Parallel基于多线程并行垃圾回收器，适合高吞吐量的服务器应用或者CPU核心数较多的服务器坏境

CMS也是并且垃圾回收，但是他会把垃圾回收分为四个阶段，尽可能减少了STW（系统在执行特定操作时需暂停所有应用程序线程）的时间，比较适用于高交互性的应用，比如web服务器，以及对停顿时间有严格要求但是对吞吐量比较宽松的场景

G1把堆内存划分了多个大小相等的区域，每个区域都可以独立作为新生代和老年代的一部分，通过并行和并发实现垃圾回收，从而减少停顿时间，另外还能根据目标停顿时间来动态调整垃圾回收策略，来满足不同需求，适合低延迟和可预测的垃圾回收停顿时间的应用，比如大规模分布式系统、在线交易系统


]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>规则引擎</title>
    <url>/2025/04/30/articles/Substitute%20driver/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[规则引擎概述
规则引擎，全称为业务规则管理系统，英文名为BRMS

就是把业务里经常变动的代码给抽离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策

主流产品：drools、VisualRules、iLog


drools概述drools是一款由JBoss组织提供的基于Java语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中(例如存放在数据库中)，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。
drools官网地址：https://drools.org/
drools源码下载地址：https://github.com/kiegroup/drools
基础使用创建spring boot工程引入drools依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;drools&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;java.version&gt;17&lt;/java.version&gt;        &lt;drools.version&gt;8.41.0.Final&lt;/drools.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.drools&lt;/groupId&gt;            &lt;artifactId&gt;drools-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.drools&lt;/groupId&gt;            &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;            &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.drools&lt;/groupId&gt;            &lt;artifactId&gt;drools-decisiontables&lt;/artifactId&gt;            &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.drools&lt;/groupId&gt;            &lt;artifactId&gt;drools-mvel&lt;/artifactId&gt;            &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;

创建drools配置类@Configurationpublic class DroolsConfig &#123;    private static final KieServices kieServices = KieServices.Factory.get();    //制定规则文件的路径    private static final String RULES_CUSTOMER_RULES_DRL = &quot;rules/order.drl&quot;;    @Bean    public KieContainer kieContainer() &#123;        //获得Kie容器对象        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();        kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_CUSTOMER_RULES_DRL));        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem);        kieBuilder.buildAll();        KieModule kieModule = kieBuilder.getKieModule();        KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());        return kieContainer;    &#125;&#125;

定义了一个 KieContainer的Bean ，KieContainer用于通过加载应用程序的/resources文件夹下的规则文件来构建规则引擎。

创建KieFileSystem实例并配置规则引擎并从应用程序的资源目录加载规则的 DRL 文件。

使用KieBuilder实例来构建 drools 模块。我们可以使用KieSerive单例实例来创建 KieBuilder 实例。

最后，使用 KieService 创建一个 KieContainer 并将其配置为 spring bean


创建实体类public class Order &#123;    private double amount;    private double score;    public double getAmount() &#123;        return amount;    &#125;    public void setAmount(double amount) &#123;        this.amount = amount;    &#125;    public double getScore() &#123;        return score;    &#125;    public void setScore(double score) &#123;        this.score = score;    &#125;&#125;

创建规则文件package com.hh.order;import com.hh.bean.Order//规则一：100元以下 不加分rule &quot;order_rule_1&quot;    when        $order:Order(amount &lt; 100)    then        $order.setScore(0);        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end//规则二：100元 - 500元 加100分rule &quot;order_rule_2&quot;    when        $order:Order(amount &gt;= 100 &amp;&amp; amount &lt; 500)    then         $order.setScore(100);         System.out.println(&quot;成功匹配到规则二：100元 - 500元 加100分&quot;);end//规则三：500元 - 1000元 加500分rule &quot;order_rule_3&quot;    when        $order:Order(amount &gt;= 500 &amp;&amp; amount &lt; 1000)    then         $order.setScore(500);         System.out.println(&quot;成功匹配到规则三：500元 - 1000元 加500分&quot;);end//规则四：1000元以上 加1000分rule &quot;order_rule_4&quot;    when        $order:Order(amount &gt;= 1000)    then         $order.setScore(1000);         System.out.println(&quot;成功匹配到规则四：1000元以上 加1000分&quot;);end

测试@SpringBootTestpublic class DroolsDemosApplicationTests &#123;    @Autowired    private KieContainer kieContainer;    @Test    public void test() &#123;        //从Kie容器对象中获取会话对象        KieSession session = kieContainer.newKieSession();        //Fact对象，事实对象        Order order = new Order();        order.setAmount(1300);        //将Order对象插入到工作内存中        session.insert(order);        //激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则        session.fireAllRules();        //关闭会话        session.dispose();        System.out.println(&quot;订单金额：&quot; + order.getAmount() + &quot;，添加积分：&quot; + order.getScore());    &#125;&#125;


使用drools规则引擎主要工作就是编写规则文件，在规则文件中定义跟业务相关的业务规则。规则定义好后就需要调用drools提供的API将数据提供给规则引擎进行规则模式匹配，规则引擎会执行匹配成功的规则并将计算的结果返回
使用规则引擎时业务规则可以做到动态管理，可以做到不重启服务情况下做调整

规则引擎构成drools规则引擎由以下三部分构成：

Working Memory（工作内存）
Rule Base（规则库）
Inference Engine（推理引擎）

其中Inference Engine（推理引擎）又包括：

Pattern Matcher（匹配器）     &#x2F;&#x2F; 具体匹配哪一个规则，由这个完成
Agenda(议程)
Execution Engine（执行引擎）

Working Memory：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如上面调用kieSession.insert(order)就是将order对象插入到了工作内存中。
Fact：事实，是指在drools 规则应用当中，将一个普通的JavaBean插入到Working Memory后的对象就是Fact对象，例如本案例中的Order对象就属于Fact对象。
Rule Base：规则库，我们在规则文件中定义的规则都会被加载到规则库中。
Pattern Matcher：匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda（议程）中。
Agenda：议程，用于存放通过匹配器进行模式匹配后被激活的规则。
Execution Engine：执行引擎，执行Agenda中被激活的规则。
Drools 基础语法基础语法


关键字
描述



package
包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用


import
用于导入类或者静态方法


global
全局变量


function
自定义函数


query
查询


rule end
规则体


Drools 支持的规则文件除了drl格式，还有Excel文件类型



规则体语法rule &quot;ruleName&quot;    attributes    when        LHS     then        RHSend

rule：关键字，表示规则开始，参数为规则的唯一名称。
attributes：规则属性，是rule与when之间的参数，为可选项。
when：关键字，后面跟规则的条件部分。
LHS(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。如果LHS为空，则它将被视为始终为true的条件元素。  （左手边）
then：关键字，后面跟规则的结果部分。
RHS(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）
end：关键字，表示一个规则结束。
Pattern 模式匹配Drools中的匹配器可以将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，条件就叫做Pattern
pattern的语法结构为：绑定变量名:Object(Field约束)
例如：
//规则一：100元以下 不加分rule &quot;order_rule_1&quot;    when        $order:Order(amount &lt; 100)    then        $order.setScore(0);        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end

通过上面的例子可以知道，匹配的条件为：
1、$order对应对象是一个Order这种类型的Fact对象—–类型约束
2、Fact对象的amount属性值必须小于100——属性约束
以上条件必须同时满足当前规则才有可能被激活。
比较运算符


符号
说明



contains
检查一个Fact对象的某个属性值是否包含一个指定的对象值


not contains
检查一个Fact对象的某个属性值是否不包含一个指定的对象值


memberOf
判断一个Fact对象的某个属性是否在一个或多个集合中


not memberOf
判断一个Fact对象的某个属性是否不在一个或多个集合中


matches
判断一个Fact对象的属性是否与提供的标准的Java正则表达式进行匹配


not matches
判断一个Fact对象的属性是否不与提供的标准的Java正则表达式进行匹配


Drools内置方法规则文件的RHS部分的主要作用是通过插入，删除或修改工作内存中的Fact数据，来达到控制规则引擎执行的目的。Drools提供了一些方法可以用来操作工作内存中的数据，操作完成后规则引擎会重新进行相关规则的匹配， 原来没有匹配成功的规则在我们修改数据完成后有可能就会匹配成功了。
修改 updateupdate方法的作用是更新工作内存中的数据，并让相关的规则重新匹配。**（要避免死循环）
**要注意 ;号
以上面的order为例参数：
order.setAmount(30);
规则：
rule &quot;order_rule&quot;	when		$order:Order(amount &lt; 100)	then		$order.setAmount(150);		update($order)		System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);endrule &quot;order_rule2&quot;	when 		$order:Order(amount &gt;= 100 &amp;&amp; amount &lt;= 500)	then		$order.setScore(100);		System.out.println(&quot;成功匹配到规则二：100元 - 500元 加100分&quot;);end


添加 insertinsert方法的作用是向工作内存中插入数据，并让相关的规则重新匹配。
rule &quot;order_rule&quot;	when		$order:Order(amount &lt; 100)	then		Order order = new Order();		order.setAmount(30);		insert($order)		System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);endrule &quot;order_rule2&quot;	when 		$order:Order(amount &gt;= 100 &amp;&amp; amount &lt;= 500)	then		$order.setScore(100);		System.out.println(&quot;成功匹配到规则二：100元 - 500元 加100分&quot;);end
删除 retractretract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。
rule &quot;order_rule_1&quot;    when        $order:Order(amout &lt; 100)    then        retract($order)      //retract方法的作用是删除工作内存中的Fact对象，会导致相关规则重新匹配        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end

规则属性


属性名
说明



salience
指定规则执行优先级


dialect
指定规则使用的语言类型，取值为java和mvel


enabled
指定规则是否启用


date-effective
指定规则生效时间


date-expires
指定规则失效时间


activation-group
激活分组，具有相同分组名称的规则只能有一个规则触发


agenda-group
议程分组，只有获取焦点的组中的规则才有可能触发


timer
定时器，指定规则触发的时间


auto-focus
自动获取焦点，一般结合agenda-group一起使用


no-loop
防止死循环


salience
salience属性用于指定规则的执行优先级，取值类型为Integer。数值越大越优先执行。每个规则都有一个默认的执行顺序，如果不设置salience属性，规则体的执行顺序为由上到下。

package com.orderrule &quot;rule_1&quot;	salience 9    when        eval(true)    then        System.out.println(&quot;规则rule_1触发&quot;);end    rule &quot;rule_2&quot;	salience 10    when        eval(true)    then        System.out.println(&quot;规则rule_2触发&quot;);endrule &quot;rule_3&quot;	salience 7    when        eval(true)    then        System.out.println(&quot;规则rule_3触发&quot;);end

no-loop
no-loop属性用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false

引擎默认不会重复触发同一规则​​例如这个例子，修改了与规则无关的值然后再次进入相同的规则，规则不会再次触发
rule &quot;order_rule_1&quot;    when        $order:Order(amout &lt; 100)    then        $order.setScore(0);        update($order)        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end

想要实现死循环应该修改与规则有关的值，如下
rule &quot;order_rule_1&quot;    when        $order:Order(amount &lt; 100)    then        $order.setAmount(0);        update($order)        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end


避免死循环：rule &quot;order_rule_1&quot;    no-loop true         //防止陷入死循环    when        $order:Order(amount &lt; 100)    then        $order.setAmount(0);        update($order)        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end

高级语法


关键字
描述



package
包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用


import
用于导入类或者静态方法


global
全局变量


function
自定义函数


query
查询


rule end
规则体


global全局变量
global关键字用于在规则文件中定义全局变量，它可以让应用程序的对象在规则文件中能够被访问。可以用来为规则文件提供数据或服务。

语法结构为：global 对象类型 对象名称

注意：

如果对象类型为包装类型时，在一个规则中改变了global的值，那么只针对当前规则有效，对其他规则中的global不会有影响。可以理解为它是当前规则代码中的global副本，规则内部修改不会影响全局的使用。
如果对象类型为集合类型或JavaBean时，在一个规则中改变了global的值，对java代码和所有规则都有效。



规则文件：
package com.hh.orderimport com.hh.bean.Orderglobal com.hh.bean.Order order_global;//规则一：100元以下 不加分rule &quot;order_rule_1&quot;    no-loop true         //防止陷入死循环    when        $order:Order(amount &lt; 100)    then        order_global.setScore(10);        update($order)        System.out.println(&quot;成功匹配到规则一：100元以下 不加分&quot;);end


测试：
@Testpublic void test1()&#123;    //从Kie容器对象中获取会话对象    KieSession session = kieContainer.newKieSession();    //Fact对象，事实对象    Order order = new Order();    order.setAmout(30);    //全局变量    Order order2 = new Order();    session.setGlobal(&quot;order_global&quot;, order2);    //将Order对象插入到工作内存中    session.insert(order);    //激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则    session.fireAllRules();    //关闭会话    session.dispose();    System.out.println(&quot;订单金额：&quot; + order.getAmout());    System.out.println(&quot;添加积分：&quot; + order2.getScore());&#125;









































































]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的 ConcurrentHashMap 1.7 和 1.8 有什么区别</title>
    <url>/2025/12/04/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/Java%20%E4%B8%AD%E7%9A%84%20ConcurrentHashMap%201.7%20%E5%92%8C%201.8%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[这两个版本的区别重点在锁的粒度
ConcurrentHashMap 1.7Java 7 里使用的是分段锁 (Segment)，底层依旧是数组，将数组分成 16 个 Segment，每个 Segment 下都有一个 HashMap 和 一个 ReentrantLock
不同线程访问不同 Segment 并不会触发锁，多线程访问同一个才会竞争，理论并发数默认 16
ConcurrentHashMap 1.8Java 8 里去除了 Segment，采用跟 HashMap 相同的数据结构，数组 + 链表 + 红黑树 ，并且将 ReentrantLock 换成了 Synchronized
CASCAS 能够保证无锁操作下的原子性，具体是三个参数：地址（V）、原本值（A）、修改值（B）

线程先读取内存地址（V）获取值，记录到原本值（A）里

当线程准备更新地址（V）时，会先检查地址（V）当前值是否为记录的原本值（A）

当前值和记录的原本值（A）相同，说明其他线程没有操作过，直接将地址值修改为修改值（B）

当前值和记录的原本值（A）不同，说明其他线程修改过 V 的值，当前线程更新失败，通常尝试自旋或者放弃




1.8 插入插入时采用 CAS 插入方法，冲突才会使用 Synchronized，但只对链表&#x2F;红黑树的头节点上锁
因为锁住了头节点基本等于锁住了整个链表&#x2F;红黑树，其他线程依旧可以对其他 bucket 进行操作，并发度大大提升
扩容的区别Java 7 中的扩容
**基于 Segment**：ConcurrentHashMap 是由多个 Segment 组成的，每个 Segment 里面都包含着一个 HashMap，但 Segment 的数量并不会扩容，扩容的是 Segement 内的 HashMap，当 HashMap 达到扩容因子时，会单独为这个 Segment 进行扩容，并不会对整个 ConcurrentHashMap 进行扩容
扩容过程：每个 Segment 维护自己的扩容因子，当 Segment 里面的元素超过阈值时对该 Segment 进行扩容，扩容过程跟 HashMap 一致，不会影响整个 ConcurrentHashMap

Java 8 中的扩容
全局扩容：整个 ConcurrentHashMap 的元素总数超过阈值时，整个 ConcurrentHashMap 进行扩容
基于CAS进行扩容：ConcurrentHashMap 扩容跟 HashMap 基本一致，但是加上了 CAS 操作确保了线程安全。在扩容时，多个线程可以同时帮助扩容
渐进式扩容：在 JDK 1.8 中引入了渐进式扩容，扩容时并不是一次将所有数据重新分配，而是多个线程共同参与，逐步迁移旧数据到新数组中，减低扩容开销。
扩容时先把 transferIndex  待迁移的旧数组下标范围标记 设为旧数组长度，线程通过 CAS “抢占” 一段下标范围（比如从 transferIndex 取 16 个下标）；
线程迁移自己抢占的下标范围内的元素，迁移完后再 CAS 抢占新的范围，直到所有下标迁移完成；
“分段抢占、并行迁移”，避免单线程一次性迁移所有数据的开销。
简单来说就算维护一个 transferIndex，线程循环 CAS 争夺下标，如果下标已经分配完了说明已经扩容完成



]]></content>
  </entry>
  <entry>
    <title>ArrayList 和 LinkedList 的区别</title>
    <url>/2025/05/21/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/ArrayList%20%E5%92%8C%20LinkedList%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[
ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。

对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。

新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。

LinkedList集合不支持 高效的随机随机访问（RandomAccess）

ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间


]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的HashMap的原理</title>
    <url>/2025/12/03/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/Java%E4%B8%AD%E7%9A%84HashMap%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[说白了 HashMap 底层就是一个数组，然后组合了链表和红黑树
怎么寻址当你存一个 Key-Value 的时候会计算出 key 的 hashcode，然后用哈希计算公式keyhashcode % (table.length - 1) 算出需要存放的位置
处理哈希冲突按照上面说的寻址我们会发现，有概率两个元素用公式算出来的结果是一样的，这就是我们常说的哈希冲突，HashMap 里也设定好了解决方法：

链表：Java 7 及以前是把他们放在一起，用链表装着
在 java 7 及以前链表使用的是头插法，即每次出现哈希冲突时，新的节点会插入到链表的头节点，老节点以此往后，在多线程环境下，头插法可能导致链表形成环，特别是在并发扩容时 rehashing 。当多个线程同时执行 put() 操作时，如果线程 A 正在进行头插，线程 B 也在同一时刻操作链表，可能导致链表结构出现环路，从而引发死循环，最终导致程序卡死或无限循环。
但在 java 8 的时候改为尾插法，即新的节点插入到链表的尾部，保持链表的流畅度


红黑树：
Java 8 后做了优化，如果同一个下标的元素太多了（超过八个），则将链表转换成红黑树
红黑树是一个自动平衡二叉树，能够将最坏情况下的查找复杂度从O(n) 变成 O(logn)
如果数中的数量低于6，红黑树将会转换回链表，以减少不必要的开销



扩容机制HashMap 默认长度是16，HashMap 有扩容因子（默认是0.75），意思是当元素超过 长度 * 0.75  时将会自动扩容。
默认长度是 16，扩容因子是 0.75，这个组合是性能和空间之间找到的平衡。如果扩容因子过高，虽然空间利用更高了，但是更容易出现哈希冲突，影响效率；如果扩容因子过低，哈希冲突出现概率减少，但是空间利用率低。
扩容就算将容量翻倍，然后把位置重新计算一遍，放进新的数组。
HashCode() 和 equals() 的重要性HashMap 的 key 必须实现 HashCode() 和 equals() 方法。

hashcode() 用于计算哈希值，以决定键的存储位置
而 equals() 用于比较两个键是否相同。

在 put 操作的时候需要用到这两个方法来计算存放的位置，误用 HashCode() 和 equals() 可能导致存放错误
注意：这个操作挺耗费性能的，所以我们尽量在初始化的时候就给个大概容量，少扩容
&#x3D;&#x3D;HashMap是非线程安全的&#x3D;&#x3D;
]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka如何避免重复消费问题</title>
    <url>/2025/05/20/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/Kafka%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[首先，kafka的块上会储存offset标记，kafka消费者通过offset标记来维护已经消费的数据，消费者每消费完一批数据时会更新offset值，来避免重复消费问题。
默认情况，消费完以后会自动提交offset值避免重复消费，Kafka消费端自动提交的逻辑中默认了5秒的间隔，所以在consumer的消费过程中，如果5秒内被强行kill了或者宕机导致offset没有提交，会导致重复消费问题。
在Kafka里有一种叫Partition Balance机制，就是把多个消费区都负载均衡给consumer消费者，如果消费者在默认的五分钟内没有处理完里面的消费，就会触发ReBalance机制导致offset提交失败，在重启ReBalance后，消费端还是会从之前没有提交offset的位置开始去消费，从而导致重复消费问题，如何去解决也有很多方法：

提高消费端的处理性能，避免触发Balance，例如：
比如采用异步的方法来处理消息，缩短单个信息消费的时长
调整消费处理的超时时间
减少一次性从区中获取数据的条数


针对信息生产md5然后保存在MySQL或者redis里，在处理消息前先去MySQL或者redis里判断是否消费过

]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事物的原理是什么</title>
    <url>/2025/05/10/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/MySQL%E4%BA%8B%E7%89%A9%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[MySQL满足ACID的特性，所以MySQL事物的原理就是innodb是如何去实现ACID的特性。
首先A就是原子性，就是要保证DML数据库操作语言要么都成功，要么都失败，都成功好理解，如果都失败就意味着要把原本执行的操作都回滚，所以innodb里面设计了一个undo log表，在事物执行的过程中把执行数据的快照保存在undo log表里，例如执行一个insert语句，在undo log表里就存储一个delete语句，一旦出现错误就直接读取undo log执行反向操作就行了。
其次就是C一致性，表示数据的约束没有得到破坏，这个更多是依靠业务层的保障，数据库里面也提供了像主键约束，唯一约束，字段长度约束等。
I是隔离性，多个并行事物对同一个数据进行操作如何去避免多个事物的干扰导致数据混乱。innodb里面实现了SQL92的标注，提供了四个隔离级别的实现，分别是未提交读、已提交读、可重复读以及串行化。innodb默认实现的是可重复读，并且使用了MVCC解决了脏读和不可重复读的问题，然后使用了行锁或者表锁的方式来解决幻读的问题。
D是持久性，也就是说事物提交后的数据一定是永久化保留，不能因为数据库宕机或者其他原因导致数据变更的失效。理论上说事物提交后直接放在磁盘保存就好了，但是因为随机磁盘IO的效率确实很低，所以innodb设计了Buffer pool缓冲区来进行优化，数据更新的时候先更新缓冲区，然后在合适的时间持久化到磁盘里。但是在这个过程中可能会因为数据库宕机导致数据丢失，因此innodb引入了redo log文件，这个文件存储了数据库变更后的值，我们通过事物进行数据更改的时候，除了修改内存缓冲区里的数据以外，还会被本次修改的值追加到redo log里面，当事物提交的时候直接把redo log里面的日志刷新到磁盘里面进行持久化，一旦数据库宕机在MySQL重启以后可以直接用redo log里面保存的重写日志读取再执行一遍。
因此认为，MySQL事物的原理就是innodb如何实现ACID的特性，用到了MVCC、行锁、表锁、缓冲区、redo log和undo log来实现。
]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动流程</title>
    <url>/2025/05/11/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[首先需要一个加了 @SpringBootApplication 注解的启动类，这个注解本质上就是由 @EnableAutoConfiguration 、@SpringBootConfiguration 和 @ComponentScanner 连起来构成。

@EnableAutoConfiguration 的作用是在启动时自动加载一个类，这个类会将所有符合条件的 @Configuration 配置都进行加载，如果启动类中不需要添加配置内容，也不需要扫描路径，可以将 @SpringBootApplication 换成 @EnableAutoConfiguration

@SpringBootConfiguration 等同于 @Configuration，就是将这个类标记为配置类，会被加载到容器中

@ComponentScanner 就是自动扫描并加载所有符合条件的 Bean


注解完成后，运行的起点就是 SpringApplication.run(类名.class, args)，在 run 开始执行后会经历四个阶段：服务构建、环境准备、容器创建和填充容器
]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringApplication.run 执行后的四个阶段</title>
    <url>/2025/05/12/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/SpringApplication.run%20%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[四阶段分别为：服务构建、环境准备、容器创建和填充容器
服务构建

首先把传入的资源加载器、主方法类记录到内存中，然后逐一判断对应的服务类是否存在来确定web服务的类型
默认是基于servlet的web服务，如tomcat，还有响应式非阻塞服务reactive，如spring-webflux，还有什么都不是的none


确定完选择哪个web服务后就是加载初始化类了，会去读取META-INF&#x2F;spring.factories文件中的注册初始化、上下文初始化和监听器这三个配置
最后是通过运行栈stackTrace判断main方法所在类

环境准备

先new一个启动上下文 bootstrapContext，然后调用启动注册初始化器中的初始化方法 initialize，但由于没有没默认的初始化器，所以也没初始化什么（这个可以靠手动添加）
将 java.awt.headless 设置为 true，表示缺少显示器、键盘等输出设备也能正常启动
然后启动运行监听器，同时发布启动事件，获取并加载springboot工程配置文件中监听器，就可以做到通过监听事件在启动的流程中加入自定义逻辑
接下来就是组装启动参数，例如根据不同的web服务构造不同的环境（默认是servlet）、坏境变量、jvm系统属性等，把这些信息加载到一个内存集合中，后续调用就无需重新加载了

容器创建

根据服务类型创建容器（默认servlet）注解配置的servlet-web服务容器
存放和生产bean实例的Bean工厂
用来解析 @Component、@ComponentScan 等注解的配置类后处理器
用来解析 @AutoWired、@Value等注解的自动注解bean处理器


对容器中的部分属性进行初始化

填充容器

生产自身提供或者自定义的所有Bean对象，放入容器创建步骤中创建好的容器中，这个过程也叫做自动装配
构造启动web服务器
回调自定义实现的 Runner 接口，来处理执行后定制化的需求

]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Prompt、Agent、MCP是什么</title>
    <url>/2025/07/28/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/Prompt%E3%80%81Agent%E3%80%81MCP%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[PromptUserPrompt23年 OpenAI 刚发布 ChatGPT 的时候，AI看起来还是一个聊天框，我们通过聊天框发送的消息，然后AI模型生成一个回复，我们发的信息就叫用户提示词（UserPrompt）。
SystemPrompt但是现实生活中，问每个人同一句话都可能得到不同的回复。比如我说：我饿了；爷爷奶奶可能会说：要不要煮点东西给你吃；朋友会说：别饿；女朋友会说：滚一边去，我也饿。但是AI没有这样的人设，所以只能给出一个通用的回复：饿了就吃饭。
于是我们就希望给AI也加上一个人设，最直接的方法就是把人设信息和用户要说的话打包成一条 UserPrompt 发过去，比如你说：你是我朋友，我饿了；然后AI就会回答：别饿。
但问题是，你扮演我的朋友这句话不是我们真正想说的内容，每次都要提及显得麻烦，于是我们将人设信息单独拎了出来，放在另一个Prompt里面，这就是系统提示词（SystemPrompt），像角色、性格、背景知识、语气等等这些不是直接由用户说出来的内容都可以放在 SystemPrompt 里。
每次用户发送 UserPrompt 的时候，系统会自动把 SystemPrompt 也一起发给AI模型，这样整个对话就显得更加自然了。
Agent上面说了这么多，说到底，AI还是一个聊天机器人，你问一个问题，他也只能给你一个回复，告诉你怎么做，实际动手的还是自己，如何让AI来帮我们完成，第一个做出尝试的是 AutoGPT。
如果想要 AutoGPT 帮我们管理电脑中的文件，那我们得先写好一些文件的管理函数，比如说暂定 List_files 用来列出目录，Read_files 用来读取文件。然后把这些函数以及它们功能描述、使用方法注册到 AutoGPT 里，AutoGPT 会根据这些信息生成一个 SystemPrompt，告诉AI模型用户给了哪些工具，分别都是干什么的，以及AI如果想要使用它们该返回什么样的格式，最后把 SystemPrompt 连通用户的请求，如果AI足够的聪明，就会按照要求的格式返回一个调用某个函数的消息，AutoGPT 解析后就可以调用对应的函数，然后 AutoGPT 把调用的结果返回给AI，AI再决定下一步该做什么，直到任务完成为止。
我们把 AutoGPT 这种负责在*模型、工具和最终用户直接传话的程序叫做 AI Agent，这些提供给AI调用的函数或者服务就叫 Agent Tool*。
但是这种架构任然有点小问题，这套架构能够运行的前提是AI足够的聪明，虽然我们在 SystemPrompt 里面写清楚了AI该用什么格式返回，但还是可能因为AI返回格式不对的内容，为了处理这种情况，很多AI Agent会在发现返回结果格式不对时自动进行重试，但这种反复的重试不仅大大减少效率，并且加大浪费。
Function Calling后来各大厂商推出一个叫做 Function Calling 的新功能，这个新功能的核心思想就是统一格式、规范描述。
比如我们上面通过 SystemPrompt告诉AI有哪些工具以及返回的格式，但是这些描述是用自然语言编写的，只要AI看得懂就行，Function Calling 则对这些描述进行标准化，比如每个 Tool 都用一个 JSON 对象来定义工具名，工具名写在name字段、功能说明写在desc字段、所需参数写在params里面等等，然后这些 JSON 对象从 SystemPrompt 里面被剥离出来，单独放在一个字段里面，最后 Function Calling 也规定了使用工具时应该返回的格式，所以 SystemPrompt 里面的格式定义也可以删掉了。
这样所有的工具描述放在同一个地方，所有的工具描述也依照相同的格式，如果AI依旧生成了错误的回复，因为回复的格式是固定的，所有AI服务端自己就能检测到，并且进行重试，这样不仅降低了用户端的开发难度，还节省了用户端重试带来的Token开销。
但 Function Calling也有相对应的问题，就是没有统一的标准，每家企业的API定义都不一样，还有很多大模型都不支持 Function Calling。
MCPAI Agent 跟 Agent Tools进行通信，最简单的是写在同一个程序里，直接函数调用，但是有些 Tools 非常通用，比如浏览网页，可能多个 Agent 都需要，但每个 Agent 都拷贝一份相同代码太麻烦了，于是大家把 Tool 变成服务统一托管，让所有的 Agent 都来调用，这就是 MCP。
MCP 是一个通信协议，专门用来规范 Agent 和 Tool 服务之间是如何交换的，运行 Tool 的服务叫做 MCP Server，调用的 Agent 叫做 MCP Client，MCP规定了MCP Server如何和 MCP Client 通信，以及 MCP Server 要提供哪些接口，比如用来查询 MCP Server 中有哪些 Tool，以及功能、描述需要的参数、格式等接口，除了普通的 Tool 这种函数调用形式，MCP Server 也可以直接提供数据，提供类似文件读写的服务叫做 Resource，或者为 Agent 提供提示词的模板叫做 Prompt 。
MCP Server 既可以和 Agent 在同一台机器上，通过标准输入输出进行通信，也可以部署在网络上，通过HTTP进行通信，MCP只负责帮 Agent 管理工具、资源和提示词
]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>redis主从复制的理解</title>
    <url>/2025/05/22/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[主从复制本质上就是从一台服务器master上的数据拷贝到另一台服务器slave上，数据的复制是单向的，只能由主节点到从节点，redis里提供了全量复制和增量复制两种方法：

全量复制：一般用于slave新构建的时候，slave会向master发送全量复制请求，然后master会拷贝当前数据快照给slave，slave丢弃旧的数据来加载新的数据，但需要注意redis并没有采用强一致性，所以会出现数据同步延迟导致数据不一致问题

增量复制：当master节点收到数据改动，master会把变更的数据同步给所有的slave节点，主要原理是master和slave会共同维护一个偏移量offset，用来表示master向slave传递的字节数量，每一次进行增量数据的传递，offset都会对应增加数量


主从连接后master 接收命令，判断runid是否匹配，判定offset是否在复制缓冲区中，runid和offset有一个不满足，执行全量复制
心跳机制：进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线

master会去ping slave，默认每十秒一次，来获取slave最后一次连接时间间隔，一般在0或1为正常
slave会用REPLCONF ACK &#123;offset&#125;，每一秒一次，汇报slave自己的复制偏移量，获取最新的数据变更指令以及判断master是否在线

]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是SpringMVC</title>
    <url>/2025/05/19/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/</url>
    <content><![CDATA[SpringMVC 是属于Spring Framework生态里面的一个模块，是在servlet的基础上构建并且使用了MVC模式涉及的web框架，目的是为了去简化传统的servlet+JSP模式下的web开发方式。其次Spring MVC的架构设计是对Javaweb里面的mvc框架模式做了一些增强和扩展，主要体现在几个方面 ：

把传统MVC框架里面的Controller控制器做了拆分，分为了前端控制器DispatcherServlet和后端控制器Controller
把model模型拆分成业务层service和数据访问层Repository
在视图层，可以支持不同的视图，比如Freemark、velocity、JSP等

所以，SpringMVC就是为了MVC模式设计的，因此在开发MVC应用时会更加方便灵活
SpringMVC整体工作流程：

浏览器请求首先经过核心控制器DispatherServlet，把请求分发到对应的Controller里面
然后等Controller调用业务逻辑进行处理完后返回Model And View
DispatcherServlet去寻找一个或多个ViewResolver视图解析器，找到Model And View指定的视图并且把数据展示到客户端

]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是消息队列（Kafka）</title>
    <url>/2025/05/26/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Kafka%EF%BC%89/</url>
    <content><![CDATA[模拟场景假如现在我需要维护两个服务A和B，B服务每秒能处理100个消息，但A服务每秒能发两百个消息
结果我们也能想到，B服务非常容器就爆炸了，聪明的我一定能想到，我在B里面加一个队列来存放A发来的消息，用offset偏移量来记录消息的位置，B服务看能力来处理消息，不断更新offset值
但这又产生了一个新问题，来不及处理的消息放在内存里，如果在服务B里面的消息没有处理完的情况下B服务关机或者重启了，里面的消息就全部丢失了，但聪明的我肯定还会想到，那我们把队列拉出来单独开一个进程不就行了嘛
这就是消息队列的来源，像A服务一样发数据到队列里就是生产者，B服务这样处理数据的就是消费者
优化
高性能  简单来说就是软件不行加硬件，消费者太慢了就加消费者，生产者慢就加生产者，但这听着感觉还是不对，如果多个生产者和消费者同时争抢同一个消息队列，抢不到就等怎么办
  解决方法：  对消息进行分类，每一类是一个topic，按照topic数量，生产者将消息分发给不同的消息队列里面，一个消费者需要订阅不同的队列来获取消息，但这样还是会出现一个topic里消息还是很多，我们还可以把单个topic拆成多个partition分区，每个消费者负责一个partition分区

高扩展
  随着partition变多，如果partition都在同一台机器上可能会导致单机CPU内存负载过高，影响系统整体效率
  解决方法：  将partition分散部署到多台机器上，每一台机器就是一个broker，我们可以通过增加broker来缓解机器CPU负载过高带来的性能问题

高可用
  如果其中一个broker挂了，那里面所有partition的消息也会跟着消失
  解决方法：  给partition多加几个副本，统称为replicas，将他们分为leader和follower，leader负责应对生产者和消费者的读写请求，follower负责同步leader的消息，将leader和follower分散到不同的broker里，这样就算leader所在的broker挂了也不会影响到follower所在的broker，并且还能重新选举一个leader partition顶上

持久化和过期策略
  假设全部broker都挂了，那所以的partition的消息不都丢失了吗
  解决方法：  所以我们不能光将数据放在内存里，还需要持久化到磁盘上，但问题又来了，磁盘是有限的，一直往里面写数据迟早得炸，所以还需要给数据加上保留策略retention policy，比如磁盘数据超过一定大小或者数据放置超过一定时间就会被清理掉

消费者组consumer group
  按现在的消费方式，每次新增的消费者只能跟着最新的offset接着消费，如何让新增的消费者从指定的offset开始消费呢
  解决方法：  引入消费者组概念，不同消费者组维护自己的消费进度，互不打扰

ZooKeeper
  就目前来看，组件太多了，而且每个组件都有自己的数据和状态，因此需要有一个组件去统一维护这些组件的状态，于是引入了ZooKeeper组件
  ZooKeeper会定期和broker通信，获取整个Kafka集群的状态，以此判断某些broker是不是挂了，某些消费者消费到哪了


应用场景
流量削峰填谷
异构同步（不同类型、不同厂商的数据库系统之间进行数据同步）
日志处理与分析
系统监控与报警等

]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是循环依赖</title>
    <url>/2025/05/27/articles/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[什么是循环依赖现在我们有两个类 ClassA 与 ClassB，但他们互相引用，直接或间接依赖对方，例如例如A类里有B的对象，B类中又有A的对象
public class ClassA &#123;
    private ClassB classB;
    // 构造方法、getter 和 setter 等
&#125;

public class ClassB &#123;
    private ClassA classA;
    // 构造方法、getter 和 setter 等
&#125;```

这种依赖不仅限于出现在类上，也可能会出现在包上或者模块上

- **出现在包层面的危害：
    - 增加了代码的耦合度，降低了代码的可维护性和可读性
    - 在编译时可能会出现编译顺序的问题，难以确定先编译哪个包。
    - 在后续的开发和维护过程中，增加了维护的难度和风险。

- **出现在模块层面的危害：
    - 会导致模块之间的边界变得模糊，无法清晰地划分模块的职责。在构建和部署项目时，可能会出现循环加载的问题，影响项目的启动效率和运行性能。

## Spring中的循环依赖

当两个或多个 Bean 之间存在构造器注入的循环依赖时，Spring 无法解决这种依赖关系。例如，`BeanA` 的构造器需要 `BeanB`，而 `BeanB` 的构造器又需要 `BeanA`。Spring 容器在创建这些 Bean 的过程中会陷入死循环，无法确定先创建哪个 Bean，从而抛出 `BeanCurrentlyInCreationException` 或 `BeanCurrentlyInCreationException` 等异常。

解决方法：
- Spring 通过单例 Bean 的提前暴露机制来解决基于 Setter 注入的循环依赖问题
- **创建 BeanA 的壳对象并存入三级缓存** ：当创建 `BeanA` 时，Spring 会先创建一个 `BeanA` 的壳对象（即一个未完全初始化的实例，只是构造函数执行完成，属性还没有填充），并将其存入三级缓存（`SingletonObjects`、`earlySingletonObjects` 和 `singletonFactories` 组成的缓存体系）中的 `singletonFactories`。
    
- **创建 BeanB 并注入依赖** ：接着创建 `BeanB`，在创建 `BeanB` 的过程中，发现 `BeanB` 依赖 `BeanA`，此时 Spring 会尝试从缓存中获取 `BeanA`。虽然 `BeanA` 还没有完全初始化（只是壳对象在 `singletonFactories` 中），但 Spring 会将其从 `singletonFactories` 中取出，放入 `earlySingletonObjects` 中，并将其作为依赖注入到 `BeanB` 中。
    
- **完成 BeanA 的初始化并注入到 BeanB** ：`BeanA` 的壳对象被注入到 `BeanB` 后，Spring 会继续完成 `BeanA` 的初始化（填充属性等操作）。当 `BeanA` 初始化完成后，会将它放入 `SingletonObjects` 中。在后续的操作中，如果 `BeanB` 还需要访问 `BeanA`，可以直接从 `SingletonObjects` 中获取已经完全初始化的 `BeanA`。

## 三级缓存

### 一级缓存（`singletonObjects`）

一级缓存也被称为单例池，存储的是已经完全初始化好的单例 Bean 实例。当需要获取一个单例 Bean 时，Spring 会优先从这个缓存中查找，其数据结构为 `Map&lt;String, Object&gt;`，键是 Bean 的名称，值是对应的 Bean 实例。

### 二级缓存（`singletonFactories`）

当 Bean 实例化完成，但还未完成属性注入和初始化时，会将一个创建该 Bean 代理对象的工厂存入二级缓存。其数据结构为 `Map&lt;String, ObjectFactory&lt;?&gt;&gt;`，键为 Bean 的名称，值是用于创建 Bean 的工厂对象。如果从一级缓存中未找到所需的 Bean，Spring 会尝试从二级缓存中获取对应的工厂对象，并通过该工厂创建 Bean 的早期暴露实例。

### 三级缓存（`earlySingletonObjects`）

三级缓存存储的是提前暴露的单例 Bean 实例，这些 Bean 虽然还未完成全部的初始化流程，但已经可以被引用。通过这个缓存，其他 Bean 在依赖该 Bean 时可以获取到一个早期的实例。其数据结构为 `Map&lt;String, Object&gt;`，键是 Bean 的名称，值是早期暴露的 Bean 实例。如果从二级缓存中获取到工厂对象后，会使用该工厂生成一个早期的 Bean 实例，并将其存入三级缓存中，以便其他 Bean 可以引用。

















]]></content>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>[object Object]</title>
    <url>/2024/12/20/articles/%E6%A8%A1%E6%9D%BF/123/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2025/02/10/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[消息队列（听不懂，不是人听的，内容的很奇怪，像初见，又像告别，又像是重逢，能看懂并且记下来都是神人了）
消息队列（MQ），指保存消息的一个容器，本质是个队列。要想称之为消息队列，这个队列要支持 高吞吐、高并发 并且 高可用。
KafkaKafka 的使用
首先需要创建一个 Kafka 集群；
在这个集群中创建一个 Topic，并且设置好分片数量；
编写生产者逻辑，引入对应语言的 SDK，配置好集群和 Topic 等参数，初始化一个生产者，调用 Send 方法发送消息；
编写消费者逻辑，引入对应语言的 SDK，配置好集群和 Topic 等参数，初始化一个消费者，调用 Poll 方法接收消息。

Kafka的原理

Topic : 逻辑队列，不同Topic 可以建立不同的 Topic
Cluster : 物理集群，每个集群中可以建立多个不同的 Topic
Producer : 生产者，负责将业务消息发送到Topic 中
Consumer : 消费者，负责消费 Topic 中的消息
ConsumerGroup : 消费者组，不同组Consumer 消费进度互不干涉

这其中还涉及到 Topic 内的 offset(相对位置)，Replica（副本），以及副本分布相关概念：

Offset : 消息在 partition 内的相对位置信息，可以理解为唯一D，在 partition 内部严格递增
Replica : 每个分片有多个 Replica，Leader Replica 将会从 ISR(In-Sync Replicas) 中选出，一般分为 Leader 和 Follower，Leader 是主片， Follwer 会异步去同步 Leader，以防 Leader 挂了可以立马补上

Kafka 运行流程（这里我也没看懂QAQ）
一条消息进入 kafka 处理的流程为： Producer -&gt; Broker -&gt; Consumer，在这三个部分可以分别采取一些方案帮助 Kafka 提高吞吐或者稳定性。

Producer 端逻辑
批量发送
为了应对大消息量的场景，采取批量发送机制，通过一次性发送多个消息从而减少 I&#x2F;O 次数，加强发送能力


消息压缩
在消息容量太大，带宽较小，导致发送速度慢的场景下，kafka 提供了消息压缩，通过对消息进行压缩处理减小消息的大小




Broker 端逻辑
写入
在存储过程中，kafka 会通过副本生成日志，将日志写入磁盘，而这些日志显然是有时效的，因此根据存入的有效时间存入不同的日志段 LogSegment，此外根据磁盘的结构，采用顺序写的方式进行写入，可以提高写入效率


读取
Consumer 通过发送 FetchRequest 请求消息数据，Broker 通过索引取出消息，按照时间窗口和信息大小发送给 Consumer


Broker 有两种文件索引方式
偏移量索引：通过二分法寻找小于目标 offset 的最大文件
时间戳索引：通过二分法找到小于目标时间戳最大的索引位置


数据拷贝
kafka 拷贝数据的流程不经过用户态空间，而是在读取磁盘后直接将 Read Buffer 中的数据传输到 NIC Buffer，通过 NIC Buffer 直接交付给消费者进程




Consumer 端逻辑
分配的问题，也就是对于每一个 partition 来讲，该由哪一个 consumer 来消费
手动分配（low level）：在启动的时候分配任务，哪个 Consumer 负责拉取哪几个 partition，但是万一其中一个 Consumer 宕机，就会导致无法拉取到完全的 partition
自动分配（high level）：对于每一个消费者组，都会选择一个 Broker 作为一个协调者 Coordinator，这个协调者负责分配各个消费者获取 partition 的任务，这使得可以动态调整各个 Consumer 的任务





Kafka缺点
运维成本高；
负载不均衡，解决方案复杂；
没有自己的缓存，需要依赖外部Cache;
若 Controller 和 Coordinator 与 Broker 在同一个进程中，大量 I&#x2F;O 会导致性能下降。

BMQBMQ （Bytedance Message Queue） 是字节跳动出品的消息队列产品，解决了 Kafka 在实际应用中的诸多问题。
BMQ 架构模型兼容 Kafka 协议，存算分离，云原生消息队列

新增 Proxy 层作为代理；
Coordinator 和 Controller 可以独立部署；
底层新增 HDFS 用于存算分离。

Proxy 负责接收所有用户的请求，对于生产请求，Proxy 会将其转发给对应的 Broker；对于消费者相关的请求，例如 commit offset，join group 等，Proxy 会将其转发给对应的 Coordinator；对于读请求 Proxy 会直接处理，并将结果返回给客户端。
BMQ 的 Broker 与 Kafka 的 Broker 略有不同，它主要负责写入请求的处理，其余请求交给了 Proxy 和 Coordinator 处理。
Coordinator 与 Kafka 版本最大的差别在于我们将其从 Broker 中独立，作为单独的进程提供服务。这样的好处是读写流量与消费者协调的资源可以完全隔离，不会互相影响。另外 Coordinator 可以独立扩缩容，以应对不同集群的情况。
Controller 承担组件心跳管理、负载均衡、故障检测及控制命令接入的工作。因为 BMQ 将数据放在分布式存储系统上，因此无需管理数据副本，相较于 Kafka 省去了 ISR 相关的管理。Controller 可以更加专注地关注集群整体流量均衡及故障检测。

BMQ的优点
Kafka痛点：传统Kafka采用分区（Partition）与Broker强绑定的架构，扩容需数据重平衡，导致运维复杂、资源浪费。

BMQ解决方案：

Proxy层解耦：引入无状态Proxy节点处理客户端请求，与存储层分离，实现动态扩缩容无需数据迁移。

分布式存储层：数据持久化采用自研分布式存储系统（如HDFS或对象存储），支持弹性扩展，降低存储成本。

自动负载均衡：Topic分区动态调度至不同存储节点，规避Kafka的”热点分区”问题。



BMQ关键技术：

零拷贝优化：绕过操作系统内核，直接操作存储设备（如SPDK），减少数据拷贝次数。

异步流水线：写路径采用异步化设计，合并小IO为顺序写入，提升吞吐量。

分层存储：热数据存内存&#x2F;SSD，冷数据转至廉价HDD或对象存储，平衡成本与性能。




BMQ的读写流程
创建Producer和Consumer：在使用BMQ之前，需要创建Producer和Consumer并连接到消息队列服务器。

创建队列：BMQ支持多个队列，可以为不同的消息类型创建不同的队列。

发送消息：生产者将消息发送到指定的队列中，消息会被存储到消息队列中，等待消费者来获取。

获取消息：消费者从队列中获取消息，并进行处理。

确认消息：消费者在处理完消息后，需要向BMQ服务器发送确认消息，告诉服务器已经消费完成。


RocketMQ（没看懂，但是好像很重要，留住，以后再学）
RocketMQ 以低延时出名，适合用在电商或者一些实时的业务上
官方文档：rocketmq.apache.org&#x2F;docs&#x2F;
基本概念
基本架构
]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>后端框架的剖析</title>
    <url>/2025/02/14/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[架构架构，又称软件架构

是有关软件整体结构与组件的抽象描述
用于指导软件系统各个方面的设计

单机架构软件系统需要具备对外提供服务，单机，就是把所有功能都实现在一个进程里，并部署在一台机器上
优点:

简单

问题


C10K问题（Concurrent 10,000 Connection）：服务器如何支持10K个并发连接，进行高性能网络编程。解决方式：采用IO复用模型epoll方法，在调用返回时，只给应用提供发生了状态变化的文件句柄，不需要轮询fd（文件描述符）


运维需要停服

单体、垂直应用|垂直切分单体架构：分布式部署垂直应用架构：按应用垂直切分的单体优点：

水平扩容
运维不需要停服问题：
职责太多，开发效率不高
爆炸半径大


SOA、微服务|水平切分S0A(Service-0riented Architecture)

将应用的不同功能单元抽象为服务
定义服务之间的通信标准

微服务架构： S0A 的去中心化演进方向
云计算云计算：是指通过软件自动化管理，提供计算资源的服务网络，是现代互联网大规模熟悉分析和存储的基石。
基础：

虚拟化技术 
整租 vs 合租（“整租”可以对应“独占虚拟机”，“合租”可以对应“共享虚拟机”）


编排方案 
业主 vs 租赁平台（“业主”可以类比为“私有云或本地数据中心”，“租赁平台”可以类比为“公有云服务提供商”）



架构：

laaS（Infrastructure as a Service）（基础设施即服务）
定义：基础设施即服务是一种云计算服务模型，它提供虚拟化的计算资源。用户可以通过Internet租用这些资源，如服务器、存储和网络硬件。
控制程度：IaaS提供了最高的控制程度，用户可以完全控制操作系统安装、应用程序部署和网络配置。


PaaS（Platform as a Service）（平台即服务）
定义：平台即服务是一种云计算服务模型，它提供了一个平台，允许用户开发、运行和管理应用程序，而无需构建和维护底层硬件和软件基础设施。
控制程度：PaaS提供了一个中间层的控制，用户可以控制应用程序和某些应用程序托管功能，但对底层基础设施的控制有限。


SaaS（Software as a Service）（软件即服务）
定义：软件即服务是一种云计算服务模型，它通过Internet提供应用程序，用户通常通过订阅模式访问这些应用程序。
控制程度：SaaS提供了最低的控制程度，用户只能使用应用程序的功能，而不能控制应用程序或其运行环境。


FaaS（Function as a Service）（方法即服务）
定义：函数即服务，也称为无服务器计算，是一种云计算服务模型，它允许用户运行代码而无需管理底层的运行环境或基础设施。
控制程度：FaaS提供了一种事件驱动的计算模型，用户只需上传代码，服务提供商会处理其余的工作，包括自动扩展、负载均衡和状态管理。



云原生云原生技术为组织(公司)在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。

弹性计算资源类型
服务资源调度
微服务：微服务架构将复杂的应用程序拆分为一组小型、独立的服务，每个服务专注于完成一个特定的业务功能。它们通常具有快速开发、部署和扩展的能力
大服务：大服务通常指那些功能复杂、使用量高且对性能要求较高的服务。它们可能需要长期运行并处理大量数据。


计算资源调度
在线

特点：在线计算通常需要实时或近实时响应用户请求，对性能和延迟要求较高。


应用场景：例如，电商网站的热销榜单展示。这类应用需要快速响应用户的查询请求，实时更新数据，并根据流量动态调整资源。


离线
特点：离线计算通常用于处理非实时的数据分析或批处理任务，对延迟要求不高，但对数据处理的完整性和准确性要求较高。
应用场景：例如，热销榜单的更新。这类任务可以在后台运行，定期处理大量数据，生成分析结果，然后更新到在线系统中。




消息队列
在线消息队列：
特点：在线消息队列主要用于实时或近实时的消息传递，能够实现系统的解耦和削峰填谷。
应用场景：
削峰：在高并发场景下，消息队列可以缓冲用户请求，避免系统过载。
解耦：将不同的系统或服务通过消息队列连接，降低系统间的耦合度，提高系统的可扩展性和可靠性。




离线消息队列：  - 特点：离线消息队列主要用于处理非实时的数据处理任务，通常用于大数据分析、日志处理等场景。  - 应用场景：例如，收集用户行为日志并进行离线分析，生成用户画像或推荐系统数据。这类任务可以在后台运行，不依赖实时响应。



DevOpsDev0ps 是云原生时代软件交付的利器贯穿整个软件开发周期，是一种将软件开发（Development）和 IT 运维（Operations）相结合的文化、理念和实践方法。它旨在打破开发和运维之间的传统壁垒，通过自动化、协作和沟通，实现软件的快速交付和高质量。DevOps 强调团队赋能、跨团队沟通和协作，以及技术自动化。
结合自动化流程，提高软件开发、交付效率
软件大概的生命周期如下：

离在线资源并池
核心收益：

降低物理资源成本：通过资源复用，减少闲置资源，提高整体资源利用率。

提供更多的弹性资源，增加收入：在离线业务的低峰期释放资源给在线业务使用，反之亦然，从而实现资源的灵活调配。



在线业务的特点：

IO密集型为主：在线业务通常对延迟敏感，需要快速响应用户请求。

潮汐性、实时性：在线业务通常呈现明显的潮汐效应，例如白天流量高，夜间流量低。



离线业务的特点：

计算密集型占多数：离线业务通常需要大量的计算资源，例如数据分析、模型训练等。

非实时性：离线业务对实时性要求较低，可以在资源允许的情况下排队执行。




]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2025/01/15/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Git/Git/</url>
    <content><![CDATA[项目初始化在study文件下创建一个git，名字叫blog
mkdir studycd studygit init blog

其他参数
--initial-branch  初始化的分支--bare  创建一个裸仓库(纯 Git 目录，没有工作目录)--template  可以通过模板来创建预先构建好的自定义 git 目录

Git Config不同级别的 Git 配置

**–global   
**–system
**–local

每个级别的配置可能会重复，但是低级别的配置会覆盖高级别的配置
system &gt; global &gt; local
常见 Git 配置用户名配置git config --global user.name &quot;用户名&quot;git config --global user.email &quot;用户邮箱地址&quot;

Instead of 配置配置命令可以用于将 Git 命令中的 URL 映射到另一个 URL比如下面把 git@github.com 映射成 https://github.com/ ：
git config --global url.git@github.com:.insteadOf https://github.com/

Git 命令别名配置可以用来简化命令比如下面把 commit --amend --no-edit 改成 cin ：
git config --global alias.cin &quot;commit --amend --no-edit&quot;

Git Remote列出当前仓库中已配置的远程仓库，并显示它们的 URL
git remote -v

添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中git remote add &lt;remote_name&gt; &lt;remote_url&gt;例如：
git remote add origin_ssh git@github.com:git/git.gitgit remote add origin_http https://github.com/git/git.git

其他关于 Remote 命令可以通过 git remote -h 来查看
Git Add目执行 git status 查看 git 状态，可以看到一个新的管理的项目目前没有任何提交，然后我们在这个目录下创建一个 &#x3D;&#x3D;readme.md&#x3D;&#x3D; 文件，使用 touch readme.md ，然后再通过 git status 查看状态
在git中，文件的状态只有三种(已修改、已暂存、已提交)

已修改
在工作目录修改Git文件


已暂存
对已修改的文件执行Git暂存操作(git add)，将文件存入暂存区


已提交
将已暂存的文件执行Git提交操作(git commit)，将文件存入版本库



我们对文件的各种操作新建、编辑(写代码)都是在工作区完成的，但是工作区的文件还是不被Git所管理的，Git会告诉你 read.me 是未被追踪的文件，需要执行git add 文件名把 readme.md 提交到暂存区以便纳入到Git版本管理中来
我们来执行git add 操作，然后再查看状态,可以看到index.php已经被暂存，如果我们想把现在的暂存撤销，可以使用git rm --cached readme.md 命令来撤销，如果想提交到版本库，就再执行git commit操作就可以了
在暂存区的文件使用git commit readme.md -m&quot;备注&quot;提交到版本库中
如果修改了文件并且上传，想要返回上次上次的快照，可以通过查看git status可以看到文件状态被改变了。可以把工作区修改的文件git add提交到暂存区，也可以使用 git checkout —- readme.md 把工作区的修改撤销，这样，文件就会回退到上一次提交时的状态。
Objects 对象Git对象一共有三种：数据对象、树对象以及提交对象，这些对象都被保存在了.git&#x2F;objects目录下

Blob
存储文件的内容


Tree
存储文件的目录信息


Commit
存储提交信息，一个 Commit 可以对应唯一的版本的代码



通过 Commit 寻找到 Tree 信息，每个 Commit 都会存储对应的 Tree ID使用 tree .git 查看 objects 中的所有信息，找到ID，然后使用 git cat-file -p CommitID，就能看到Tree ID 和 作者
通过 Tree 存储信息可以获取到对应的目录树信息，也是用 git cat-file -p TreeID
从 Tree 中获取 Blob 的 ID， git cat-file -p BlobID 获取到对应的文件内容
Refs分支新建、切换分支切换分支：git checkout 分支名 新建分支：git checkout -b 分支名

Tag标签一般表示一个稳定的版本，指向一个 Commit 一般不会变更
git tag -a 版本号 -m &quot;备注&quot;


修改历史版本git commit --amend

Git Clone &amp; Pull &amp; Fetch
Clone
拉取完整的仓库到本地目录，可以指定分支，深度


Fetch
将远端某些分支最新代码拉取到本地，不会执行 merger 操作，会修改 refs&#x2F;remote 内的分支信息，如果需要和本地代码合并需要手动操作


Pull
拉取远端某些分支，并和本地代码进行合并，操作等同于 git fetch + git merger，也可以通过 git pull –rebase 完成 git fetch + git rebase 操作，可能存在冲突，需要手动解决冲突



关于 Fetch ，Fetch 会把代码拉取到本地的远端分支，但是并不会合并到当前分支，所以当前分支历史没有变化
Git Push将本地代码同步到远端的方式
一般使用 git push origin 分支名
冲突问题

如果本地的 commit 记录和远端的 commit 历史不一致，则会发生冲突，比如 git commit –amend or git rebase 都有可能导致这个问题
如果该分支就自己一个人使用，或者团队内确认可以修改历史则可以通过 git push origin 分支名 -f 来完成强制推送，一般不建议主干分支进行该操作，正常都应该解决冲突后再进行推送

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>网络接入</title>
    <url>/2025/02/12/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%85%A5/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[域名系统使用域名系统来代替 hosts 文件
关于域名空间:    - 域名空间被组织成树形结构    - 域名空间通过划分zone的方式进行分层授权管理    - 全球公共域名空间仅对应一棵树    - 根域名服务器:查询起点    - 域名组成格式:[a-zA-Z0-9-]，以点划分label

顶级域gTLD（general Top-level Domains）：gov政府.edu教育.com商业.mil军事.org非盈利组织
DNS服务器DNS查询过程
比如这里的网络客户端想要访问163.com域名，首先会访问本地的DNS服务器，看看有没有163.com域名的解析记录，第一次访问都不会有解析记录的，如果没有解析记录会依次向根、顶级域进行解析以及保存在本地，以便于下次查询
DNS记录类型
A&#x2F;AAAA:IP指向记录，用于指向IP，前为IPv4记录，后者为IPv6记录
CNAME:别名记录，配置值为别名或主名，客户端根据别名继续解析以提取IP地址
TXT:文本记录，购买证书时需要
MX:邮件交换记录，用于指向邮件交换服务器
NS:解析服务器记录，用于指定哪台服务器对于该域名解析
SOA 记录:起始授权机构记录，每个zon要权威服务器的记录,有且仅有唯一的一条SOA记录，SOA是描述zone属性以及主

接入HTTPS协议由于HTTP是明文传输，很容易被截取，因此有了HTTPS
对称加密和非对称加密加密是在传输过程中为无规则乱码，即使被第三方获取，在没有密钥的情况下也无法进行解密数据，从而保证了数据的安全性    - 对称加密由于双方密码一致，在发送时需要把密码发送给对方，这样在传输的过程中就有可能被截获    - 非对称加密加密和解密使用两种不同的密钥，公钥和私钥，如果使用公钥加密就需要用私钥解密，反之一致

证书链
Server 端发送是带签名的证书链

Client 收到会仍然需要验证

是否是可信机构颁布
域名是否与实际访问一致
检查数字签名是否一致
检查证书的有效期
检查证书的撤回状态



接入全站加速源站容量问题：增加后机器扩容;静态内容，使用静态加速缓存网络传输问题：动态加速DCDN全站加速 &#x3D; 静态加逗+动态加速
一般网址常见的问题有许多，例如：

源站容量低，可承载的并发请求数低，容易被打垮
丢包、劫持、mtu问题报文经过的网络设备越多，出问题的概率越大，自主选路网络链路长，时延高
卡顿响应慢
极大的流失了大部分的用户群体
NPS 留存率数据不乐观。

静态加速CDN（Content Delivery Network）内容分发网络，将网站内容发布到最接近用户的边缘节点，使网民可就近取得所需内容，有效解决互联网网络拥塞状况，提高网民访问的响应速度和成功率。静态CDN服务以图片、页面、js、css、大文件安装包等静态文件加速为主。主要原理是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度，如同提供了多个分布在各地的加速器，以达到快速、可冗余的为多个网站加速的目的。

解决由于地域、带宽、运营商接入等问题带来的跨网访问问题
结合DNS调度系统，将用户的请求分配至最适合他的节点，提升用户的访问速度
中心节点收敛回源，降低回源且提升命中率，减轻源站压力
隐藏源站，提供大带宽接入，降低源站被攻击的风险
提供存储方案，解决业务线文件存放问题

四层负载均衡基于IP+端口，利用某种算法将报文转发给某个后端服务器，实现负载均衡地落到后端服务器上。
三个主要功能:

解耦 vip 和 rs
NAT
防攻击:syn proxy


常见的算法
RR轮询:Round Robin，将所有的请求平均分配给每个真实服务器RS
加权RR轮询:给每个后端服务器一个权值比例，将请求按照比例分配
最小连接:把新的连接请求分配到当前连接数最小的服务器
五元组hash:根据sip、sport、proto、dip、dport对静态分配的服务器做散列取模  缺点:当后端某个服务器故障后，所有连接都重新计算，影响整个 hash 环
一致性hash:只影响故障服务器上的连接session，其余服务器上的连接不受影响

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发与迭代</title>
    <url>/2025/02/13/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E5%90%8E%E7%AB%AF%E7%9A%84%E5%BC%80%E5%8F%91%E4%BA%8E%E8%BF%AD%E4%BB%A3/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[了解开发流程
复杂项目没有流程会有什么问题

需求阶段:每个人都有自己的想法，团队决策需要有一个过程
开发阶段:多人&#x2F;多端协作开发，每个人有自己的安排，相互配合需要有一个流程
测试阶段:产物怎样交付，测试如何开展，BUG怎么修都需要流程
发布阶段:怎样确保发布过程平稳丝滑，版本和流量如何控制，需要有规范
运维阶段:线上问题如何应急响应，处理用户反馈和线上问题需要有流程

瀑布模型需求、开发、测试、发布、运维，一个阶段完全好了，再到下一个

传统的线性开发模型，按顺序依次进行需求分析、系统设计、编码、测试和部署。
每个阶段的结果作为下一个阶段的输入。
瀑布模型的突出缺点是不适宜用户需求的变化
需求一旦确认，较难进行修改。
适用于需求较为稳定、项目较小的情况。

敏捷开发更注重的是个体的互动、工作的软件、客户合作、响应变化

以小团队快速迭代
团队成员之间的合作更加紧密
以人为本，和用户沟通

更现代的流程模型

迭代、增量的开发方法，强调快速响应需求变化和持续交付价值。
开发过程中注重协作、沟通和自组织团队。
将开发任务分解为小块，每个迭代周期内交付可用的功能。
适用于需求不确定、变化频繁的项目。

字节团队的开发流程
开发流程详解需求阶段MVP (minimum viable product，最小化可行产品)思想

站在用户的角度思考收集用户反馈，快速迭代
把重要和紧急的事情先做，重要放在前面，紧急放在重要后面。
开发阶段云原生下的开发传统虚拟机

在物理主机中虚拟出多个虚拟机，每个虚拟机拥有自己的操作系统
运维人员负责维护和交付虚拟机
每个虚拟机中都要安装相应的依赖环境

容器化

容器是在操作系统中虚拟出来的
通过cgroup，namespace和Union Mount等技术实现了容器之间的相互隔离，同时容器只有很低的开销
应用和其依赖作为一个整体，打包成镜像交付

单体结构

多个模块共同组成一个服务，服务体量较大
模块之间直接调用，不需要RPC通信
服务整体扩缩容量
多人开发一个代码仓库，需要充分集成测试

微服务架构

各个功能在不同的服务中
不同模块需要进行RPC通信
不同模块可以独立扩缩容
每个服务的代码仓库仅由少部分人维护

代码规范、自测和文档代码规范

养成良好的注释习惯，超过三个月的代码，自己都会忘了当时在想什么
不要有魔法数字，魔法字符串
重复的逻辑抽象成公共的方法，不要copy代码
正确使用IDE的重构功能，防止修改错误

自测

单元测试
功能环境测试测试
数据构造

文档

大型改造需要有技术设计文档，方案评审
好的接口文档能更方便的和前端进行沟通

测试阶段
功能环境

需要一个能模拟线上的环境进行开发和测试
环境和环境之间能够隔离，不影响其他功能的开发和测试

集成环境

不同人开发的功能合并在一起测试，相互之间的影响可能产生缺陷
迭代发布的所有功能合并在一起测试，确保发布的所有功能之间的影响不产生缺陷

回归环境

确保新的功能不对老的功能产生影响
回归测试一般会借助自动化测试脚本

发布阶段发布之前要查询检查一遍，观察每个服务的发布状态，及时处理异常
发布过程中监视和告警需要特别关注，如果有异常立刻判断是否由变更引起，如果是变引起或用户反馈，及时终止发布。
发布负责人

负责按照计划执行发布
需要通知各个相关人员发布进展
观察各个服务的发布状态，及时处理异常

变更服务的相关 RD

按照上线checklist检查服务的日志，监控，响应上线过程中的告警
对于自己负责的改动，在小流量或者是预览环境进行功能验证
执行发布计划中的其他操作(如线上配置，数据处理等)

值班同学

发布过程中的监控和告警需要特别关注，如果有异常需要立刻判断是否由变更引起
如果有变更引起的告警或者用户反馈，需要及时中止发布

简单发布直接用新版本覆盖老版本

优点：简单、成本低

缺点：发布过程中服务会中断，出了问题会影响全部用户


适用：

测试环境部署
小公司或非核心业务

金丝雀发布由于金丝雀对瓦斯非常铭感，因此以前开矿下矿洞，先放一只金丝雀进去探是否有毒气体，看到金丝雀能否活下来，金丝雀发布由此得名。先发一台服务看看是否有问题

优点：相对简单，能用少量用户验证新版本功能

缺点：发布过程中服务也会中断，发现不了随用户增大才会暴露的问题


适用：

测试环境部小公司或非核心业务

滚动发布（推荐）每个实例都通过金丝雀的方式逐步放大流量，对用户影响小，体验平滑

优点：发布过程中用户不会中断，可以充分验证服务功能

缺点：流程复杂，对发布系统比较高的要求，发布速度慢，新老版本不兼容的情况不能用


适用：

发布系统能力较强，可以平滑切换流量
发布自动化程度高，可以自动滚动

蓝绿发布（推荐）把服务分为蓝绿两组，先把蓝组流量摘除然后升级，只用绿组提供服务，之后切换全部流量，只用蓝组提供服务，然后升级绿组服务，最终全部升级

优点：发布速度快，流程相对简单

缺点：需要对一般机器承担所有流量的能力，出问题影响全部用户


适用：

服务器资源丰富
新老版本不能兼容的情况，需要一次性升级到新版

半夜流量一般比较低，适合做发布，所有这就是大部分后端开发都工作时间比较晚的原因
红黑发布和蓝绿发布类似，但是发布时会动态扩容出一组新的服务，而不需要常备两组服务

优点：发布速度快流程相对简单

缺点：需要能扩容一倍对机器数量仍然有要求，出问题会影响全部用户


适用：

服务器资源丰富
新老版本不能兼容的情况，需要一次性升级到新版

运维阶段（了解就行）公司在发展过程中，逐渐形成了十分复杂的超大规模微服务体系。为了实现对这些复杂微服务的监控，我们往往会在微服务中添加埋点采集 Metrics、Logging、分布式 Trace 等多种数据。
优化流程
技术的发展会带来质量和效率的同时提高

将质量保障融入到流程，将流程自动化

从需求到上线全流程自动化，同时提高质量和效率

DevOps：将开发和运维无缝集成的方法论，通过自动化和协作提高软件开发和运维效率和质量。

全流程自动化：通过自动化工具和流程实现代码构建、测试、部署和监控等环节的自动化。

目标是提高团队效率、减少手动操作和人为错误，实现快速交付和持续集成。


]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2025/02/18/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[了解微服务架构

优势：

开发效率高、2. 业务独立设计、3. 自下而上、4. 故障隔离


劣势：

治理、运维难度高、2. 观测挑战、3. 安全性、4. 分布式系统的问题



核心要素
服务治理

服务注册、2. 服务发现、3. 负载均衡、4. 扩缩容、5. 流量治理、6. 稳定性治理


可观测性

日志采集、2. 日志分析、3. 监控打点、4. 监控大盘、5. 异常报警、6. 链路追踪


安全

身份验证、2. 认证授权、3. 访问令牌、4. 审计、5. 传输加密、5. 黑产攻击



微服务架构原理及特征基本概念
服务(service)

一组具有相同逻辑的运行实体。


实例(instance)

一个服务中，每个运行实体即为一个实例。


实例与进程的关系

实例与进程之间没有必然对应关系，可以一个实例可以对应一个或多个进程(反之不常见)


集群(cluster)

通常指服务内部的逻辑划分，包含多个实例。


常见的实例承载形式

进程、VM、k8s pod


有状态&#x2F;无状态服务

服务的实例是否存储了可持久化的数据(例如磁盘文件)。



服务间通信对于单体服务，不同模块通信只是简单的函数调用。对于微服务，服务间通信意味着网络传输。

服务注册及发现在代码层面，我们如何去调用一个服务的地址？
答：加一层，新增一个统一的服务注册中心，用于存储服务名到服务实例的映射，类似于 DNS，但DNS问题也很多，例如：本地 DNS 存在缓存，导致延时负载均衡问题，不支持服务实例的探活检查域名无法配置端口等等
下图为服务实例上线与下线过程，讲师在讲这里时非常清晰很生动

流量特征
统一网关入口
内网通信多数采用RPC
网状调用链路


核心服务治理功能服务发布服务发布(deployment)，即指让一个服务升级运行新的代码的过程
常见的服务发布难点：
1. 服务不可用、2. 服务抖动、3. 服务回滚 

讲解中讲了两种方法，都是之前有了解过的：

蓝绿发布：简单、但需要两倍资源（可以根据流量的错峰特性使用蓝绿发布）
金丝雀发布：过度平滑，但是在部署时进度在1%～99%时都有可能出现问题，需要回滚版本，这种维护能力需要平台级的设施提供支持。


流量治理在微服务架构下，我们可以基于地区、集群、实例、请求等维度，对端到端流量的路由进行精确控制。

负载均衡负载均衡((Load Balance)负责分配请求在每个下游实例上的分布。
常见的LB策略：


绝对公平、2. 随机、3. 一次性哈希



稳定性治理线上服务总是会出问题的，这与程序的正确性无关。
常见的问题：


网络攻击、2. 流量突增、3. 机房断电、4. 光纤被挖、5. 机械故障、6. 网络故障、 7. 机房空调故障



微服务架构中典型的稳定性治理功能：


限流、2. 熔断、3. 过载保护、4. 降级




重试本地函数调用可能出现的问题：


参数非法、2. OOM (Out Of Memory)、3. NPE (Null Pointer Exception)、4. 边界 case



系统崩溃、6. 死循环、7. 程序异常退出



远程函数调用可能出现的问题：


网络抖动、2. 下游负载高导致超时、3. 下游机器宕机、4. 本地机器负载高，调度超时、5. 下游熔断、限流



本地函数重试基本上是没有意义的，而远程函数重试则有意义，因为其发生请求错误的原因可能不是下游程序编写出错
重试的意义
降低错误率：单次错误概率为0.01，连续错误两次概率为0.0001
降低长尾延迟：对于偶尔耗时较长的请求，重试请求有机会提前返回
规避暂时性错误：网络抖动
避开下游故障实例：一个服务可能会有少量故障实例（如机器故障），重试可以将请求打到其他机器

重试的难点
幂等性

幂等性是指多次执行同一操作，结果与执行一次相同，确保了即使请求被多次发送，也不会引发重复操作或数据不一致的问题


超时设置

超时设置是重试机制中的关键环节，合理的超时时间可以避免系统资源被无效占用，同时也能减少重试风暴的风险


重试风暴

重试风暴是指由于重试策略配置不当，导致系统在短时间内收到大量重试请求，从而引发系统过载甚至崩溃的现象



重试策略
限制重试比例

设定一个重试比例阈值（例如1%），重试此处占所有请求比例不超过该阈值。


防止链路重试

链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试，可以返回特殊的 status 表明“请求失败，但别重试”


对冲请求（Hedged requests）

对于可能超时(或延时高)的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应,



重试效果验证讲解中有举例，字节跳动工作组有做过对应的实验并产出结论

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化及自动内存管理</title>
    <url>/2025/02/20/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.Go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[&#x3D;&#x3D;这里主要讲的是Go语言&#x3D;&#x3D;，太概念了，这知识根本不入脑
性能优化提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力
性能优化的作用
用户体验：带来用户体验的提升 - 让刷抖音更丝滑，让双十一购物不再卡顿
资源高效利用：降低成本，提高效率 - 很小的优化乘以海量机器会是显著的性能提升和成本节约

性能优化的层面
业务层优化
针对特定场景，具体问题，具体分析
容易获得较大性能收益


语言运行时优化
解决更通用的性能问题
考虑更多场景
Tradeoffs


数据驱动
自动化性能分析工具 – pprof
依靠数据而非猜测
首先优化最大瓶颈



软件质量
软件质量至关重要
在保证接口稳定的前提下改进具体实现
测试用例:覆盖尽可能多的场景，方便回归
文档：做了什么，没做什么，能达到怎样的效果
隔离：通过选项控制是否开启优化
可观测:必要的日志输出

自动内存管理
动态内存
程序在运行时根据需求动态分配的内存：malloc()


自动内存管理(垃圾回收):由程序语言的运行时系统管理动态内存
避免手动内存管理，专注于实现业务逻辑
保证内存使用的正确性和安全性: double-free problem, use-after-free problem



相关概念
Mutator:业务线程，分配新对象，修改对象指向关系
Collector: GC 线程，找到存活对象，回收死亡对象的内存空间
Serial Gc: 只有一个 collector
Parallel Gc: 支持多个 collectors 同时回收的 GC 算法
Concurrent GC: mutator(s)和 collector(s)可以同时执行
Collectors 必须感知对象指向关系的改变



追踪垃圾回收
对象被回收的条件：指针指向关系不可达的对象
标记根对象
静态变量、全局变量、常量、线程栈等


标记：找到可达对象
求指针指向关系的传递闭包：从根对象出发，找到所有可达对象


清理：所有不可达对象
将存活对象复制到另外的内存空间(Copying GC)
将死亡对象的内存标记为“可分配”(Mark-sweep GC)
移动并整理存活对象(Mark-compact GC)


根据对象的生命周期，使用不同的标记和清理策略

]]></content>
  </entry>
  <entry>
    <title>开源实践入门</title>
    <url>/2025/02/21/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.%E5%BC%80%E6%BA%90%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/%E5%BC%80%E6%BA%90%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[看完感觉跟没看一样，学习笔记就直接把课件CV一份，好歹也是看了
开源软件定义非盈利组织 Open Source Initiative(OSI)极力倡导，任何开源软件都必须遵循如下标准

可以被免费进行二次分发。
源代码应当公开、可用。
可以与原始软件不同的格式进行修改和分发。
软件本身不应歧视任何个人或团体。
软件本身不应限制其他软件的使用或调用。

开源不仅仅意味着源码开放，同时还需要支持衍生物发行、符合传播规范、满足非歧视原则等要求OSI让开源具有了教育和倡导开放式开发流程的优势。(社会价值)开源软件提供了一种与潜在的软件用户和开发人员相互动的宝贵方法。通过一个具有互动参与性的社区大家可以创建新的或改进原有的源代码。(项目价值)
自由软件 &amp; 开源软件 &amp; 免费软件
所谓“Free Software”中的“free”-词强调的是自由，而不是价格上的免费。
自由软件有比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都能被称为“自由”。
免费软件就是不要钱的软件，但“不要钱”的定义往往是模糊的:是指人们取得该软件时无需付费，还是说人们在使用的过程中都无需付费，亦或是指该软件的发行者不从中获取利益?实际情况往往是复杂而黑暗的。

开源软件的意义从软件分发而言

任何人可以修改源代码，以满足使用需求
打破专有软件垄断，根据许可证要求再分发
降低软件总拥有成本，促进软件行业快速发展

从行为动机而言

礼物文化:付出热情、智慧和努力，得到认可
行动中学习，教与学的过程，例如 Code Review

从技术发展而言

标准化快速落地，打破软件烟囱，技术生态繁荣发展
沟通协作和技术场景复杂，促进代码和架构的模块化
开源引领技术创新，成为新技术的摇篮

从组织管理而言

打造开放式组织，最大化知识工作者的效益
Private Collective Model，即成员私有投入，产出公开可见
民主与决策，Communityovercode 下的社区治理实践

]]></content>
  </entry>
  <entry>
    <title>定时计划</title>
    <url>/2025/02/17/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E5%AE%9A%E6%97%B6%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[基本的定时任务
Windows运行批处理文件

Windows任务计划程序（右键我的电脑）

Linux命令—CronJob

应用程序编码层—单机定时任务（Timer—Java、Ticker—Go、ScheduledExecutorService—线程池技术）

任务调度—Quartz（单任务极致控制、没有负载均衡机制）

分布式定时任务（平台化管理、分布式部署、支持海量数据）


分布式定时任务
定时任务是指系统为了自动完成特定任务，实时、延时、周期性完成任务调度的过程。

分布式定时任务是把分散的、可靠性差的定时任务纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。


按触发时机分类:

定时任务：特定时间触发，比如今天15:06执行
延时任务：延时触发，比如10s后执行
周期任务：固定周期时间，或固定频率周期调度触发，比如每天12点或者每隔5s执行

特点
自动化：全自动完成定时任务的认度和执行
平台化：基于平台化的思维管控系列的分布式定时任务
分布式：在分布式系统环境下运行任务调度，突破单机定时任务的性能瓶颈
伸缩性：采用集群方式部署，可随时按需扩缩容
高可用：单点故障不影响最终任结果，可以做到故障转移

执行方式
单机任务：随机触发一台机器执行任务，适用于计算量小、并发度低的任务

广播任务：广播到所有机器上执行同一个任务，比如所有机器一起清理日志

Map任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算。适用于计算量单机无法满足要求的任务

MapReduce任务：在Map任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务


业内定时任务框架
比较分布式定时任务VS单机定时任务

关系:
都可以实现自动化的定时、延时、周期任务调度


差异:
分布式定时任务可支撑更大的业务体量
分布式定时任务的性能、伸缩性、稳定性更高



分布式定时任务VS大数据处理引擎

关系:
都可以对海量数据做处理
性能、伸缩性、稳定性都很高


差异:
定时并不是大数据处理引擎要解决的核心问题
大数据处理引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做这个之外，还可以调用HTTP和RPC服务



核心架构分布式定时任务核心要解决触发、调度、执行三个关键问题

触发器：Trigger，解析任务，生成触发事件

这个定时任务在什么时间点被准时准点的触发


调度器：Scheduler，分配任务，管理任务生命周期

这个任务触发了怎么去协调机器来进行任务的调度


执行器：Executor，获取执行任务单元，执行任务逻辑

单台机器怎么去把分配的任务执行好，遇到故障的回复等等



除此之外，还需要提供一个控制台(Admin)，:提供任务管理和干预的功能。

控制台

任务:Job，任务元数据

任务元数据(Job)是用户对任务属性定义（who），包括任务类型调度时机（when）、执行行为（what）、执行方式（how）等


任务实例:Joblnstance,任务运行的实例

任务实例(Joblnstance)是一个确定的 Job 的一次运行实例（Job_id、触发时间、状态&amp;结果、过程消息）


任务结果:JobResult，任务实例运行的结果

任务历史:JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储


触发器核心职责

给定一系列任务，解析它们的触发规则，在规定的时间点触发任务的调度

设计约束

需支持大量任务
需支持秒级的调度
周期任务需要多次执行
需保证秒级扫描的高性能，并避免资源浪费

方案时间轮 ( Quartz 所用方案)时间轮是一种高效利用线程资源进行批量化调度的一种调度模型。时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表。

不同业务之间，任务的调度相互影响怎么办？负责扫描和触发的机器挂了怎么办？

存储上：不同国别、业务做资源隔离
运行上：不同国别、业务分开执行
部署时：采用多机房集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只被触发一次

调度器资源来源
业务系统提供资源（阿里、美团、字节）

优点：任务执行逻辑与业务系统共用一份资源，利用率高
缺点：更容易发生定时任务脚本影响在线业务的事故；不能由定时任务平台控制扩缩容


定时任务平台提供机器资源（字节）

优点：任务执行逻辑与业务系统提供的在线服务隔离，避免相互影响，可以优化扩缩容
缺点：消耗更多机器资源；需要额外为定时任务平台申请接口调用权限，而不能直接继承业务系统的权限



节点选择
随机节点执行：选择集群中一个可用的执行节点执行调度任务。适用场景：定时对账，
广播执行：在集群中所有的执行节点分发调度任务并执行。适用场景：批量运维。
分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率。适用场景：海量日志统计。

任务分片：
高级特性
任务编排：使用有向无环图 DAG(Directed Acyclic Graph)进行可视化任务编排

N个执行器Executor，M个业务数据区段，最好M&gt;&#x3D;N，且M是N的整数倍


故障转移：分片任务基于一致性Hash策略分发任务，当某个执行器异常时，调度器会将任务分发到其他执行器。

分片任务基于一致性hash策略分发任务，当某Executor异常时，调度器会将任务分发到其他Executor


高可用：调度器可以集群部署，做到完全无状态，靠消息队列的重试机制保障任务一定会被调度。


上半图为故障转移的分发任务，下半图为高可用的消息队列重试机制
执行器基于注册中心，可以做到执行器的弹性扩缩容
]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2025/01/17/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.DataBase/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[ARID磁盘阵列Q : 单机存储系统怎么做到高性能&#x2F;高性价比&#x2F;高可靠性
A : R(edundant) A(array) I(nexpensive) D(isks)
ARID的使用背景
单块大容量磁盘的价格 &gt; 多块小容量磁盘
单块磁盘的写入性能 &lt; 多块磁盘的并发写入功能
单块磁盘的容错能力有限，不够安全

常见ARID方案
RAID 0
多块磁盘简单组合
数据条带化存储，提高磁盘带宽
没有额外的容错设计  例如一条1G的数据1被拆成两条512M数据，分别写道磁盘1和磁盘2上，然后磁盘1和磁盘2的第一个512M共同组成数据1


RAID 1
一块磁盘对应着一块额外的磁盘
真实空间利用率仅50%
容错能力强  RAID 1和RAID 0是两个极端，把一条数据copy一份放在两个磁盘上


RAID 0 + 1
结合了 RAID 0 和 RAID 1
真实空间利用率只有50%
容错能力强，写入宽带好  例如说，现在有四块磁盘，可以把它两两组成一个 RAID 0，然后再把组成的单元用 RAID 1 组成起来或者组成 RAID 1，然后再用 RAID 0 组成起来，虽然空间利用率还是只有50%，但是还用上了 RAID 1 的条带化写入，并发存储，写入带宽能翻几倍。



数据库关系 &#x3D; 集合 &#x3D; 任意元素组成的若干有序偶对反应了事物间的关系
关系代数 &#x3D; 对关系作运算的抽象查询语言(交、并、笛卡尔积……)
SQL &#x3D; 一种DSL(领域特定语言)
单机数据库单机数据库 &#x3D; 单个计算机节点上的数据库系统
事物在单机内执行，也可能通过网络交互实现分布式事物


关系型数据库关系型数据库是存储系统，但是在存储之外，有发展出其他功能

结构化数据友好
支持事务(ACID(原子性，一致性、隔离性，持久性))
支持复杂查询语言


非关系型数据库非关系型数据库也是存储系统，但是一般不要求严格的结构化
关系型数据库一般直接使用 SQL 交互，而非关系型数据库交互方式各不相同
非关系型数据库的数据结构千奇吧百怪，没有关系约束后，schema相对灵活
单机存储系统单机存储系统 &#x3D; 单个计算机节点上的存储软件系统，一般不涉及网络交互
本地文件系统Linux经典哲学：一切皆文件

文件系统管理单元：文件
文件系统接口：如Ext2&#x2F;3&#x2F;4，sysfs，rootfs等，但都遵循VFS的统一抽象接口
Liunx文件系统的两大数据结构：Index Node &amp; Directory Entry


Key-value存储
常见使用方式：put(k, v) &amp; get(k)
常见数据结构：LSM-Tree，某种程度上牺牲读性能，追求写性能

分布式存储系统分布式存储系统 &#x3D; 在单机存储基础上实现了分布式协议，涉及大量网络交互
可以解决容量、弹性、性价比问题：
单机数据库通过本地文件系统提供的文件接口，在底层的存储介质读&#x2F;写文件，这有个很明显的问题，就是存储是有限的，所以我们现在普遍使用的是池化的技术，把存储能力做成了一个存储池，存储池由物理或者虚拟机组成，存储池与数据库是用网络进行交互，这样，数据库就不需要看本身的存储能力够不够，只要存储池在达到预值后自动添加存储节点，把数据的写入分配到新加入的存储节点即可
解决弹性问题HDFS堪称大数据时代的基石
核心特点：

支持海量数据存储
高容错性
弱POSIX语义
使用普通x86服务器，性价比高

Ceph开源分布式存储系统里的&#x3D;&#x3D;万金油
核心特点：

一套系统支持对象接口、块接口、文件接口，但是一切皆对象
数据写入采用主备复制模型
数据分布模型采用CURSH算法

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>RDBMS</title>
    <url>/2025/01/20/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.RDBMS/RDBMS/</url>
    <content><![CDATA[ACIDACID：

原子性( tomicity):事务是一个不可再分割的工作单元,事务中的操作要么都发生，要么都不发生。
一致性( onsistency):数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性，每个操作都必须是合法的。
隔离性( solation):多个事务并发访问时,事务之间是隔离的,一个事务不应该影响其它事务运行效果，类似于串行操作。
持久性(Curability):在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

模型1960s，传统的文件系统已经不能满足人们的需要，数据库管理系统(DBMS)应运而生DBMS:按照某种数据模型来组织、存储和管理数据的仓库。所以通常按照数据模型的特点将传统数据库系统分成网状数据库、层次数据库和关系数据库三类。
网状模型
把每个数据作为一个节点，构成一个网状的结构，每个父节点可以有多个子节点，一个子节点也可以有多个父节点，多对多
层次模型
层次模型是一个树形模型，层次模型和网状模型特别相像，最大的不同是每个父节点可以有多个子节点，但每个子节点只能有一个父节点，一对多
关系模型
把所有的关系都存放在一个或多个二维表里，就是我们现在所使用的数据库模型
优势与劣势


模型类型
优势
劣势



网状模型
- 能直接描述现实世界- 存取效率较高
- 结构复杂- 用户不易使用- 访问程序设计复杂


层次模型
- 结构简单- 查询效率高- 可以提供较好的完整性支持
- 无法表示M:N的关系- 插入、删除限制多- 遍历子节点必须经过父节点- 访问程序设计复杂


关系模型
- 实体及实体间的联系都通过二维表结构表示- 可以方便的表示M:N关系- 数据访问路径对用户透明
- 关联查询效率不够高- 关系必须规范化


SQL
语法风格接近自然语言;
高度非过程化;
面向集合的操作方式;
语言简洁，易学易用。

一条SQL语句的执行：

Parser：语法解析器
AST：语法树
Optimizer：优化器
Plan：生成一个树状结构PlanTree
Executor：执行器&#x3D;&#x3D;其中Parsser、Optimizer、Executor都是SQL引擎，DataFile、LogFile都是存储引擎，事物引擎没有显示的表现在图上&#x3D;&#x3D;

Parser解析器(Parser)一般分为词法分析(Lexical analysis)、语法分析(Syntax analysis)、语义分析(Semantic analyzer)等步骤。

Optimizer作用是在多种可能中选取最优的那种
基于规则的优化（RBO  Rule  Base Optimizer）
条件优化

a &gt; b &amp; a &gt; 5  –&gt;  a &gt; 5 &amp; b &gt; 5
a &gt; 5 &amp; a &lt; b &amp; b &#x3D; 1 –&gt;  false


表连接优化

总是小表先进行连接


Scan优化

唯一索引
普通索引
全表扫描



基于代价的优化（CBO  Cost Base Optimizer）一个查询有多种执行方案，CBO会选择其中代价最低的方案去真正的执行
例如：时间，IO，CPU，NET，内存
存储引擎InnoDB
支持行锁，采用MVCC来支持高并发，有可能死锁
支持事务
支持外键
支持崩溃后的安全恢复
不支持全文索引

B+Tree页面内页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。从根到叶，中间节点存储
事物日志
Atomicity &amp; Undo log

Undo Log是逻辑日志，记录的是数据的增量变化。利用Undo Log可以进行事务回滚，从而保证事务的原子性。同时也实现了多版本并发控制(MVCC)解决读写冲突和一致性读的问题


Isolation &amp; MVCC

MVCC的意义:
读写互不阻塞;
降低死锁概率;
实现一致性读。




Durability &amp; Redo Log

redo log是物理日志，记录的是页面的变化，它的作用是保证事务持久化。如果数据写入磁盘前发生故障，重启MySQL后会根据redo loq重做。



大流量以下为缩写，有需要对照去查资料
Sharding问题背景

单节点写容易成为瓶颈单机数据容量上限

解决方案

业务数据进行水平拆分代理层进行分片路由

实施效果

数据库写入性能线性扩展数据库容量线性扩展

扩容问题背景

活动流量上涨集群性能不满足要求

解决方案

扩容DB物理节点数量利用影子表进行压测

实施效果

数据库集群提供更高的吞吐保证集群可以承担预期流量

代理连接池问题背景

突增流量导致大量建联大量建联导致负载变大，延时上升

解决方案

业务侧预热连接池
代理侧预热连接池
代理侧支持连接队列

实施效果

避免 DB 被突增流量打死避免代理和 DB 被大量建联打死

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言</title>
    <url>/2025/01/21/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.Go/Go%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[基础语法
变量
var 变量名 &#x3D; 值
int（数据类型） 变量名 &#x3D; 值
变量名 :&#x3D; 值


常量
const 变量名 &#x3D; 值
const 变量名 数据类型 &#x3D; 值



判断 IFpackage main    import &quot;fmt&quot;    func main() &#123;      if 7%2 == 0 &#123;         fmt.Println(&quot;7 is even&quot;)      &#125; else &#123;         fmt.Println(&quot;7 is odd&quot;)      &#125;        if 8%4 == 0 &#123;         fmt.Println(&quot;8 is divisible by 4&quot;)      &#125;        if num := 9; num &lt; 0 &#123;         fmt.Println(num, &quot;is negative&quot;)      &#125; else if num &lt; 10 &#123;         fmt.Println(num, &quot;has l digit&quot;)      &#125; else &#123;         fmt.Println(num, &quot;has multiple digits&quot;)      &#125;  &#125;

循环 For在 Go 中没有 while 和 do while，只有 for 循环
package main    import &quot;fmt&quot;    func main() &#123;      i := 1      for &#123;         fmt.Println(&quot;loop&quot;)         break      &#125;        for j := 7; j &lt; 9; j++ &#123;         fmt.Println(j)      &#125;        for n := 0; n &lt; 5; n++ &#123;         if n%2 == 0 &#123;            continue         &#125;         fmt.Println(n)      &#125;        for i &lt;= 3 &#123;         fmt.Println(i)         i++      &#125;  &#125;

选择 Switch相较于C++、Java，Go中的 switch 不需要在每个 case 后都加 break
package main    import (      &quot;fmt&quot;      &quot;time&quot;)    func main() &#123;      a := 2      switch a &#123;      case 1:         fmt.Println(&quot;one&quot;)      case 2:         &#123;            fmt.Println(&quot;two&quot;)         &#125;      case 3:         fmt.Println(&quot;three&quot;)      case 4, 5:         fmt.Println(&quot;four or five&quot;)      default:         fmt.Println(&quot;other&quot;)      &#125;        t := time.Now()      switch &#123;      case t.Hour() &lt; 12:         fmt.Println(&quot;It&#x27;s before noon&quot;)      default:         fmt.Println(&quot;It&#x27;s after noon&quot;)      &#125;  &#125;

如上 a &#x3D; 2，进入 switch 后 进入 case 2，跑完 case 2 的事件后就到 t :&#x3D; time.Now() 
而且，Go 的 switch 可以用任意的变量类型，比如字符串，结构体等
数组一样，数组长度是固定的
package main    import &quot;fmt&quot;    func main() &#123;      var a [5]int      a[4] = 100      fmt.Println(a[4], len(a))        b := [5]int&#123;1, 2, 3, 4, 5&#125;      fmt.Println(b)        var twoD [2][3]int      for i := 0; i &lt; 2; i++ &#123;         for j := 0; j &lt; 3; j++ &#123;            twoD[i][j] = i + j         &#125;      &#125;      fmt.Println(twoD)  &#125;

切片个人感觉就是链表
package main    import &quot;fmt&quot;    func main() &#123;      s := make([]string, 3)      s[0] = &quot;a&quot;      s[1] = &quot;b&quot;      s[2] = &quot;c&quot;      fmt.Println(s[2])      fmt.Println(len(s))        s = append(s, &quot;d&quot;)      s = append(s, &quot;e&quot;, &quot;f&quot;)      fmt.Println(s)        c := make([]string, len(s))      copy(c, s)      fmt.Println(c)        fmt.Println(s[2:5]) // [c d e]      fmt.Println(s[:5])  // [a b c d e]      fmt.Println(s[2:])  // [c d e f]        good := []string&#123;&quot;g&quot;, &quot;o&quot;, &quot;o&quot;, &quot;d&quot;&#125;      fmt.Println(good)  &#125;

map变量名 := make(map[键]值)
接收值1, 接收值2 := map变量名[&quot;键&quot;]  第二个接收值可以查看map中是否有这个键，有返回true，反之false
package main    import &quot;fmt&quot;    func main() &#123;      m := make(map[string]int)      m[&quot;one&quot;] = 1      m[&quot;two&quot;] = 2      fmt.Println(m)            // Output: map[one:1 two:2]      fmt.Println(len(m))       // Output: 2      fmt.Println(m[&quot;one&quot;])     // Output: 1      fmt.Println(m[&quot;unknown&quot;]) // Output: 0        r, ok := m[&quot;unknown&quot;]      fmt.Println(r, ok) // Output: 0 false        delete(m, &quot;one&quot;)        m2 := map[string]int&#123;&quot;three&quot;: 3, &quot;four&quot;: 4&#125;      var m3 = map[string]int&#123;&quot;three&quot;: 3, &quot;four&quot;: 4&#125;      fmt.Println(m2, m3) // Output: map[three:3 four:4] map[three:3 four:4]  &#125;

rangefor 变量1, 变量2 := range 数组（容器） &#123;&#125;  变量1是索引 index， 变量2是索引对照的值val
如果不需要索引就用下划线 _ 代替
package main    import &quot;fmt&quot;    func main() &#123;      nums := []int&#123;1, 2, 3, 4, 5&#125;      sum := 0      for i, num := range nums &#123;         sum += num         if num == 2 &#123;            fmt.Println(&quot;index: &quot;, i, &quot;nums: &quot;, num)         &#125;      &#125;      fmt.Println(&quot;sum: &quot;, sum)        m := map[string]string&#123;&quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, &quot;c&quot;: &quot;C&quot;&#125;      for k, v := range m &#123;         fmt.Println(k, v) // prints &quot;a A&quot;, &quot;b B&quot;, &quot;c C&quot;      &#125;      for k := range m &#123;         fmt.Println(&quot;key &quot;, k) // prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot;      &#125;  &#125;

函数package main    import &quot;fmt&quot;    func add(a int, b int) int &#123;      return a + b  &#125;    func add2(a, b int) int &#123;      return a + b  &#125;    func exists(m map[string]string, key string) (v string, ok bool) &#123;      v, ok = m[key]      return v, ok  &#125;    func main() &#123;      res := add(1, 2)      fmt.Println(res)        v, ok := exists(map[string]string&#123;&quot;a&quot;: &quot;A&quot;&#125;, &quot;a&quot;)      fmt.Println(v, ok)  &#125;

指针相较于 C&#x2F;C++，这里的指针操作有限，主要用途是对传入的参数进行修改
package main    import &quot;fmt&quot;    func add2(n int) &#123;      n += 2  &#125;    func add2ptr(n *int) &#123;      *n += 2  &#125;    func main() &#123;      n := 5      add2(n)      fmt.Println(n) // Output: 5      add2ptr(&amp;n)      fmt.Println(n) // Output: 7  &#125;

结构体package main    import &quot;fmt&quot;    type user struct &#123;      name     string      password string  &#125;    func main() &#123;      a := user&#123;name: &quot;John&quot;, password: &quot;12345&quot;&#125;      b := user&#123;&quot;Mary&quot;, &quot;67890&quot;&#125;      c := user&#123;name: &quot;Mike&quot;&#125;      c.password = &quot;98765&quot;      var d user      d.name = &quot;Peter&quot;      d.password = &quot;4321&quot;        fmt.Println(a, b, c, d) // Output: &#123;John 12345&#125; &#123;Mary 67890&#125; &#123;Mike 98765&#125; &#123;Peter 4321&#125;      fmt.Println(checkPassword(a, &quot;1234&quot;)) // Output: false      fmt.Println(checkPassword2(&amp;a, &quot;12345&quot;)) // Output: true  &#125;    func checkPassword(u user, password string) bool &#123;      return u.password == password  &#125;    func checkPassword2(u *user, password string) bool &#123;      return u.password == password  &#125;

结构体方法package main    import &quot;fmt&quot;    type user struct &#123;      name     string      password string  &#125;    func (u user) checkPassword(password string) bool &#123;      return u.password == password  &#125;    func (u *user) resetPassword(password string) &#123;      u.password = password  &#125;    func main() &#123;      a := user&#123;name: &quot;John&quot;, password: &quot;12345&quot;&#125;      b := user&#123;&quot;Mary&quot;, &quot;67890&quot;&#125;      c := user&#123;name: &quot;Mike&quot;&#125;      c.password = &quot;98765&quot;      var d user      d.name = &quot;Peter&quot;      d.password = &quot;4321&quot;      fmt.Println(a.checkPassword(&quot;12345&quot;))  &#125;

错误处理一般在做错误处理时需返回 error，如果有错误就返回 errors.New(&quot;错误介绍&quot;)，否则返回 nil
package main    import (      &quot;errors&quot;      &quot;fmt&quot;)    type user struct &#123;      name     string      password string  &#125;    func findUser(users []user, name string) (v *user, err error) &#123;      for _, u := range users &#123;         if u.name == name &#123;            return &amp;u, nil         &#125;      &#125;      return nil, errors.New(&quot;not found&quot;)  &#125;    func main() &#123;      u, err := findUser([]user&#123;&#123;&quot;Alice&quot;, &quot;123456&quot;&#125;&#125;, &quot;Alice&quot;)      if err != nil &#123;         fmt.Println(err)         return      &#125;      fmt.Println(u.name)        if u, err = findUser([]user&#123;&#123;&quot;wang&quot;, &quot;123&quot;&#125;&#125;, &quot;li&quot;); err != nil &#123;         fmt.Println(err)         return      &#125; else &#123;         fmt.Println(u.name)      &#125;  &#125;

字符串操作HasPrefix函数用于判断第二个参数代表的字符串&#x2F;字节切片是不是第一个参数的前缀HasSuffix函数则用于判断第二个参数是不是第一个参数的后缀
package main    import (      &quot;fmt&quot;      &quot;strings&quot;)    func main() &#123;      a := &quot;hello&quot;      fmt.Println(strings.Contains(a, &quot;ll&quot;))                // true      fmt.Println(strings.Count(a, &quot;l&quot;))                    // 2      fmt.Println(strings.HasPrefix(a, &quot;he&quot;))               // true      fmt.Println(strings.HasSuffix(a, &quot;llo&quot;))              // true      fmt.Println(strings.Index(a, &quot;ll&quot;))                   // 2      fmt.Println(strings.Join([]string&#123;&quot;he&quot;, &quot;llo&quot;&#125;, &quot;-&quot;)) // &quot;he-llo&quot;      fmt.Println(strings.Repeat(a, 2))                     // &quot;hellohello&quot;      fmt.Println(strings.Replace(a, &quot;e&quot;, &quot;E&quot;, -1))         // &quot;hEllo&quot;      fmt.Println(strings.Split(&quot;a-b-c&quot;, &quot;-&quot;))              // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]      fmt.Println(strings.ToLower(a))                       // &quot;hello&quot;      fmt.Println(strings.ToUpper(a))                       // &quot;HELLO&quot;      fmt.Println(len(a))                                   // 5        b := &quot;你好&quot;      fmt.Println(len(b)) //6  &#125;

字符串格式化package main    import &quot;fmt&quot;    type point struct &#123;      x, y int  &#125;    func main() &#123;      s := &quot;hello&quot;      n := 123      p := point&#123;1, 2&#125;      fmt.Println(s, n, p) // Output: hello 123 &#123;1 2&#125;        fmt.Printf(&quot;s=%v\n&quot;, s) // Output: s=hello      fmt.Printf(&quot;n=%v\n&quot;, n) // Output: n=123      fmt.Printf(&quot;p=%v\n&quot;, p) // Output: p=&#123;1 2&#125;      fmt.Printf(&quot;p=%+v\n&quot;, p) // Output: p=point&#123;x:1, y:2&#125;      fmt.Printf(&quot;p=%#v\n&quot;, p) // Output: p=main.point&#123;x:1, y:2&#125;        f := 3.1415926      fmt.Println(f) // Output: 3.1415926      fmt.Printf(&quot;%.2f\n&quot;, f) // Output: 3.14  &#125;

JSON处理package main    import (      &quot;encoding/json&quot;      &quot;fmt&quot;)    type userInfo struct &#123;      Name  string      Age   int `json:&quot;age&quot;`      Hobby []string  &#125;    func main() &#123;      a := userInfo&#123;Name: &quot;John&quot;, Age: 25, Hobby: []string&#123;&quot;Golang&quot;, &quot;typeScript&quot;&#125;&#125;      buf, err := json.Marshal(a) // 序列化      if err != nil &#123;         panic(err)      &#125;      fmt.Println(buf) // 输出序列化后的json字符串 [123 34 78 97 109...]    fmt.Println(string(buf)) // 输出序列化后的json字符串 &#123;&quot;Name&quot;:&quot;John&quot;,&quot;age&quot;:25,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;typeScript&quot;]&#125;      buf, err = json.MarshalIndent(a, &quot;&quot;, &quot;\t&quot;)      if err != nil &#123;         panic(err)      &#125;      fmt.Println(string(buf))      /*      &#123;       &quot;Name&quot;: &quot;John&quot;,       &quot;age&quot;: 25,       &quot;Hobby&quot;: [          &quot;Golang&quot;,          &quot;typeScript&quot;       ]    &#125;    */      var b userInfo      err = json.Unmarshal(buf, &amp;b)      if err != nil &#123;         panic(err)      &#125;      fmt.Println(b) // 输出反序列化后的结构体 &#123;John 25 [Golang typeScript]&#125;&#125;

时间处理package main    import (      &quot;fmt&quot;      &quot;time&quot;)    func main() &#123;      now := time.Now()      fmt.Println(now) // 2025-01-23 15:36:01.0802031 +0800 CST m=+0.000000001      t := time.Date(2021, 10, 1, 12, 30, 0, 0, time.UTC)      t2 := time.Date(2021, 9, 1, 12, 30, 0, 0, time.UTC)      fmt.Println(t)                                                              // 2021-10-01 12:30:00 +0000 UTC      fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second()) // 2021 10 1 12 30 0      fmt.Println(t.Format(&quot;2006-01-02 15:04:05&quot;))                                // 2021-10-01 12:30:00        diff := t2.Sub(t)      fmt.Println(diff)                           // -720h0m0s      fmt.Println(diff.Minutes(), diff.Seconds()) // -43200 -2.592e+06      t3, err := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2021-10-01 12:30:00&quot;)      if err != nil &#123;         fmt.Println(err)      &#125;      fmt.Println(t3 == t)   // true      fmt.Println(t3.Unix()) // 1633091400  &#125;

数字解析package main    import (      &quot;fmt&quot;      &quot;strconv&quot;)    func main() &#123;      f, _ := strconv.ParseFloat(&quot;3.14&quot;, 64)      fmt.Println(f) // Output: 3.14        n, _ := strconv.ParseInt(&quot;111&quot;, 10, 64)  // 10是指十进制，传0的表示自动识别，64表示精度为64    fmt.Println(n) // Output: 111        n, _ = strconv.ParseInt(&quot;0x1234&quot;, 0, 64)      fmt.Println(n) // Output: 4660        n2, _ := strconv.Atoi(&quot;123&quot;)      fmt.Println(n2) // Output: 123        n2, err := strconv.Atoi(&quot;abc&quot;)      fmt.Println(n2, err) // Output: 0 strconv.ParseInt: parsing &quot;abc&quot;: invalid syntax  &#125;

进程信息package main    import (      &quot;fmt&quot;      &quot;os&quot;    &quot;os/exec&quot;)    func main() &#123;      fmt.Println(os.Args)        fmt.Println(os.Getenv(&quot;PATH&quot;))      fmt.Println(os.Setenv(&quot;AA&quot;, &quot;BB&quot;))        buf, err := exec.Command(&quot;grep&quot;, &quot;127.0.0.1&quot;, &quot;/etc/hosts&quot;).CombinedOutput()      if err != nil &#123;         fmt.Println(err)      &#125;      fmt.Println(string(buf))  &#125;

综合练习猜数字package main    import (      &quot;bufio&quot;      &quot;fmt&quot;    &quot;math/rand&quot;    &quot;os&quot;    &quot;strconv&quot;    &quot;strings&quot;    &quot;time&quot;)    func main() &#123;      maxNum := 100      rand.Seed(time.Now().UnixNano())      secretNumber := rand.Intn(maxNum)        for &#123;         fmt.Println(&quot;Please input your guess&quot;)         reader := bufio.NewReader(os.Stdin)         input, err := reader.ReadString(&#x27;\n&#x27;)         if err != nil &#123;            fmt.Println(&quot;An error occurred while reading input, please try again&quot;, err)            continue         &#125;         input = strings.TrimSuffix(input, &quot;\n&quot;)         guess, err := strconv.Atoi(input)         if err != nil &#123;            fmt.Println(&quot;Invalid input, please try again&quot;, err)            continue         &#125;         if guess &gt; secretNumber &#123;            fmt.Println(&quot;Too high, try again&quot;)         &#125; else if guess &lt; secretNumber &#123;            fmt.Println(&quot;Too low, try again&quot;)         &#125; else &#123;            fmt.Println(&quot;Congratulations, you guessed the number&quot;, secretNumber)            break         &#125;      &#125;  &#125;

在线词典第一步首先打开彩云小译官网 - 高效准确的翻译工具 | 文字翻译 | 文档翻译 | 网页翻译 | 浏览器插件 | 双语对照 | 术语库
按键盘上的 F12 或者右键页面打开检查，随后点击网络

从下往上找第一个dict，右键复制–&gt;复制cURL(bash)
然后打开curl to Go，把复制的代码放在里面，生成 Go
package main    import (      &quot;fmt&quot;      &quot;io&quot;    &quot;log&quot;    &quot;net/http&quot;    &quot;strings&quot;)    func main() &#123;      client := &amp;http.Client&#123;&#125;      var data = strings.NewReader(`&#123;&quot;trans_type&quot;:&quot;zh2en&quot;,&quot;source&quot;:&quot;帅&quot;&#125;`)      req, err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;, data)      if err != nil &#123;         log.Fatal(err)      &#125;      req.Header.Set(&quot;accept&quot;, &quot;application/json, text/plain, */*&quot;)      req.Header.Set(&quot;accept-language&quot;, &quot;zh&quot;)      req.Header.Set(&quot;app-name&quot;, &quot;xiaoyi&quot;)      req.Header.Set(&quot;authorization&quot;, &quot;Bearer&quot;)      req.Header.Set(&quot;content-type&quot;, &quot;application/json;charset=UTF-8&quot;)      req.Header.Set(&quot;device-id&quot;, &quot;&quot;)      req.Header.Set(&quot;origin&quot;, &quot;https://fanyi.caiyunapp.com&quot;)      req.Header.Set(&quot;os-type&quot;, &quot;web&quot;)      req.Header.Set(&quot;os-version&quot;, &quot;&quot;)      req.Header.Set(&quot;priority&quot;, &quot;u=1, i&quot;)      req.Header.Set(&quot;referer&quot;, &quot;https://fanyi.caiyunapp.com/&quot;)      req.Header.Set(&quot;sec-ch-ua&quot;, `&quot;Not A(Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;132&quot;, &quot;Microsoft Edge&quot;;v=&quot;132&quot;`)      req.Header.Set(&quot;sec-ch-ua-mobile&quot;, &quot;?0&quot;)      req.Header.Set(&quot;sec-ch-ua-platform&quot;, `&quot;Windows&quot;`)      req.Header.Set(&quot;sec-fetch-dest&quot;, &quot;empty&quot;)      req.Header.Set(&quot;sec-fetch-mode&quot;, &quot;cors&quot;)      req.Header.Set(&quot;sec-fetch-site&quot;, &quot;cross-site&quot;)      req.Header.Set(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;)      req.Header.Set(&quot;x-authorization&quot;, &quot;token:qgemv4jr1y38jyq6vhvi&quot;)      resp, err := client.Do(req)      if err != nil &#123;         log.Fatal(err)      &#125;      defer resp.Body.Close()      bodyText, err := io.ReadAll(resp.Body)      if err != nil &#123;         log.Fatal(err)      &#125;      fmt.Printf(&quot;%s\n&quot;, bodyText)  &#125;

第二步
我们需要把所需的文本转成 json
package main    import (      &quot;bytes&quot;      &quot;encoding/json&quot;    &quot;log&quot;    &quot;net/http&quot;)    type DictRequest struct &#123;      TranType string `json:&quot;tran_type&quot;`      Source   string `json:&quot;source&quot;`      UserID   string `json:&quot;user_id&quot;`  &#125;    func main() &#123;      client := &amp;http.Client&#123;&#125;      request := DictRequest&#123;TranType: &quot;EN-ZH&quot;, Source: &quot;good&quot;&#125;      buf, err := json.Marshal(request)      if err != nil &#123;         log.Fatal(err)      &#125;      var data = bytes.NewReader(buf)      req, err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;, data)      if err != nil &#123;         log.Fatal(err)      &#125;  &#125;

后因工具因素暂未完成（工具网址暂停运用了），大概工作是对照所需要的 json 来生成 struct，最后全部拼接到一起
]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>代码优化</title>
    <url>/2025/01/23/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[高质量编程编写的代码能够达到正确可靠、简洁清晰的目标可称为高质量代码

各种边界条件是否考虑完备
异常情况处理，稳定性保证
易读易维护

编程原则简单性

消除“多余的复杂性”，以简单清晰的逻辑编写代码 
不理解的代码无法修复改进可读性
代码是写给人看的，而不是机器
编写可维护代码的第一步是确保代码可读生产力
团队整体工作效率非常重要

编写规范注释公共符号始终要注释

包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释
任何既不明显也不简短的公共功能必须予以注释
无论长度或复杂程度如何对库中的任何函数都必须进行注释

注释应该做的：

注释应该解释代码作用
注释应该解释代码如何做的
注释应该解释代码实现的原因
注释应该解释代码什么情况会出错

命名规范变量名
简洁胜于冗长
缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写
例如使用 ServeHTTP 而不是 ServeHttp
使用 XMLHTTPRequest 或者 xmlHTTPRequest


变量距离其被使用的地方越远，则需要携带越多的上下文信息
全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义



例如：
// Badfor index := 0; index &lt; len(s); index++&#123;	//do something...&#125;// Goodfor i := 0; i &lt; len(s); i++&#123;	//do something...&#125;
i 和 index 的作用域范围仅限于 for 循环内部时，index 的额外冗长几乎没有增加对程序的理解
// Goodfunc (c *Client) send(req *Request, deadline time.Time)// Badfunc (c *Client) send(req *Request, t time.Time)
将 deadline 替换成t 降低了变量名的信息量，t 常代指任意时间deadline 指截止时间，有特定的含义
函数名
函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的
函数名尽量简短
当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义
当名为 foo 的包某个函数返回类型 T时(T 并不是 Foo)，可以在函数名中加入类型信息

例如：在 http 包中创建服务器的函数
// Goodfunc Server(I net.Listener, handler Handler) error// Badfunc ServerHTTP(I net.Listener, handler Handler) error
因为我们是在 http 包下创建的函数，如果其他包中调用这个函数那么是 http.函数名，http就没必要出现在函数名中了
package
只由小写字母组成。不包含大写字母和下划线等字符
简短并包含一定的上下文信息。例如 schema、task 等
不要与标准库同名。例如不要使用 sync 或者 strings

以下规则尽量满足，以标准库包名为例

不使用常用变量名作为包名。例如使用 bufio 而不是 buf
使用单数而不是复数。例如使用 encoding 而不是 encodings
谨慎地使用缩写。例如使用 fmt 在不破坏上下文的情况下比 format 更加简短

控制流程避免嵌套，保持正常流程清晰
// Badif foo &#123;	return x&#125;else &#123;	return nil&#125;// Goodif foo &#123;	return x&#125;return nil
如果两个分支中都包含return语句，则可以去除冗余的else
尽量保持正常代码路径为最小缩进

优先处理错误情况&#x2F;特殊情况，尽早返回或继续循环来减少嵌套

// Badfunc OneFunc() err &#123;	err := doSomething()	if err == nil &#123;		err := doSomething()		if err == nil&#123;			return nil // normal case		&#125;		return err	&#125;	return err&#125;// Goodfunc OneFunc() err &#123;	if err := doSomething(); err != nil &#123;		return err	&#125;	if err := doSomething(); err != nil &#123;		return err	&#125;	return nil // normal case&#125;

最常见的正常流程的路径被嵌套在两个 if 条件内
成功的退出条件是 return nil，必须仔细匹配大括号来发现函数最后一行返回一个错误，需要追溯到匹配的左括号，才能了解何时会触发错误
如果后续正常流程需要增加一步操作，调用新的函数，则又会增加一层嵌套

错误和异常处理简单错误
简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误
优先使用 errors.New 来创建匿名变量来直接表示简单错误
如果有格式化的需求，使用 fmt.Errorf

错误的 Wrap 和 Unwrap错误的 Wrap 实际上是提供了一个 error 嵌套另一个error 的能力，从而生成一个 error 的跟踪链在 fmt.Errorf 中使用: %w 关键字来将一个错误关联至错误链中
判断错误判定一个错误是否为特定错误，使用 errors.ls

不同于使用 ==，使用该方法可以判定错误链上的所有错误是否含有特定的错误

在错误链上获取特定种类的错误，使用errors.As
panic注意在Go语言中，recover只在defer调用的函数中有效，并且defer要在panic之前先注册，否则不能捕获异常panic相当于直接 throw 一个异常来终止程序运行，当panic被捕获到后，被注册的函数将获得程序控制权

不建议在业务代码中使用 panic
调用函数不包含 recover 会造成程序崩溃
若问题可以被屏蔽或解决，建议使用error 代替 panic
当程序启动阶段发生不可逆转的错误时可以在 init 或 main 函数中使用 panic

recover
recover 只能在被 defer 的函数中使用
嵌套无法生效
只在当前 goroutine 生效
defer 的语句是后进先出

如果需要更多的上下文信息，可以recover 后在 log 中记录当前的调用栈
优化性能
性能优化的前提是满足正确可靠、简洁清晰等质量因素
性能优化是综合评估，有时候时间效率和空间效率可能对立
针对 Go 语言特性，介绍 Go 相关的性能优化建议

BenchmarkGo 语言提供了支持基准性能测试的 benchmark 工具
go test -bench=. -benchmem

Slice 预分配内存// Badfunc NoPreAlloc(size int) &#123;	data := make([]int, 0)	for k := 0; k &lt; size; k++ &#123;		data = append(data, k)	&#125;&#125;// Goodfunc NoPreAlloc(size int) &#123;	data := make([]int, 0, size)	for k := 0; k &lt; size; k++ &#123;		data = append(data, k)	&#125;&#125;


切片本质是一个数组片段的描述
包括数组指针
片段的长度
片段的容量(不改变内存分配情况下的最大长度)


切片操作并不复制切片指向的元素
创建一个新的切片会复用原来切片的底层数组



在已有切片基础上创建切片，不会创建新的底层数组场景
原切片较大，代码在原切片基础上新建小切片
原底层数组在内存中有引用，得不到释放


可使用 copy 替代 re-slice
map 也是一样，不断向 map 中添加元素的操作会触发 map 的扩容，提前分配好空间可以减少内存拷贝和 Rehash 的消耗

字符串处理常见的字符串拼接方法：strings.Builder
// Badfunc Plus(n int, str string) string &#123;	s := &quot;&quot;	for i := 0; i &lt; n; i++ &#123;		s += str	&#125;	return s&#125;// Goodfunc Plus(n int, str string) string &#123;	var builder strings.Builder	for i := 0; i &lt; n; i++ &#123;		builder.WriteString(str)	&#125;	return builder.String()&#125;

使用 strings.Builder

使用+拼接性能最差，strings.Builder，bytes.Buffer 相近，strings.Buffer 更快

分析

字符串在 Go 语言中是不可变类型，占用内存大小是固定的
使用 +每次都会重新分配内存
strings.Builder，bytes.Buffer 底层都是 []byte 数组
内存扩容策略,不需要每次拼接重新分配内存

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2025/01/24/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[排序Insertion Sort 插入排序
将元素不断插入已经排序好的 array 中

起始只有一个元素5，其本身是一个有序序列
后续元素插入有序序列中，即不断交换，直到找到第一个比其小的元素




Best
Avg
Worst



O(n)
O(n^2)
O(n^2)


缺点

平均和最坏情况的时间复杂度高达 O(n^2)

优点

最好情况时间复杂度为O(n)

总结：插入排序平均和最坏情况时间复杂度都是 O(n^2)
Quick Sort 快速排序
分治思想，不断分割序列直到序列整体有序

选定一个 pivot (轴点)
使用 pivot 分割序列，分成元素比 pivot 大 和元素比 pivot 小两个序列




Best
Avg
Worst



O(n * logn)
O(n * logn)
O(n^2)


缺点

平均和最坏情况的时间复杂度高达 O(n * logn)

优点

最好情况时间复杂度为O(n^2)

总结：快速排序整体性能处于中间层次
Heap Sort 堆排序
大顶堆和小顶堆

小顶堆是根节点比子节点小
大顶堆是根节点比子节点大




Best
Avg
Worst



O(n * logn)
O(n * logn)
O(n * logn)


总结：众生平等堆排序性能稳定




实际场景 benchmark根据序列元素排列情况划分

完全随机的情况(random)
有序&#x2F;逆序的情况 (sorted&#x2F;reverse)
元素重复度较高的情况(mod8)在此基础上，还需要根据序列长度的划分(16&#x2F;128&#x2F;1024)

random

插入排序在短序列中速度最快
快速排序在其他情况中速度最快
堆排序速度于最快算法差距不大

sorted

插入排序在序列已经有序的情况下最快

总结：

所有短序列和元素有序情况下，插入排序性能最好
在大部分的情况下，快速排序有较好的综合性能
几乎在任何情况下，堆排序的表现都比较稳定

pdqsort (pattern-defeating-quicksort)是一种不稳定的混合排序算法，它的不同版本被应用在 C++ BOOST、Rust 以及 Go 1.19 中。它对常见的序列类型做了特殊的优化，使得在不同条件下都拥有不错的性能
结合三种排序方法的优点

对于短序列(小于一定长度)，我们使用插入排序
其他情况，使用快速排序来保认整体性能
当快速排序表现不佳时，使用堆排序来保证最坏情况下时间复杂度仍然为 O(n*logn)

当最终 pivot 的位置离序列两端很接近时(距离小于 length&#x2F;8)判定其表现不佳，当这种情况的次数达到 limit(即 bits.Len(length)时，切换到堆排序
pivot的选择
使用第一个元素作为pivot（最简单的方案）实现简单，但是往往效果不好，如果在sorted情况下性能会很差
遍历数组，寻找真正的中位数遍历比对代价很高，性能不好

优化-Pivot 的选择

短序列(&lt;&#x3D;8)，选择固定元素
中序列(&lt;&#x3D;50)，采样三个元素，median of three
长序列(&gt;50)，:采样九个元素，median of medians

同时Pivot 的采样方式使得我们有探知序列当前状态的能力

如果采样的元素都是逆序排序，那我们可能推出序列已经逆序，我们只需要翻转整个序列
如果采样的元素都是顺序排序，那我们可能推出序列已经顺序，在前面我们已经探究出插入排序对有序序列效率更高，在这里就使用插入排序

注：插入排序实际使用 partiallnsertionSort，即有限制次数的插入排序，因为插入排序在一般序列性能表现是比较差的，我们只是认为可能有顺序的可能，不是真正的有序，用partiallnsertionSort可以限制插入的次数
如果两次 partition 生成的 pivot 相同，即 partition 进行了无效分割,此时认为 pivot 的值为重复元素
优化-重复元素较多的情况(partitonEqual)当检测到此时的 pivot 和上次相同时(发生在 leftSubArray)，使用partitionEqual 将重复元素排列在一起，减少重复元素对于 pivot 选择的干扰



Best
Avg
Worst



O(n)
O(n * logn)
O(n * logn)



]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>对象存储</title>
    <url>/2025/02/06/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%20TOS/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%20TOS/</url>
    <content><![CDATA[我在青训营看完这章对象存储TOS感觉对理论性的知识有了一定了解吧，太理论了，让我复述一遍可能都做不到
我在网上查阅资料后得知

T：Tencent，表示这是腾讯云提供的服务。

O：Object，表示对象存储（Object Storage），是一种存储非结构化数据的技术。

S：Storage，表示存储服务。


首先开头以抖音短视频为例
架构大概分为 片源 -&gt; 转码  -&gt; 审核 -&gt; 播放
但是短视频系统要承载非常多的用户访问量，根据未来的可能的用户数量，做了简单数学计算，结果发现存储量非常之大：

每天: 432块4tb磁盘 

每月：12960块4tb磁盘 

每年： 157680块4tb盘


对于这么大的访问量，我们需要一个合适的存储去承载数据，这个储存需要满足以下三个条件：

海量

易用

便宜


然后列举了四个存储系统

单机存储——&gt;不支持海量，适合的数据类型（单击文件）——&gt;不行

单机数据库——&gt; 不支持海量,只支持结构化和半结构化数据——&gt;不行

分布式数据库——&gt;支持海量，但是单条记录存储的容量太少——&gt;不行

分布式存储——&gt; 大数据计算中间结果&#x2F;视频&#x2F;图片——&gt;行


分布式文件系统（HDFS）

海量：支持PB——&gt;EB海量存储 

易用：伪Posix文件接口，开发略微复杂，非云原生，搭建维护麻烦，视频、图片相关生态接入略微复杂 

便宜：使用普通x86服务器，成本低


分布式对象存储TOS

海量：支持&gt;eb海量存储

易用：RestFul HTTP接口，开发极其简单，云原生，按需申请使用

便宜：使用普通x86服务器，具备冷热数据分级存储能力，成本更低


TOS 的接口
Mkdirs创建文件夹Append：写GET：下载对象HEAD：查看对象上传PUT：上传对象DELETE：删除对象

TOS 中Bucket&#x2F;Object语义
Bucket：存储对象的桶，可类比一下Object：对象，包含以下三个部分key:对象的名字，可类比于Map的keyData：对象的内容，例如视频、图片内容MetaData：对象的一些元信息



]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 框架三件套</title>
    <url>/2025/02/07/articles/MarsCode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.Go%20%E6%A1%86%E6%9E%B6%E4%B8%89%E4%BB%B6%E5%A5%97%E8%AF%A6%E8%A7%A3(Web%20RPC%20ORM)/Gorm%20%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[Gorm 的基本使用
相关文档 https://gorm.io/zh_CN/docs/index.html
gorm目前支持 MySQL、SQLServer、PostgreSQL、SQLite
以 MySQL 为例：
import (  &quot;gorm.io/driver/mysql&quot;  &quot;gorm.io/gorm&quot;)func main() &#123;  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情  dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)&#125;

或者可以更详细的配置：
db, err := gorm.Open(mysql.New(mysql.Config&#123;  DSN: &quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, // DSN data source name  DefaultStringSize: 256, // string 类型字段的默认长度  DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持  DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引  DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列  SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置&#125;), &amp;gorm.Config&#123;&#125;)

创建数据
我们可以使用 clause.OnConflict 处理数据冲突DoNothing: true 意思是遇到数据冲突不做任何改变 
p:=&amp;Product&#123;Code:&quot;D42&quot;，ID:1&#125;db.Clauses(clause.OnConflict&#123;DoNothing: true&#125;).Create(&amp;p)

可以使用 default 标签为字段定义默认值
type User struct &#123;	ID      int64	Name    string `gorm:&quot;default:galeone&quot;`	Age     int64  `gorm:&quot;default:18&quot;`&#125;

查询数据
需要注意的点：

使用 First 时，需要注意查询不到数据会返回 ErrRecordNotFound

使用 Find 查询多条数据，查询不到数据不会返回错误

当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 0、”、false 或其他 零值，该字段不会被用于构建查询条件，使用Map 来构建查询条件。


更新数据
使用 Struct 更新时，只会更新非零值，如果需要更新零值可以使用 Map 更新或使用Select 选择字段。
删除数据物理删除
软删除GORM 提供了 gorm.DeletedAt 用于帮助用户实现软删
拥有软删除能力的 Model 调用 Delete 时，记录不会被从数据库中真正删除。但 GORM 会将 DeletedAt 置为当前时间并且你不能再通过正常的查询方法找到该记录。
使用 Unscoped 可以查询到被软删的数据
事物Gorm 提供了 Begin、Commit、Rollback 方法用于使用事务


特别注意的点，db.Begin() 后会生成一个变量，我们后续的操作都是通过后面的变量

Gorm 提供了 Tansaction 方法用于自动提交事务，避免用户漏写 Commit、Rollbcak

]]></content>
      <tags>
        <tag>字节青训营</tag>
      </tags>
  </entry>
</search>

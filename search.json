[{"title":"CompletableFuture异步编排","url":"/2025/06/23/articles/Substitute driver/CompletableFuture异步编排/","content":"#### 简介\n\n- CompletableFuture是java.utils.concurrent里的一个类\n\n- 作用：把串行执行的代码变为并行执行，提高代码执行速度\n\n### 快速上手\n\n#### 创建异步编排对象\n\n```java\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor);\n\npublic static CompletableFuture<Void> runAsync(Runnable runnable);\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);\n```\n\n\n\n#### 线程串行方法\n\n```java\n// 使线程串行执行，无入参，无返回值\npublic CompletableFuture<Void> thenRun(Runnable action);\npublic CompletableFuture<Void> thenRunAsync(Runnable action);\npublic CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);\n\n// 使线程串行执行，有入参，无返回值\npublic CompletableFuture<Void> thenAccept(Consumer<? super T> action);\npublic CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action);\npublic CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);\n\n// 使线程串行执行，有入参，有返回值\npublic <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\npublic <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn);\npublic <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);\n```\n\n#### 多任务组合\n\n```java\npublic static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);\n```\n\n#### 代码实例\n\n```java\npublic class CompletableFutureTest5 {\n\n    @SneakyThrows\n    public static void main(String[] args) {\n        //动态获取服务器核数\n        int processors = Runtime.getRuntime().availableProcessors();\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                processors+1, // 核心线程个数 io:2n ,cpu: n+1  n:内核数据\n                processors+1,\n                0,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(10),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n\n        CompletableFuture<String> future01 = CompletableFuture.supplyAsync(() -> \"任务1\", executor);\n        CompletableFuture<String> future02 = CompletableFuture.supplyAsync(() -> \"任务2\", executor);\n        CompletableFuture<String> future03 = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"任务3\";\n        }, executor);\n\n        // 串联起若干个线程任务, 没有返回值\n        CompletableFuture<Void> all = CompletableFuture.allOf(future01, future02, future03);\n        // 等待所有线程执行完成\n        // .join()和.get()都会阻塞并获取线程的执行情况\n        // .join()会抛出未经检查的异常，不会强制开发者处理异常 .get()会抛出检查异常，需要开发者处理\n        all.join();\n        all.get();\n    }\n}  \n```","tags":["project"]},{"title":"MongoDB","url":"/2025/06/17/articles/Substitute driver/快速上手MongoDB/","content":"# 概述\n\n- MongoDB 与传统关系型数据库相比更加简单，架构为key-value结构\n- MySQL数据库：数据库-表-记录\n  MongoDB      ：数据库-集合-文档（记录）\n- 文档类似于JSON对象，结构成为BSON\n\n\n\n# 安装与启动\n\n## 1. 导入 MongoDB 官方 GPG 密钥\n\n首先需要导入 MongoDB 官方的 GPG 密钥，以便系统能够验证下载包的完整性。\n\n```bash\ncurl -fsSL https://pgp.mongodb.com/server-7.0.asc | \\\n   sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg \\\n   --dearmor\n```\n\n## 2. 添加 MongoDB 软件源\n\n将 MongoDB 的软件源添加到系统的源列表中，这样就可以通过包管理器直接下载 MongoDB。\n\n```bash\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n```\n\n## 3. 更新包索引\n\n添加完软件源后，需要更新本地的包索引，让系统知道有哪些新的软件包可以安装。\n\n```bash\nsudo apt-get update\n```\n\n## 4. 安装 MongoDB 7.0.0\n\n使用包管理器安装指定版本的 MongoDB。\n\n```bash\nsudo apt-get install -y mongodb-org=7.0.0 mongodb-org-database=7.0.0 mongodb-org-server=7.0.0 mongodb-org-shell=7.0.0 mongodb-org-mongos=7.0.0 mongodb-org-tools=7.0.0\n```\n\n## 5. 锁定 MongoDB 版本\n\n为了防止系统自动升级 MongoDB 版本，需要对其进行版本锁定。\n\n```bash\necho \"mongodb-org hold\" | sudo dpkg --set-selections\necho \"mongodb-org-database hold\" | sudo dpkg --set-selections\necho \"mongodb-org-server hold\" | sudo dpkg --set-selections\necho \"mongodb-org-shell hold\" | sudo dpkg --set-selections\necho \"mongodb-org-mongos hold\" | sudo dpkg --set-selections\necho \"mongodb-org-tools hold\" | sudo dpkg --set-selections\n```\n\n  \n\n## 6. 启动 MongoDB 服务\n\n安装完成后，启动 MongoDB 服务并设置为开机自启动。\n\n```bash\nsudo systemctl start mongod\nsudo systemctl enable mongod\n```\n\n  \n\n## 7. 验证安装结果\n\n通过以下命令检查 MongoDB 服务的运行状态，确认是否安装成功。\n\n```bash\nsudo systemctl status mongod\n```\n\nLinux进入MongoDB\n```shell\nmongosh\n```\n\n```mongosh\nshow dbs  # 查看数据库\ndb.version() # 查看版本  \ndb.getMongo()  # 查看当前db的链接机器地址\ndb.help()    # 帮助\nquit()       # 退出\n```\n\n# 命令行操作MongoDB\n\n### 数据库操作\n\n创建数据库，如果数据库不存在，则创建数据库，否则切换数据库\n```mongosh\nuse 库名\n```\n\n查看当前数据库\n```\ndb.getName()\n```\n\n查看当前数据库状态\n```\ndb.stats()\n```\n\n删除当前数据库\n```\ndb.dropDatabase()\n```\n\n\n### 集合操作\n\n创建集合\n```\ndb.createCollection(\"User\")\n```\n\n删除集合\n```\ndb.集合名.drop()\n```\n\n\n### 文档操作\n\n注意：\n- MongoDB区分类型和大小写\n- MongoDB文档不能有重复的键\n\ninsert，向集合插入一条记录。可以预先使用 `createCollection` 方法创建，也可以不先创建，直接插入，集合会自动创建\n```\ndb.集合名.insert({name:'zhangsan',age:21,sex:true})\n```\n\nfind，查询当前集合中name是zhangsan的数据，空参的话是查询全部\n```\ndb.集合名.find({name:zhangsan})\n```\n\nupdate，只更新匹配到的第一条记录\n```\ndb.集合名.update({age:21},{$set:{name:100})\n```\n更新匹配到的所有记录\n```\ndb.集合名.update({age:21},{set:{name:100}},{multi:true})\n```\n\nremove，删除一个文档\n```\ndb.集合名.remove(id)\n```\n删除所有文档\n```\ndb.集合名.remove({})\n```\n\n# SpringBoot整合MongoDB\n\n- spring-data-mongodb提供了两种方式\n\n第一种 MongoTemplate（更灵活）\n\n第二种 MongoRepository（操作简单）\n\n\n## 准备工作\n\n第一步 创建项目，导入依赖\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.0.5</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <artifactId>mongo_demo0</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!--mongodb-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-mongodb</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n第二步 创建项目文件\n\napplication.yml\n```yaml\nspring:\n  data:\n    mongodb:\n      database: daijia\n      host: 47.107.42.25\n      port: 27017\n```\n\n第三步 创建实体类\n\n```java\n@Data\n@Document(\"user\") //指定mongodb中的集合名字\npublic class User {\n\n    @Id\n    private ObjectId id;\n    \n    private String name;\n    private Integer age;\n    private String email;\n    private Date createDate;\n}\n```\n\n## MongoRepository\n\n* 添加interface继承MongoRepository\n\n```java\npublic interface UserRepository extends MongoRepository<User, ObjectId> {\n}\n```\n\n#### 普通方法\n\n* 编写测试类\n\n```java\n@SpringBootTest\npublic class MongoRepositoryTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    //添加\n    @Test\n    public void add() {\n        User user = new User();\n        user.setName(\"mary\");\n        user.setAge(30);\n        user.setCreateDate(new Date());\n        userRepository.save(user);\n    }\n\n    //查询所有\n    @Test\n    public void findAll() {\n        List<User> list = userRepository.findAll();\n        System.out.println(list);\n    }\n\n    //根据id查询\n    @Test\n    public void testFindById() {\n        Optional<User> optional =\n                userRepository.findById(new ObjectId(\"666a9a85f5294513720647ff\"));\n        boolean present = optional.isPresent();\n        if(present) {\n            User user = optional.get();\n            System.out.println(user);\n        }\n    }\n\n    //条件查询 + 排序\n    // age = 20\n    @Test\n    public void testFindCondition() {\n        //封装条件\n        User user = new User();\n        user.setAge(20);\n        Example<User> example = Example.of(user);\n\n        Sort sort = Sort.by(Sort.Direction.DESC, \"name\");\n\n        List<User> list = userRepository.findAll(example, sort);\n        System.out.println(list);\n    }\n\n    //分页查询\n    @Test\n    public void testPage() {\n        //第一页从0开始的\n        PageRequest pageable = PageRequest.of(0,2);\n\n        Page<User> page = userRepository.findAll(pageable);\n\n        List<User> list = page.getContent();\n        System.out.println(list);\n    }\n\n    //更新\n    @Test\n    public void testUpdateUser(){\n        //注意：先查询，再更新\n        Optional<User> optional = userRepository.findById(\n                new ObjectId(\"64eee9dff317c823c62b4faf\")\n        );\n        if(optional.isPresent()){\n            User user = optional.get();\n            user.setAge(100);\n            //user中包含id，就会执行更新\n            userRepository.save(user);\n            System.out.println(user);\n        }\n    }\n\n    //删除\n    @Test\n    public void testDeleteUser(){\n        userRepository.deleteById(\n                new ObjectId(\"64eee9dff317c823c62b4faf\")\n        );\n    }\n}\n```\n\n#### 命名方法\n\n- MongoRepository也可以**按照规则**在把查询方法创建出来\n\n总体规模：\n- 查询方法 以  get   |   find   |   read开头\n- 后面街上查询字段名称，满足大驼峰命名\n- 字段查询条件添加关键字，比如like\n\n比如：\n```java\n@Repository  \npublic interface OrderServiceLocationRepository extends MongoRepository<OrderServiceLocation, String> {  \n  \n    // 根据订单id获取位置信息，按照创建时间排序  \n    List<OrderServiceLocation> findByOrderIdOrderByCreateTimeAsc(Long orderId);  \n}\n```\n\n## MongoTemplate\n\n```java\n@SpringBootTest\npublic class MongoTemplateTest {\n\n    @Autowired\n    private MongoTemplate mongoTemplate;\n\n    //添加\n    @Test\n    public void add() {\n        User user = new User();\n        user.setName(\"test\");\n        user.setAge(20);\n        user.setCreateDate(new Date());\n        mongoTemplate.insert(user);\n    }\n\n    //查询所有\n    @Test\n    public void findAll() {\n        List<User> list = mongoTemplate.findAll(User.class);\n        list.forEach(user->{\n            System.out.println(user);\n        });\n    }\n\n    //根据id查询\n    @Test\n    public void testFindId() {\n        User user = mongoTemplate.findById(\"666a9b5e9a3653796627bb3c\", User.class);\n        System.out.println(user);\n    }\n\n    //条件查询\n    @Test\n    public void testCondition() {\n        // where name=? and age=?\n        Criteria criteria =\n                Criteria.where(\"name\").is(\"test\").and(\"age\").is(20);\n        Query query = new Query(criteria);\n\n        List<User> list = mongoTemplate.find(query,User.class);\n        System.out.println(list);\n    }\n\n    //分页查询\n    @Test\n    public void testPage() {\n        // limit 0,2\n        Query query = new Query();\n        List<User> list = mongoTemplate.find(query.skip(0).limit(2), User.class);\n        list.forEach(user->{\n            System.out.println(user);\n        });\n    }\n\n    //修改和删除\n    //修改\n    @Test\n    public void testUpdateUser() {\n        Criteria criteria = Criteria.where(\"_id\").is(\"64eeeae31711344f35635788\");\n        Query query = new Query(criteria);\n        Update update = new Update();\n        update.set(\"name\", \"zhangsan\");\n        update.set(\"age\", 99);\n        UpdateResult result = mongoTemplate.upsert(query, update, User.class);//改一条\n        //UpdateResult result = mongoTemplate.updateMulti(query, update, User.class);//改多条\n        long count = result.getModifiedCount();\n        System.out.println(count);\n    }\n\n    //删除\n    @Test\n    public void testRemove() {\n        Criteria criteria = Criteria.where(\"_id\").is(\"64eeeae31711344f35635788\");\n        Query query = new Query(criteria);\n        DeleteResult result = mongoTemplate.remove(query, User.class);\n        long count = result.getDeletedCount();\n        System.out.println(count);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["project"]},{"title":"分布式事物锁","url":"/2025/06/07/articles/Substitute driver/分布式事物锁/","content":"# 分布式锁解决司机抢单\n\n因为上面写的司机抢单并没有考虑并发，类似于电商的超卖问题\n\n**解决方案\n\n- **第一种 设置数据库事务的隔离级别**，设置为Serializable，效率低下\n\n- **第二种 使用乐观锁解决**，通过版本号进行控制\n\n- **第三种  加锁解决**，学习过synchronized 及lock锁，本地锁，目前微服务架构，分布式部署方式。\n\n## 本地锁的局限性\n\n- 我们使用锁一般都是，synchronized 及lock锁，这些都是本地锁，只在当前jvm生效，在微服务里面就是只有当个微服务生效\n- 举例演示\nTestController\n```java\n@Tag(name = \"测试接口\")  \n@RestController  \n@RequestMapping(\"/order/test\")  \npublic class TestController {  \n  \n    @Autowired  \n    private TestService testService;  \n  \n    @GetMapping(\"testLock\")  \n    public Result testLock() {  \n        testService.testLock();  \n        return Result.ok();  \n    }  \n}\n```\n\nTestServiceImpl\n```java\n@Service  \npublic class TestServiceImpl implements TestService{  \n  \n    @Autowired  \n    private StringRedisTemplate redisTemplate;  \n  \n    @Override  \n    public synchronized void testLock() {  \n        //从redis里面获取数据  \n        String value = redisTemplate.opsForValue().get(\"num\");  \n  \n        if(StringUtils.isBlank(value)) {  \n            return;  \n        }  \n  \n        //把从redis获取数据+1  \n        int num = Integer.parseInt(value);  \n  \n        //数据+1之后放回到redis里面  \n        redisTemplate.opsForValue().set(\"num\",String.valueOf(++num));  \n    }  \n}\n```\n\n- 测试，模拟200个请求并发过程\n\n- 在redis添加初始值，num = 0\n\n使用测试工具 `jmeter` 实现功能测试\n\n![[Pasted image 20250605203137.png]]\n![[Pasted image 20250605203153.png]]\n\n加上锁 synchronized 后是没有问题\n\n- 上面的测试方式是在一个服务内进行的，单机测试，但是如果部署到集群下这个锁不一定会生效\n\n## 实现分布式锁-redis\n\n设置过期时间，到时间之后自动释放锁\n```java\n@Override\npublic void testLock() {\n\t//从redis里面获取数据\n\t//1 获取当前锁  setnx\n\tBoolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(\"lock\", \"lock\");\n\n\t//2 如果获取到锁，从redis获取数据 数据+1 放回redis里面\n\tif(ifAbsent) {\n\t\t//获取锁成功，执行业务代码\n\t\t//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0\n\t\tString value = redisTemplate.opsForValue().get(\"num\");\n\t\t//2.如果值为空则非法直接返回即可\n\t\tif (StringUtils.isBlank(value)) {\n\t\t\treturn;\n\t\t}\n\t\t//3.对num值进行自增加一\n\t\tint num = Integer.parseInt(value);\n\t\tredisTemplate.opsForValue().set(\"num\", String.valueOf(++num));\n\n\t\t//3 释放锁\n\t\tredisTemplate.delete(\"lock\");\n\t} else {\n\t\ttry {\n\t\t\tThread.sleep(100);\n\t\t\tthis.testLock();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n问题：如果锁的删除时间小于事物的执行时间\n例如：\n- 场景：如果业务逻辑执行的时间是7s\n- index1业务逻辑没执行完，3秒后释放\n- index2获取到锁，执行业务逻辑，3秒后锁会被自动释放\n- index3获取到锁，执行业务逻辑\n- index1业务逻辑完成，开始调用del释放锁，这是释放的是index3的锁，导致index3的业务只执行1s就被别人释放\n\n修改后的代码\n```java\n//uuid防止误删\n@Override\npublic void testLock() {\n    //从redis里面获取数据\n    String uuid = UUID.randomUUID().toString();\n    //1 获取当前锁  setnx  + 设置过期时间\n    //        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(\"lock\", \"lock\");\n    Boolean ifAbsent =\n            redisTemplate.opsForValue()\n                    .setIfAbsent(\"lock\", uuid,10, TimeUnit.SECONDS);\n\n    //2 如果获取到锁，从redis获取数据 数据+1 放回redis里面\n    if(ifAbsent) {\n        //获取锁成功，执行业务代码\n        //1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0\n        String value = redisTemplate.opsForValue().get(\"num\");\n        //2.如果值为空则非法直接返回即可\n        if (StringUtils.isBlank(value)) {\n            return;\n        }\n        //3.对num值进行自增加一\n        int num = Integer.parseInt(value);\n        redisTemplate.opsForValue().set(\"num\", String.valueOf(++num));\n        //出现异常\n\n        //3 释放锁\n        String redisUuid = redisTemplate.opsForValue().get(\"lock\");\n        if(uuid.equals(redisUuid)) {\n            redisTemplate.delete(\"lock\");\n        }\n       \n    } else {\n        try {\n            Thread.sleep(100);\n            this.testLock();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 通过LUA脚本保证原子性\n\n通过uuid防止误删，但是还是有问题，不具备原子性\n\n```java\n@Override\npublic void testLock() {\n\t//从redis里面获取数据\n\tString uuid = UUID.randomUUID().toString();\n\t//1 获取当前锁  setnx  + 设置过期时间\n\t//        Boolean ifAbsent = redisTemplate.opsForValue().setIfAbsent(\"lock\", \"lock\");\n\tBoolean ifAbsent =\n\t\t\tredisTemplate.opsForValue()\n\t\t\t\t\t.setIfAbsent(\"lock\", uuid,3, TimeUnit.SECONDS);\n\n\t//2 如果获取到锁，从redis获取数据 数据+1 放回redis里面\n\tif(ifAbsent) {\n\t\t//获取锁成功，执行业务代码\n\t\t//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0\n\t\tString value = redisTemplate.opsForValue().get(\"num\");\n\t\t//2.如果值为空则非法直接返回即可\n\t\tif (StringUtils.isBlank(value)) {\n\t\t\treturn;\n\t\t}\n\t\t//3.对num值进行自增加一\n\t\tint num = Integer.parseInt(value);\n\t\tredisTemplate.opsForValue().set(\"num\", String.valueOf(++num));\n\t\t//出现异常\n\n\t\t//3 释放锁 lua脚本实现\n\t\tDefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n\t\t// lua脚本\n\t\tString script = \"if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1]\\n\" +\n\t\t\t\t\"then\\n\" +\n\t\t\t\t\"    return redis.call(\\\"del\\\",KEYS[1])\\n\" +\n\t\t\t\t\"else\\n\" +\n\t\t\t\t\"    return 0\\n\" +\n\t\t\t\t\"end\";\n\t\tredisScript.setScriptText(script);\n\t\t// 设置返回结果\n\t\tredisScript.setResultType(Long.class);\n\t\tredisTemplate.execute(redisScript, Arrays.asList(\"lock\"), uuid);\n\t} else {\n\t\ttry {\n\t\t\tThread.sleep(100);\n\t\t\tthis.testLock();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n### 总结\n\n1、加锁\n\n```java\n// 1. 从Redis中获取锁,set k1 v1 px 20000 nx\nString uuid = UUID.randomUUID().toString();\nBoolean lock = this.redisTemplate.opsForValue()\n      .setIfAbsent(\"lock\", uuid, 2, TimeUnit.SECONDS);\n```\n\n \n\n2、使用lua释放锁\n\n```java\n// 2. 释放锁 del\nString script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n// 设置lua脚本返回的数据类型\nDefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n// 设置lua脚本返回类型为Long\nredisScript.setResultType(Long.class);\nredisScript.setScriptText(script);\nredisTemplate.execute(redisScript, Arrays.asList(\"lock\"),uuid);\n```\n\n \n\n3、重试\n\n```java\nThread.sleep(500); \ntestLock();\n```\n\n为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：\n\n**第一个：互斥性**，在任何时刻，只有一个客户端能持有锁。\n\n**第二个：不会发生死锁**，即使有一个客户端在获取锁操作时候崩溃了，也能保证其他客户端能获取到锁。\n\n**第三个：解铃还须系铃人**，解锁加锁必须同一个客户端操作。\n\n**第四个：加锁和解锁必须具备原子性**\n\n\n## 实现分布式锁-Redisson\n\n### 准备工作\n\n#### **引入依赖**\n\n在common里service-utils引入依赖\n\n```xml\n<dependency>  \n    <groupId>org.redisson</groupId>  \n    <artifactId>redisson</artifactId>  \n</dependency>\n```\n\n#### **创建Redisson配置类**\n\n```java\n@Data  \n@Configuration  \n@ConfigurationProperties(prefix = \"spring.data.redis\")  \npublic class RedissonConfig {  \n  \n    private String host;  \n  \n    private String password;  \n  \n    private String port;  \n  \n    private int timeout = 3000;  \n    private static String ADDRESS_PREFIX = \"redis://\";  \n  \n    @Bean  \n    RedissonClient redissonSingle() {  \n        Config config = new Config();  \n  \n        if(!StringUtils.hasText(host)){  \n            throw new RuntimeException(\"host is  empty\");  \n        }  \n        SingleServerConfig serverConfig = config.useSingleServer()  \n                .setAddress(ADDRESS_PREFIX + this.host + \":\" + port)  \n                .setTimeout(this.timeout);  \n        if(StringUtils.hasText(this.password)) {  \n            serverConfig.setPassword(this.password);  \n        }  \n        return Redisson.create(config);  \n    }  \n}\n```\n\n\n#### **在业务方法编写加锁和解锁**\n\n```java\n// Redisson实现  \n@Override  \npublic void testLock() {  \n\n\t// 通过redisson创建锁对象  \n\tRLock lock = redissonClient.getLock(\"lock1\");  \n\n\t// 尝试获取锁  \n\t// 阻塞一直等待直到获取到，获取锁之后设置锁的超时时间为10秒，没有参数默认是30秒  \n\tlock.lock(10, TimeUnit.SECONDS);  \n\n\t// tryLock，设置等待时间为30秒，超时时间为10秒  \n//        try {  \n//            boolean b = lock.tryLock(30, 10, TimeUnit.SECONDS);  \n//        } catch (InterruptedException e) {  \n//            throw new RuntimeException(e);  \n//        }  \n\n\t//编写业务代码  \n\t//1.先从redis中通过key num获取值  key提前手动设置 num 初始值：0  \n\tString value = redisTemplate.opsForValue().get(\"num\");  \n\t//2.如果值为空则非法直接返回即可  \n\tif (StringUtils.isBlank(value)) {  \n\t\treturn;  \n\t}  \n\t//3.对num值进行自增加一  \n\tint num = Integer.parseInt(value);  \n\tredisTemplate.opsForValue().set(\"num\", String.valueOf(++num));  \n\n\t//释放锁  \n\tlock.unlock();  \n}\n```\n\n### 看门狗原理\n\n只要线程加锁成功，就会启动一个`watch dog`看门狗，它是一个后台进程，每隔十秒检查一下，如果线程还持有锁，那么就会不断延长锁`key`的生存时间，因此可以解决锁过期释放，业务还没完成的问题\n- 若使用 `tryLock()` 方法并指定了租约时间，则不会启动看门狗\n- 如果我们未指定超时时间，就会使用 `lockwatchdogTimeout = 30 * 1000`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["project"]},{"title":"快速上手xxl-job","url":"/2025/05/31/articles/Substitute driver/快速上手xxl-job/","content":"## XXL-JOB入门案例\n\n### 第一步\n\n下载XXL-JOB示例代码，解压，使用idea打开\n\n**项目组成：\n- admin：调度中心\n- core：公共依赖\n- sample\n\t- sample-frameless：不带框架的\n\t- sample-springboot：带springboot框架的\n\n\n### 第二步\n\n**创建XXL-JOB使用数据库和相关表**\n\n在示例代码文件里面doc文件夹下的db里面有相关的sql语句，直接拉到数据库即可\n\n代码如下\n```mysql\n#  \n# XXL-JOB v2.3.0  \n# Copyright (c) 2015-present, xuxueli.  \n  \nCREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci;  \nuse `xxl_job`;  \n  \nSET NAMES utf8mb4;  \n  \nCREATE TABLE `xxl_job_info` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',  \n  `job_desc` varchar(255) NOT NULL,  \n  `add_time` datetime DEFAULT NULL,  \n  `update_time` datetime DEFAULT NULL,  \n  `author` varchar(64) DEFAULT NULL COMMENT '作者',  \n  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',  \n  `schedule_type` varchar(50) NOT NULL DEFAULT 'NONE' COMMENT '调度类型',  \n  `schedule_conf` varchar(128) DEFAULT NULL COMMENT '调度配置，值含义取决于调度类型',  \n  `misfire_strategy` varchar(50) NOT NULL DEFAULT 'DO_NOTHING' COMMENT '调度过期策略',  \n  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',  \n  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',  \n  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',  \n  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',  \n  `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',  \n  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',  \n  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',  \n  `glue_source` mediumtext COMMENT 'GLUE源代码',  \n  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',  \n  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',  \n  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',  \n  `trigger_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',  \n  `trigger_last_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '上次调度时间',  \n  `trigger_next_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '下次调度时间',  \n  PRIMARY KEY (`id`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_log` (  \n  `id` bigint(20) NOT NULL AUTO_INCREMENT,  \n  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',  \n  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',  \n  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',  \n  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',  \n  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',  \n  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',  \n  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',  \n  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',  \n  `trigger_code` int(11) NOT NULL COMMENT '调度-结果',  \n  `trigger_msg` text COMMENT '调度-日志',  \n  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',  \n  `handle_code` int(11) NOT NULL COMMENT '执行-状态',  \n  `handle_msg` text COMMENT '执行-日志',  \n  `alarm_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',  \n  PRIMARY KEY (`id`),  \n  KEY `I_trigger_time` (`trigger_time`),  \n  KEY `I_handle_code` (`handle_code`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_log_report` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',  \n  `running_count` int(11) NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',  \n  `suc_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',  \n  `fail_count` int(11) NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',  \n  `update_time` datetime DEFAULT NULL,  \n  PRIMARY KEY (`id`),  \n  UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_logglue` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',  \n  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',  \n  `glue_source` mediumtext COMMENT 'GLUE源代码',  \n  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',  \n  `add_time` datetime DEFAULT NULL,  \n  `update_time` datetime DEFAULT NULL,  \n  PRIMARY KEY (`id`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_registry` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `registry_group` varchar(50) NOT NULL,  \n  `registry_key` varchar(255) NOT NULL,  \n  `registry_value` varchar(255) NOT NULL,  \n  `update_time` datetime DEFAULT NULL,  \n  PRIMARY KEY (`id`),  \n  KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_group` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',  \n  `title` varchar(12) NOT NULL COMMENT '执行器名称',  \n  `address_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',  \n  `address_list` text COMMENT '执行器地址列表，多地址逗号分隔',  \n  `update_time` datetime DEFAULT NULL,  \n  PRIMARY KEY (`id`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_user` (  \n  `id` int(11) NOT NULL AUTO_INCREMENT,  \n  `username` varchar(50) NOT NULL COMMENT '账号',  \n  `password` varchar(50) NOT NULL COMMENT '密码',  \n  `role` tinyint(4) NOT NULL COMMENT '角色：0-普通用户、1-管理员',  \n  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',  \n  PRIMARY KEY (`id`),  \n  UNIQUE KEY `i_username` (`username`) USING BTREE  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nCREATE TABLE `xxl_job_lock` (  \n  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',  \n  PRIMARY KEY (`lock_name`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;  \n  \nINSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, 'xxl-job-executor-sample', '示例执行器', 0, NULL, '2018-11-03 22:21:31' );  \nINSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, '测试任务1', '2018-11-03 22:21:31', '2018-11-03 22:21:31', 'XXL', '', 'CRON', '0 0 0 * * ? *', 'DO_NOTHING', 'FIRST', 'demoJobHandler', '', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2018-11-03 22:21:31', '');  \nINSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);  \nINSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( 'schedule_lock');  \n  \ncommit;\n```\n\n### 第三步\n\n**部署调度中心**\n\n* 修改xxl-job-admin项目里面配置文件\n\n主要修改数据库\n```properties\n### xxl-job, datasource\nspring.datasource.url=jdbc:mysql://localhost:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n* 启动调度中心\n\n* 通过路径访问：http://localhost:8080/xxl-job-admin\n\n* 默认用户名和密码： admin/123456\n\n### 第四步\n\n**部署执行器项目**\n\n- 导入依赖\n\n- 修改配置文件，把执行器项目放在调度中心进行注册\n\n- 创建配置类，获取任务调用过程中需要使用的参数\n```java\npackage com.xxl.job.executor.core.config;\n\nimport com.xxl.job.core.executor.impl.XxlJobSpringExecutor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * xxl-job config\n *\n * @author xuxueli 2017-04-28\n */\n@Configuration\npublic class XxlJobConfig {\n    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);\n\n    @Value(\"${xxl.job.admin.addresses}\")\n    private String adminAddresses;\n\n    @Value(\"${xxl.job.accessToken}\")\n    private String accessToken;\n\n    @Value(\"${xxl.job.executor.appname}\")\n    private String appname;\n\n    @Value(\"${xxl.job.executor.address}\")\n    private String address;\n\n    @Value(\"${xxl.job.executor.ip}\")\n    private String ip;\n\n    @Value(\"${xxl.job.executor.port}\")\n    private int port;\n\n    @Value(\"${xxl.job.executor.logpath}\")\n    private String logPath;\n\n    @Value(\"${xxl.job.executor.logretentiondays}\")\n    private int logRetentionDays;\n\n\n    @Bean\n    public XxlJobSpringExecutor xxlJobExecutor() {\n        logger.info(\">>>>>>>>>>> xxl-job config init.\");\n        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();\n        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);\n        xxlJobSpringExecutor.setAppname(appname);\n        xxlJobSpringExecutor.setAddress(address);\n        xxlJobSpringExecutor.setIp(ip);\n        xxlJobSpringExecutor.setPort(port);\n        xxlJobSpringExecutor.setAccessToken(accessToken);\n        xxlJobSpringExecutor.setLogPath(logPath);\n        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);\n\n        return xxlJobSpringExecutor;\n    }\n\n\n}\n```\n\n* 启动执行器项目\n\n* 注册到调度中心里面\n\n\n### 第五步\n\n**开发执行器项目job方法**\n\n```java\n@Component\npublic class SampleXxlJob {\n    private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class);\n\n\n    /**\n     * 1、简单任务示例（Bean模式）\n     */\n    @XxlJob(\"demoJobHandler\")\n    public void demoJobHandler() throws Exception {\n        XxlJobHelper.log(\"XXL-JOB, Hello World.\");\n\n        for (int i = 0; i < 5; i++) {\n            XxlJobHelper.log(\"beat at:\" + i);\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName()+\"atguigu....\");\n        }\n        // default success\n    }\n}\n```\n\n### 第六步\n\n**创建任务并启动任务**\n\n通过图形化界面进行操作\n新增任务\n![[Pasted image 20250531154302.png]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["project"]},{"title":"什么是循环依赖","url":"/2025/05/27/articles/每日一篇/什么是循环依赖/","content":"## 什么是循环依赖\n\n现在我们有两个类 ClassA 与 ClassB，但他们互相引用，直接或间接依赖对方，例如例如A类里有B的对象，B类中又有A的对象\n```java\npublic class ClassA {\n    private ClassB classB;\n    // 构造方法、getter 和 setter 等\n}\n\npublic class ClassB {\n    private ClassA classA;\n    // 构造方法、getter 和 setter 等\n}```\n\n这种依赖不仅限于出现在类上，也可能会出现在包上或者模块上\n\n- **出现在包层面的危害：\n\t- 增加了代码的耦合度，降低了代码的可维护性和可读性\n\t- 在编译时可能会出现编译顺序的问题，难以确定先编译哪个包。\n\t- 在后续的开发和维护过程中，增加了维护的难度和风险。\n\n- **出现在模块层面的危害：\n\t- 会导致模块之间的边界变得模糊，无法清晰地划分模块的职责。在构建和部署项目时，可能会出现循环加载的问题，影响项目的启动效率和运行性能。\n\n## Spring中的循环依赖\n\n当两个或多个 Bean 之间存在构造器注入的循环依赖时，Spring 无法解决这种依赖关系。例如，`BeanA` 的构造器需要 `BeanB`，而 `BeanB` 的构造器又需要 `BeanA`。Spring 容器在创建这些 Bean 的过程中会陷入死循环，无法确定先创建哪个 Bean，从而抛出 `BeanCurrentlyInCreationException` 或 `BeanCurrentlyInCreationException` 等异常。\n\n解决方法：\n- Spring 通过单例 Bean 的提前暴露机制来解决基于 Setter 注入的循环依赖问题\n- **创建 BeanA 的壳对象并存入三级缓存** ：当创建 `BeanA` 时，Spring 会先创建一个 `BeanA` 的壳对象（即一个未完全初始化的实例，只是构造函数执行完成，属性还没有填充），并将其存入三级缓存（`SingletonObjects`、`earlySingletonObjects` 和 `singletonFactories` 组成的缓存体系）中的 `singletonFactories`。\n    \n- **创建 BeanB 并注入依赖** ：接着创建 `BeanB`，在创建 `BeanB` 的过程中，发现 `BeanB` 依赖 `BeanA`，此时 Spring 会尝试从缓存中获取 `BeanA`。虽然 `BeanA` 还没有完全初始化（只是壳对象在 `singletonFactories` 中），但 Spring 会将其从 `singletonFactories` 中取出，放入 `earlySingletonObjects` 中，并将其作为依赖注入到 `BeanB` 中。\n    \n- **完成 BeanA 的初始化并注入到 BeanB** ：`BeanA` 的壳对象被注入到 `BeanB` 后，Spring 会继续完成 `BeanA` 的初始化（填充属性等操作）。当 `BeanA` 初始化完成后，会将它放入 `SingletonObjects` 中。在后续的操作中，如果 `BeanB` 还需要访问 `BeanA`，可以直接从 `SingletonObjects` 中获取已经完全初始化的 `BeanA`。\n\n## 三级缓存\n\n### 一级缓存（`singletonObjects`）\n\n一级缓存也被称为单例池，存储的是已经完全初始化好的单例 Bean 实例。当需要获取一个单例 Bean 时，Spring 会优先从这个缓存中查找，其数据结构为 `Map<String, Object>`，键是 Bean 的名称，值是对应的 Bean 实例。\n\n### 二级缓存（`singletonFactories`）\n\n当 Bean 实例化完成，但还未完成属性注入和初始化时，会将一个创建该 Bean 代理对象的工厂存入二级缓存。其数据结构为 `Map<String, ObjectFactory<?>>`，键为 Bean 的名称，值是用于创建 Bean 的工厂对象。如果从一级缓存中未找到所需的 Bean，Spring 会尝试从二级缓存中获取对应的工厂对象，并通过该工厂创建 Bean 的早期暴露实例。\n\n### 三级缓存（`earlySingletonObjects`）\n\n三级缓存存储的是提前暴露的单例 Bean 实例，这些 Bean 虽然还未完成全部的初始化流程，但已经可以被引用。通过这个缓存，其他 Bean 在依赖该 Bean 时可以获取到一个早期的实例。其数据结构为 `Map<String, Object>`，键是 Bean 的名称，值是早期暴露的 Bean 实例。如果从二级缓存中获取到工厂对象后，会使用该工厂生成一个早期的 Bean 实例，并将其存入三级缓存中，以便其他 Bean 可以引用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["面试八股文"]},{"title":"什么是消息队列（Kafka）","url":"/2025/05/26/articles/每日一篇/什么是消息队列（Kafka）/","content":"\n### 模拟场景\n\n假如现在我需要维护两个服务A和B，B服务每秒能处理100个消息，但A服务每秒能发两百个消息\n\n结果我们也能想到，B服务非常容器就爆炸了，聪明的我一定能想到，我在B里面加一个队列来存放A发来的消息，用offset偏移量来记录消息的位置，B服务看能力来处理消息，不断更新offset值\n\n但这又产生了一个新问题，来不及处理的消息放在内存里，如果在服务B里面的消息没有处理完的情况下B服务关机或者重启了，里面的消息就全部丢失了，但聪明的我肯定还会想到，那我们把队列拉出来单独开一个进程不就行了嘛\n\n这就是消息队列的来源，像A服务一样发数据到队列里就是生产者，B服务这样处理数据的就是消费者\n\n### 优化\n\n- **高性能**\n\t简单来说就是软件不行加硬件，消费者太慢了就加消费者，生产者慢就加生产者，但这听着感觉还是不对，如果多个生产者和消费者同时争抢同一个消息队列，抢不到就等怎么办\n\t\n\t解决方法：\n\t\t对消息进行分类，每一类是一个topic，按照topic数量，生产者将消息分发给不同的消息队列里面，一个消费者需要订阅不同的队列来获取消息，但这样还是会出现一个topic里消息还是很多，我们还可以把单个topic拆成多个partition分区，每个消费者负责一个partition分区\n\n- **高扩展**\n\t\n\t随着partition变多，如果partition都在同一台机器上可能会导致单机CPU内存负载过高，影响系统整体效率\n\t\n\t解决方法：\n\t\t将partition分散部署到多台机器上，每一台机器就是一个broker，我们可以通过增加broker来缓解机器CPU负载过高带来的性能问题\n\n- **高可用**\n\t\n\t如果其中一个broker挂了，那里面所有partition的消息也会跟着消失\n\t\n\t解决方法：\n\t\t给partition多加几个副本，统称为replicas，将他们分为leader和follower，leader负责应对生产者和消费者的读写请求，follower负责同步leader的消息，将leader和follower分散到不同的broker里，这样就算leader所在的broker挂了也不会影响到follower所在的broker，并且还能重新选举一个leader partition顶上\n\n- **持久化和过期策略**\n\t\n\t假设全部broker都挂了，那所以的partition的消息不都丢失了吗\n\t\n\t解决方法：\n\t\t所以我们不能光将数据放在内存里，还需要持久化到磁盘上，但问题又来了，磁盘是有限的，一直往里面写数据迟早得炸，所以还需要给数据加上保留策略retention policy，比如磁盘数据超过一定大小或者数据放置超过一定时间就会被清理掉\n\n- **消费者组consumer group**\n\t\n\t按现在的消费方式，每次新增的消费者只能跟着最新的offset接着消费，如何让新增的消费者从指定的offset开始消费呢\n\t\n\t解决方法：\n\t\t引入消费者组概念，不同消费者组维护自己的消费进度，互不打扰\n\n- **ZooKeeper**\n\t\n\t就目前来看，组件太多了，而且每个组件都有自己的数据和状态，因此需要有一个组件去统一维护这些组件的状态，于是引入了ZooKeeper组件\n\t\n\tZooKeeper会定期和broker通信，获取整个Kafka集群的状态，以此判断某些broker是不是挂了，某些消费者消费到哪了\n\n### 应用场景\n\n- 流量削峰填谷\n- 异构同步（不同类型、不同厂商的数据库系统之间进行数据同步）\n- 日志处理与分析\n- 系统监控与报警等\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["面试八股文"]},{"title":"redis主从复制的理解","url":"/2025/05/22/articles/每日一篇/redis主从复制的理解/","content":"主从复制本质上就是从一台服务器master上的数据拷贝到另一台服务器slave上，**数据的复制是单向的，只能由主节点到从节点**，redis里提供了全量复制和增量复制两种方法：\n\n- 全量复制：一般用于slave新构建的时候，slave会向master发送全量复制请求，然后master会拷贝当前数据快照给slave，slave丢弃旧的数据来加载新的数据，但需要注意**redis并没有采用强一致性，所以会出现数据同步延迟导致数据不一致问题**\n\n- 增量复制：当master节点收到数据改动，master会把变更的数据同步给所有的slave节点，主要原理是master和slave会共同维护一个偏移量offset，用来表示master向slave传递的字节数量，每一次进行增量数据的传递，offset都会对应增加数量\n\n主从连接后master 接收命令，判断runid是否匹配，判定offset是否在复制缓冲区中，runid和offset有一个不满足，执行全量复制\n\n\n**心跳机制**：进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现**双方连接保持在线**\n- master会去`ping slave`，默认每十秒一次，来获取slave最后一次连接时间间隔，一般在0或1为正常\n- slave会用`REPLCONF ACK {offset}`，每一秒一次，汇报slave自己的复制偏移量，获取最新的数据变更指令以及判断master是否在线","tags":["面试八股文"]},{"title":"ArrayList 和 LinkedList 的区别","url":"/2025/05/21/articles/每日一篇/ArrayList 和 LinkedList 的区别/","content":"- ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。\n\n- 对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。\n\n- 新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。\n\n- LinkedList集合不支持 高效的随机随机访问（RandomAccess）\n\n- ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间","tags":["面试八股文"]},{"title":"Kafka如何避免重复消费问题","url":"/2025/05/20/articles/每日一篇/Kafka如何避免重复消费问题/","content":"\n首先，kafka的块上会储存offset标记，kafka消费者通过offset标记来维护已经消费的数据，消费者每消费完一批数据时会更新offset值，来避免重复消费问题。\n\n默认情况，消费完以后会自动提交offset值避免重复消费，Kafka消费端自动提交的逻辑中默认了5秒的间隔，所以在consumer的消费过程中，如果5秒内被强行kill了或者宕机导致offset没有提交，会导致重复消费问题。\n\n在Kafka里有一种叫Partition Balance机制，就是把多个消费区都负载均衡给consumer消费者，如果消费者在默认的五分钟内没有处理完里面的消费，就会触发ReBalance机制导致offset提交失败，在重启ReBalance后，消费端还是会从之前没有提交offset的位置开始去消费，从而导致重复消费问题，如何去解决也有很多方法：\n1. 提高消费端的处理性能，避免触发Balance，例如：\n\t1. 比如采用异步的方法来处理消息，缩短单个信息消费的时长\n\t2. 调整消费处理的超时时间\n\t3. 减少一次性从区中获取数据的条数\n2. 针对信息生产md5然后保存在MySQL或者redis里，在处理消息前先去MySQL或者redis里判断是否消费过","tags":["面试八股文"]},{"title":"什么是SpringMVC","url":"/2025/05/19/articles/每日一篇/什么是SpringMVC/","content":"SpringMVC 是属于Spring Framework生态里面的一个模块，是在servlet的基础上构建并且使用了MVC模式涉及的web框架，目的是为了去简化传统的servlet+JSP模式下的web开发方式。\n其次Spring MVC的架构设计是对Javaweb里面的mvc框架模式做了一些增强和扩展，主要体现在几个方面 ：\n1. 把传统MVC框架里面的Controller控制器做了拆分，分为了前端控制器DispatcherServlet和后端控制器Controller\n2. 把model模型拆分成业务层service和数据访问层Repository\n3. 在视图层，可以支持不同的视图，比如Freemark、velocity、JSP等\n\n所以，SpringMVC就是为了MVC模式设计的，因此在开发MVC应用时会更加方便灵活\n\nSpringMVC整体工作流程：\n1. 浏览器请求首先经过核心控制器DispatherServlet，把请求分发到对应的Controller里面\n2. 然后等Controller调用业务逻辑进行处理完后返回Model And View\n3. DispatcherServlet去寻找一个或多个ViewResolver视图解析器，找到Model And View指定的视图并且把数据展示到客户端","tags":["面试八股文"]},{"title":"JVM垃圾回收器","url":"/2025/05/13/articles/每日一篇/JVM垃圾回收器/","content":"**Java分配对象的过程以及新生代和老年代划分的目的\n\n创建一个新的对象实例时，jvm首先会在堆内存分配内存空间，大部分情况下，新对象都会分配到新生代的Eden区，新生代有三个区，一个Eden区和两个survivor区，当Eden区满了以后会进行Minor GC（新生代GC，是指新生代的垃圾收集，一般Eden区满了就执行，非常频繁，回收速度快），在GC的过程中存活的对象会在两个survivor区中进行转移和交换，经过多次GC任然存活的对象会被放入老年代，老年代主要用于存储长期存活的对象或者是大对象。\n\n新生代中如果有比较大的对象比如数组list那些，会直接放入老年代里面。\n\n划分新生代和老年代的主要目的有两个：\n- 新生代采用的是一种简单高效的复制算法进行垃圾回收，可以快速完成垃圾回收减少暂停时间，因为大部分对象都是暂时存在的，所有这种策略能够有效处理大量短暂对象的分配和回收\n- 可以针对不同的对象采取不同的回收策略，新生代频繁回收，老年代较少回收，可以减少full GC（全面垃圾收集，清理新生代与老年代以及方法区，full GC通常比Minor GC慢很多，因为full GC涉及到整个栈的回收，并且在GC期间，应用程序的所有线程都会暂停）的频率，提升系统的整体性能\n\n\n**标记清除、复制和标记压缩三种垃圾回收算法的基本原理\n\n**标记清除算法：**\n遍历所有可达对象标记为存活的状态，然后遍历堆内存，把没有标记的对象全部视为垃圾进行清理\n\n- 优点\n\t简单，不需要额外的内存空间\n- 缺点\n\t会产生大量的内存碎片，而且效率很低\n\n**复制算法：**\n把内存分为两个相等的区域，每次只使用其中一个区域，当这个区域满了以后，把存活的对象复制到另一个区域中并且清除原区域的所有对象\n\n- 优点\n\t每次垃圾回收后内存都是连续的，不存在内存碎片\n- 缺点\n\t需要额外的占用内存空间，并且对象频繁复制导致效率问题\n\n**标记压缩算法：**\n先标记所有可达对象，然后把存活的对象向一端移动，然后直接清理边界外的内存区域，从而消除碎片\n![[Pasted image 20250513172753.png]]\n\n- 优点\n\t解决标记清除算法所造成的内存碎片问题，相对复制算法减少了内存空间占用\n- 缺点\n\t复杂度高，而且执行效率相对比较低，特别是压缩阶段需要移动对象，可能会引起程序暂停的时间较长\n\n\n**serial、Parallel、CMS和G1垃圾回收器的主要特点**\n\n- serial GC是串行垃圾回收器，比较适用于单核处理器或者对响应时间要求不高的场景\n\n- Parallel基于多线程并行垃圾回收器，适合高吞吐量的服务器应用或者CPU核心数较多的服务器坏境\n\n- CMS也是并且垃圾回收，但是他会把垃圾回收分为四个阶段，尽可能减少了STW（系统在执行特定操作时需暂停所有应用程序线程）的时间，比较适用于高交互性的应用，比如web服务器，以及对停顿时间有严格要求但是对吞吐量比较宽松的场景\n\n- G1把堆内存划分了多个大小相等的区域，每个区域都可以独立作为新生代和老年代的一部分，通过并行和并发实现垃圾回收，从而减少停顿时间，另外还能根据目标停顿时间来动态调整垃圾回收策略，来满足不同需求，适合低延迟和可预测的垃圾回收停顿时间的应用，比如大规模分布式系统、在线交易系统\n\n\n\n","tags":["面试八股文"]},{"title":"SpringApplication.run 执行后的四个阶段","url":"/2025/05/12/articles/每日一篇/SpringApplication.run 执行后的四个阶段/","content":"四阶段分别为：服务构建、环境准备、容器创建和填充容器\n\n服务构建\n- 首先把传入的资源加载器、主方法类记录到内存中，然后逐一判断对应的服务类是否存在来确定web服务的类型\n\t- 默认是基于servlet的web服务，如tomcat，还有响应式非阻塞服务reactive，如spring-webflux，还有什么都不是的none\n- 确定完选择哪个web服务后就是加载初始化类了，会去读取META-INF/spring.factories文件中的注册初始化、上下文初始化和监听器这三个配置\n- 最后是通过运行栈stackTrace判断main方法所在类\n\n环境准备\n- 先new一个启动上下文 `bootstrapContext`，然后调用启动注册初始化器中的初始化方法 `initialize`，但由于没有没默认的初始化器，所以也没初始化什么（这个可以靠手动添加）\n- 将 `java.awt.headless` 设置为 true，表示缺少显示器、键盘等输出设备也能正常启动\n- 然后启动运行监听器，同时发布启动事件，获取并加载springboot工程配置文件中监听器，就可以做到通过监听事件在启动的流程中加入自定义逻辑\n- 接下来就是组装启动参数，例如根据不同的web服务构造不同的环境（默认是servlet）、坏境变量、jvm系统属性等，把这些信息加载到一个内存集合中，后续调用就无需重新加载了\n\n容器创建\n- 根据服务类型创建容器（默认servlet）注解配置的servlet-web服务容器\n\t- 存放和生产bean实例的Bean工厂\n\t- 用来解析 `@Component`、`@ComponentScan` 等注解的配置类后处理器\n\t- 用来解析 `@AutoWired`、`@Value`等注解的自动注解bean处理器\n- 对容器中的部分属性进行初始化\n\n填充容器\n- 生产自身提供或者自定义的所有Bean对象，放入容器创建步骤中创建好的容器中，这个过程也叫做自动装配\n- 构造启动web服务器\n- 回调自定义实现的 Runner 接口，来处理执行后定制化的需求","tags":["面试八股文"]},{"title":"SpringBoot启动流程","url":"/2025/05/11/articles/每日一篇/SpringBoot启动流程/","content":"首先需要一个加了 `@SpringBootApplication` 注解的启动类，这个注解本质上就是由 `@EnableAutoConfiguration` 、`@SpringBootConfiguration` 和 `@ComponentScanner` 连起来构成。\n\n- `@EnableAutoConfiguration` 的作用是在启动时自动加载一个类，这个类会将所有符合条件的 `@Configuration` 配置都进行加载，如果启动类中不需要添加配置内容，也不需要扫描路径，可以将 `@SpringBootApplication` 换成 `@EnableAutoConfiguration`\n\n- `@SpringBootConfiguration` 等同于 `@Configuration`，就是将这个类标记为配置类，会被加载到容器中\n\n- `@ComponentScanner` 就是自动扫描并加载所有符合条件的 Bean\n\n注解完成后，运行的起点就是 `SpringApplication.run(类名.class, args)`，在 run 开始执行后会经历四个阶段：服务构建、环境准备、容器创建和填充容器\n\n","tags":["面试八股文"]},{"title":"MySQL事物的原理是什么","url":"/2025/05/10/articles/每日一篇/MySQL事物的原理是什么/","content":"MySQL满足ACID的特性，所以MySQL事物的原理就是innodb是如何去实现ACID的特性。\n\n首先A就是原子性，就是要保证DML数据库操作语言要么都成功，要么都失败，都成功好理解，如果都失败就意味着要把原本执行的操作都回滚，所以innodb里面设计了一个undo log表，在事物执行的过程中把执行数据的快照保存在undo log表里，例如执行一个insert语句，在undo log表里就存储一个delete语句，一旦出现错误就直接读取undo log执行反向操作就行了。\n\n其次就是C一致性，表示数据的约束没有得到破坏，这个更多是依靠业务层的保障，数据库里面也提供了像主键约束，唯一约束，字段长度约束等。\n\nI是隔离性，多个并行事物对同一个数据进行操作如何去避免多个事物的干扰导致数据混乱。innodb里面实现了SQL92的标注，提供了四个隔离级别的实现，分别是未提交读、已提交读、可重复读以及串行化。innodb默认实现的是可重复读，并且使用了MVCC解决了脏读和不可重复读的问题，然后使用了行锁或者表锁的方式来解决幻读的问题。\n\nD是持久性，也就是说事物提交后的数据一定是永久化保留，不能因为数据库宕机或者其他原因导致数据变更的失效。理论上说事物提交后直接放在磁盘保存就好了，但是因为随机磁盘IO的效率确实很低，所以innodb设计了Buffer pool缓冲区来进行优化，数据更新的时候先更新缓冲区，然后在合适的时间持久化到磁盘里。但是在这个过程中可能会因为数据库宕机导致数据丢失，因此innodb引入了redo log文件，这个文件存储了数据库变更后的值，我们通过事物进行数据更改的时候，除了修改内存缓冲区里的数据以外，还会被本次修改的值追加到redo log里面，当事物提交的时候直接把redo log里面的日志刷新到磁盘里面进行持久化，一旦数据库宕机在MySQL重启以后可以直接用redo log里面保存的重写日志读取再执行一遍。\n\n因此认为，MySQL事物的原理就是innodb如何实现ACID的特性，用到了MVCC、行锁、表锁、缓冲区、redo log和undo log来实现。\n","tags":["面试八股文"]},{"title":"Redis常见的几个问题","url":"/2025/05/08/articles/Substitute driver/Redis常见的几个问题/","content":"# 缓存雪崩\n\n当大量缓存在同一时间失效或者过期，亦或者Redis故障宕机时，如果此时有大量用户数据访问，Redis 无法处理，于是全部请求都会直接访问数据库，导致数据库压力剧增，严重会导致数据库宕机，从而出现更严重的问题\n\n常见解决方法：\n- 给各数据设置不相同的过期时间，尽量让他们不要在同一时间过期\n- 设置互斥锁，当发现需要查找的数据在Redis中找不到，就加上一个互斥锁，保证一个时间只有规定的次数查询数据库来构建缓存\n- 如果是宕机，那我们可以用熔断来解决，或者是拒绝服务\n\n# 缓存击穿\n\n缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩其中之一\n\n如果缓存中某个热点数据过期了，此时大量的数据请求访问了该数据，就无法从缓存中读取，直接访问数据库，数据库很容易被高并发的请求冲垮，这就是缓存击穿问题。\n\n常见解决方法：\n- 互斥锁方案，保证同一时间只有一个业务线程更新缓存\n- 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；\n\n# 缓存穿透\n\n当用户访问的数据不存在，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，那么此时大量的请求都落在数据库中，导致数据库压力骤增\n\n常见解决方法\n- 限制非法请求，进行参数校验，对于不合法的参数请求直接抛出异常返回给客户端。\n- 缓存空值或者默认值，当发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，使其不会继续查询数据库\n- 使用布隆过滤器，过滤器说数据不存在，那么数据库中一定不会有这个数据。如果说数据存在，并不一定证明数据库中存在这个数据，有误判的几率，只不过几率非常小。（底层是hash，有极小概率误判）","tags":["project"]},{"title":"莫名其妙的报错","url":"/2025/05/03/articles/Substitute driver/莫名其妙的报错/","content":"\n太吓人了可恶，今天写完运行的时候报了两个错\n```\nD:\\Desktop\\hhsqdmz\\Project\\Substitute driver\\代码\\daijia-parent\\service-client\\service-map-client\\src\\main\\java\\com\\atguigu\\daijia\\map\\client\\MapFeignClient.java:19:5\njava: 找不到符号\n  符号:   类 Result\n  位置: 接口 com.atguigu.daijia.map.client.MapFeignClient\n\nD:\\Desktop\\hhsqdmz\\Project\\Substitute driver\\代码\\daijia-parent\\service-client\\service-map-client\\src\\main\\java\\com\\atguigu\\daijia\\map\\client\\MapFeignClient.java:3:40 java: 程序包com.atguigu.daijia.common.result不存在\n```\n\n然后我按照报错原因按个排插，看了半天没发现问题，最后我使用了最原始的方法：回溯\n\n我按照步骤挨个回退，一路删删删，最后发现问题居然是ALT+Enter，快速的加入了一个依赖在最外层父项目，然后那个依赖本身就存在，两个相同的依赖导致出错，并且报错原因和真实原因毫不相关\n\n气煞我也！","tags":["project"]},{"title":"规则引擎","url":"/2025/04/30/articles/Substitute driver/规则引擎/","content":"\n# 规则引擎概述\n\n- 规则引擎，全称为**业务规则管理系统**，英文名为BRMS\n\n- 就是把业务里经常变动的代码给抽离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策\n\n- 主流产品：drools、VisualRules、iLog\n\n# drools\n\n## 概述\n\ndrools是一款由JBoss组织提供的基于Java语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中(例如存放在数据库中)，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。\n\ndrools官网地址：https://drools.org/\n\ndrools源码下载地址：https://github.com/kiegroup/drools\n\n## 基础使用\n\n### 创建spring boot工程\n### 引入drools依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>drools</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.0.5</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <java.version>17</java.version>\n        <drools.version>8.41.0.Final</drools.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>org.drools</groupId>\n            <artifactId>drools-core</artifactId>\n            <version>${drools.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.drools</groupId>\n            <artifactId>drools-compiler</artifactId>\n            <version>${drools.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.drools</groupId>\n            <artifactId>drools-decisiontables</artifactId>\n            <version>${drools.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.drools</groupId>\n            <artifactId>drools-mvel</artifactId>\n            <version>${drools.version}</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n### 创建drools配置类\n\n```java\n@Configuration\npublic class DroolsConfig {\n\n    private static final KieServices kieServices = KieServices.Factory.get();\n    //制定规则文件的路径\n    private static final String RULES_CUSTOMER_RULES_DRL = \"rules/order.drl\";\n\n    @Bean\n    public KieContainer kieContainer() {\n        //获得Kie容器对象\n        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();\n        kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_CUSTOMER_RULES_DRL));\n\n        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem);\n        kieBuilder.buildAll();\n\n        KieModule kieModule = kieBuilder.getKieModule();\n        KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());\n\n        return kieContainer;\n    }\n}\n```\n- 定义了一个 `KieContainer`的`Bean` ，`KieContainer`用于通过加载应用程序的`/resources`文件夹下的规则文件来构建规则引擎。\n\n- 创建`KieFileSystem`实例并配置规则引擎并从应用程序的资源目录加载规则的 `DRL` 文件。\n\n- 使用`KieBuilder`实例来构建 `drools` 模块。我们可以使用KieSerive单例实例来创建 `KieBuilder` 实例。\n\n- 最后，使用 `KieService` 创建一个 `KieContainer` 并将其配置为 `spring bean`\n\n### 创建实体类\n\n```java\npublic class Order {\n\n    private double amount;\n    private double score;\n\n    public double getAmount() {\n        return amount;\n    }\n\n    public void setAmount(double amount) {\n        this.amount = amount;\n    }\n\n    public double getScore() {\n        return score;\n    }\n\n    public void setScore(double score) {\n        this.score = score;\n    }\n}\n```\n\n### 创建规则文件\n\n```drl\npackage com.hh.order;\nimport com.hh.bean.Order\n\n//规则一：100元以下 不加分\nrule \"order_rule_1\"\n    when\n        $order:Order(amount < 100)\n    then\n        $order.setScore(0);\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n\n//规则二：100元 - 500元 加100分\nrule \"order_rule_2\"\n    when\n        $order:Order(amount >= 100 && amount < 500)\n    then\n         $order.setScore(100);\n         System.out.println(\"成功匹配到规则二：100元 - 500元 加100分\");\nend\n\n//规则三：500元 - 1000元 加500分\nrule \"order_rule_3\"\n    when\n        $order:Order(amount >= 500 && amount < 1000)\n    then\n         $order.setScore(500);\n         System.out.println(\"成功匹配到规则三：500元 - 1000元 加500分\");\nend\n\n//规则四：1000元以上 加1000分\nrule \"order_rule_4\"\n    when\n        $order:Order(amount >= 1000)\n    then\n         $order.setScore(1000);\n         System.out.println(\"成功匹配到规则四：1000元以上 加1000分\");\nend\n```\n\n### 测试\n\n```java\n@SpringBootTest\npublic class DroolsDemosApplicationTests {\n\n    @Autowired\n    private KieContainer kieContainer;\n\n    @Test\n    public void test() {\n        //从Kie容器对象中获取会话对象\n        KieSession session = kieContainer.newKieSession();\n\n        //Fact对象，事实对象\n        Order order = new Order();\n        order.setAmount(1300);\n\n        //将Order对象插入到工作内存中\n        session.insert(order);\n\n        //激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则\n        session.fireAllRules();\n\n        //关闭会话\n        session.dispose();\n\n        System.out.println(\"订单金额：\" + order.getAmount() + \"，添加积分：\" + order.getScore());\n    }\n}\n```\n\n- 使用drools规则引擎主要工作就是编写规则文件，在规则文件中定义跟业务相关的业务规则。规则定义好后就需要调用drools提供的API将数据提供给规则引擎进行规则模式匹配，规则引擎会执行匹配成功的规则并将计算的结果返回\n- 使用规则引擎时业务规则可以做到动态管理，可以做到不重启服务情况下做调整\n\n# 规则引擎构成\n\ndrools规则引擎由以下三部分构成：\n\n- Working Memory（工作内存）\n- Rule Base（规则库）\n- Inference Engine（推理引擎）\n\n其中Inference Engine（推理引擎）又包括：\n\n- Pattern Matcher（匹配器）     // 具体匹配哪一个规则，由这个完成\n- Agenda(议程)\n- Execution Engine（执行引擎）\n\n\n**Working Memory**：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如上面调用kieSession.insert(order)就是将order对象插入到了工作内存中。\n\n**Fact**：事实，是指在drools 规则应用当中，将一个**普通的JavaBean插入到Working Memory后的对象**就是Fact对象，例如本案例中的Order对象就属于Fact对象。\n\n**Rule Base**：规则库，我们在规则文件中定义的规则都会被加载到规则库中。\n\n**Pattern Matcher**：匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda（议程）中。\n\n**Agenda**：议程，用于存放通过匹配器进行模式匹配后被激活的规则。\n\n**Execution Engine**：执行引擎，执行Agenda中被激活的规则。\n\n# Drools 基础语法\n\n## 基础语法\n\n| 关键字      | 描述                               |\n| -------- | -------------------------------- |\n| package  | 包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用 |\n| import   | 用于导入类或者静态方法                      |\n| global   | 全局变量                             |\n| function | 自定义函数                            |\n| query    | 查询                               |\n| rule end | 规则体                              |\nDrools 支持的规则文件除了drl格式，还有Excel文件类型\n\n## 规则体语法\n\n```drl\nrule \"ruleName\"\n    attributes\n    when\n        LHS \n    then\n        RHS\nend\n```\n\n**rule**：关键字，表示规则开始，参数为规则的唯一名称。\n\n**attributes**：规则属性，是rule与when之间的参数，为可选项。\n\n**when**：关键字，后面跟规则的条件部分。\n\n**LHS**(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。**如果LHS为空，则它将被视为始终为true的条件元素**。  （左手边）\n\n**then**：关键字，后面跟规则的结果部分。\n\n**RHS**(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）\n\n**end**：关键字，表示一个规则结束。\n\n## Pattern 模式匹配\n\nDrools中的匹配器可以将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，条件就叫做Pattern\n\n**pattern的语法结构为：绑定变量名:Object(Field约束)**\n\n例如：\n```drl\n//规则一：100元以下 不加分\nrule \"order_rule_1\"\n    when\n        $order:Order(amount < 100)\n    then\n        $order.setScore(0);\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n通过上面的例子可以知道，匹配的条件为：\n\n1、$order对应对象是一个Order这种类型的Fact对象-----类型约束\n\n2、Fact对象的amount属性值必须小于100------属性约束\n\n以上条件必须同时满足当前规则才有可能被激活。\n\n## 比较运算符\n\n| 符号         | 说明                                                         |\n| :----------- | :----------------------------------------------------------- |\n| contains     | 检查一个Fact对象的某个属性值是否包含一个指定的对象值         |\n| not contains | 检查一个Fact对象的某个属性值是否不包含一个指定的对象值       |\n| memberOf     | 判断一个Fact对象的某个属性是否在一个或多个集合中             |\n| not memberOf | 判断一个Fact对象的某个属性是否不在一个或多个集合中           |\n| matches      | 判断一个Fact对象的属性是否与提供的标准的Java正则表达式进行匹配 |\n| not matches  | 判断一个Fact对象的属性是否不与提供的标准的Java正则表达式进行匹配 |\n\n## Drools内置方法\n\n规则文件的`RHS`部分的主要作用是通过**插入，删除或修改工作内存中的Fact数据**，来达到控制规则引擎执行的目的。Drools提供了一些方法可以用来操作工作内存中的数据，**操作完成后规则引擎会重新进行相关规则的匹配，** 原来没有匹配成功的规则在我们修改数据完成后有可能就会匹配成功了。\n\n### 修改 update\n\nupdate方法的作用是更新工作内存中的数据，并让相关的规则重新匹配。**（要避免死循环）\n\n**要注意 `;`号\n\n以上面的order为例\n参数：\n```java\norder.setAmount(30);\n```\n规则：\n```drl\nrule \"order_rule\"\n\twhen\n\t\t$order:Order(amount < 100)\n\tthen\n\t\t$order.setAmount(150);\n\t\tupdate($order)\n\t\tSystem.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n\nrule \"order_rule2\"\n\twhen \n\t\t$order:Order(amount >= 100 && amount <= 500)\n\tthen\n\t\t$order.setScore(100);\n\t\tSystem.out.println(\"成功匹配到规则二：100元 - 500元 加100分\");\nend\n```\n\n\n### 添加 insert\n\ninsert方法的作用是向工作内存中插入数据，并让相关的规则重新匹配。\n\n```drl\nrule \"order_rule\"\n\twhen\n\t\t$order:Order(amount < 100)\n\tthen\n\t\tOrder order = new Order();\n\t\torder.setAmount(30);\n\t\tinsert($order)\n\t\tSystem.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n\nrule \"order_rule2\"\n\twhen \n\t\t$order:Order(amount >= 100 && amount <= 500)\n\tthen\n\t\t$order.setScore(100);\n\t\tSystem.out.println(\"成功匹配到规则二：100元 - 500元 加100分\");\nend\n```\n### 删除 retract\n\nretract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。\n\n```drl\nrule \"order_rule_1\"\n    when\n        $order:Order(amout < 100)\n    then\n        retract($order)      //retract方法的作用是删除工作内存中的Fact对象，会导致相关规则重新匹配\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n## 规则属性\n\n| 属性名           | 说明                                               |\n| :--------------- | :------------------------------------------------- |\n| salience         | 指定规则执行优先级                                 |\n| dialect          | 指定规则使用的语言类型，取值为java和mvel           |\n| enabled          | 指定规则是否启用                                   |\n| date-effective   | 指定规则生效时间                                   |\n| date-expires     | 指定规则失效时间                                   |\n| activation-group | 激活分组，具有相同分组名称的规则只能有一个规则触发 |\n| agenda-group     | 议程分组，只有获取焦点的组中的规则才有可能触发     |\n| timer            | 定时器，指定规则触发的时间                         |\n| auto-focus       | 自动获取焦点，一般结合agenda-group一起使用         |\n| no-loop          | 防止死循环                                         |\n### salience\n\n- salience属性用于指定规则的执行优先级，**取值类型为Integer**。**数值越大越优先执行**。每个规则都有一个默认的执行顺序，**如果不设置salience属性，规则体的执行顺序为由上到下**。\n\n```drl\npackage com.order\n\nrule \"rule_1\"\n\tsalience 9\n    when\n        eval(true)\n    then\n        System.out.println(\"规则rule_1触发\");\nend\n    \nrule \"rule_2\"\n\tsalience 10\n    when\n        eval(true)\n    then\n        System.out.println(\"规则rule_2触发\");\nend\n\nrule \"rule_3\"\n\tsalience 7\n    when\n        eval(true)\n    then\n        System.out.println(\"规则rule_3触发\");\nend\n```\n\n### no-loop\n\n- no-loop属性用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false\n\n- **引擎默认不会重复触发同一规则​**\n​例如这个例子，修改了与规则无关的值然后再次进入相同的规则，规则不会再次触发\n```drl\nrule \"order_rule_1\"\n    when\n        $order:Order(amout < 100)\n    then\n        $order.setScore(0);\n        update($order)\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n想要实现死循环应该修改与规则有关的值，如下\n```drl\nrule \"order_rule_1\"\n    when\n        $order:Order(amount < 100)\n    then\n        $order.setAmount(0);\n        update($order)\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n- 避免死循环：\n```drl\nrule \"order_rule_1\"\n    no-loop true         //防止陷入死循环\n    when\n        $order:Order(amount < 100)\n    then\n        $order.setAmount(0);\n        update($order)\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n\n## 高级语法\n\n| 关键字   | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| package  | 包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用 |\n| import   | 用于导入类或者静态方法                                       |\n| global   | 全局变量                                                     |\n| function | 自定义函数                                                   |\n| query    | 查询                                                         |\n| rule end | 规则体                                                       |\n\n### global全局变量\n\n- global关键字用于在规则文件中**定义全局变量**，它可以让应用程序的对象在规则文件中能够被访问。可以用来为规则文件提供数据或服务。\n\n- 语法结构为：**global 对象类型 对象名称**\n\n- 注意：\n\t- 如果对象类型为**包装类型**时，在一个规则中改变了global的值，那么**只针对当前规则有效**，对其他规则中的global不会有影响。可以理解为它是当前规则代码中的global副本，规则内部修改不会影响全局的使用。\n\t- 如果对象类型为**集合类型或JavaBean**时，在一个规则中改变了global的值，对java代码和所有规则都有效。\n\n规则文件：\n```drl\npackage com.hh.order\nimport com.hh.bean.Order\n\nglobal com.hh.bean.Order order_global;\n\n//规则一：100元以下 不加分\nrule \"order_rule_1\"\n    no-loop true         //防止陷入死循环\n    when\n        $order:Order(amount < 100)\n    then\n        order_global.setScore(10);\n        update($order)\n        System.out.println(\"成功匹配到规则一：100元以下 不加分\");\nend\n```\n\n\n测试：\n```drl\n@Test\npublic void test1(){\n    //从Kie容器对象中获取会话对象\n    KieSession session = kieContainer.newKieSession();\n\n    //Fact对象，事实对象\n    Order order = new Order();\n    order.setAmout(30);\n\n    //全局变量\n    Order order2 = new Order();\n    session.setGlobal(\"order_global\", order2);\n\n    //将Order对象插入到工作内存中\n    session.insert(order);\n\n    //激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则\n    session.fireAllRules();\n    //关闭会话\n    session.dispose();\n\n    System.out.println(\"订单金额：\" + order.getAmout());\n    System.out.println(\"添加积分：\" + order2.getScore());\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["project"]},{"title":"mybatis-plus 组件策略","url":"/2025/04/18/articles/Substitute driver/mybatis-plus 组件策略/","content":"\n## 默认的组件策略 ASSIGN_ID 雪花算法\n\n- mp有默认的组件策略 `ASSIGN_ID`，会生成一个唯一的值，包含数字\n\n- 雪花算法：使用一个64位的长型的数字作为全局唯一ID\n\n- 表对应类型 bigint 或者 varchar类型\n\n## ASSIGN_UUID\n\n- `ASSIGN_ID` 还有另一个相近的策略 `ASSIGN_UUID`，生成唯一的uuid值，包含数字和字母\n\n- 表对应字段的类型 varchar(32) 类型，实体类字段对应 String\n\n## 自增策略 AUTO\n\n- 想要主键自增需要配置以下操作\n\n\t- 需要创建表的时候给主键设置自增\n\n\t- 实体字段种配置 `@TableId(type=IdType.AUTO)`\n\n\n## INPUT\n\n- 普遍用法是需要自己手动设置主键ID值，有其他复杂用法，但是看着感觉运用不多，需要的时候再做了解\n\n\n","tags":["project"]},{"title":"校园闪送项目笔记","url":"/2025/04/17/articles/Substitute driver/我来开！项目笔记/","content":"\n# 搭建前端环境\n\n## 注册微信开发者账号\n\n打开微信公总平台，按照流程一步步注册：`https://mp.weixin.qq.com/`\n\n然后去申请开通三个我们项目会用到的接口\n![[Pasted image 20250417092751.png]]\n\n\n以及我们需要用到的插件\n![[Pasted image 20250417093027.png]]\nhttps://fuwu.weixin.qq.com/search?tab=3&type=&serviceType=3&page=1&kw=腾讯位置服务地图选点\nfuwu.weixin.qq.com/search?tab=3&type=&serviceType=3&page=1&kw=微信同声传译\n\n## 安装 node.js 和微信开发者工具\n\n下载node.js：`https://nodejs.org/en/download` 版本选择16.20.0\n![[Pasted image 20250417093149.png]]\n\n\n微信开发者工具也是点击下载一步步走就行\n- 下载两遍，安装两个相同的，方便后期项目两个端口一起调试\n![[Pasted image 20250417091648.png]]\n![[Pasted image 20250417091741.png]]\n\n## 在开发者工具中运行前端代码\n\n- 点击左上角项目栏下的导入项目\n![[Pasted image 20250417093655.png]]\n\n- 点击上方设置栏中的安全设置，打开里面的服务端口\n![[Pasted image 20250417093936.png]]\n\n另一个也是一样\n\n# 搭建后端环境\n\n## 安装软件环境\n\n### 安装rabbitmq\n\n- **第一步 拉取镜像\n\n`docker pull rabbitmq:3.9.0-management\n\n- **第二步 使用容器启动服务\n\n`docker run -d --name=rabbitmq --restart=always -p 5672:5672 -p 15672:15672 rabbitmq:3.9.0-management  \n\n- **第三步 安装延迟队列插件\n\n1、首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：https://www.rabbitmq.com/community-plugins.html\n\t\n2、上传下载延迟队列插件到Linux操作系统中，切换到插件所在目录，\n\t\n执行 `docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins` 命令，将刚插件拷贝到容器内plugins目录下\n\t\n3、执行 `docker exec -it rabbitmq /bin/bash` 命令进入到容器内部，并 `cd plugins` 进入plugins目录\n\t\n执行 `ls -l|grep delay`  命令查看插件是否copy成功\n在容器内plugins目录下，执行 `rabbitmq-plugins enable rabbitmq_delayed_message_exchange`  命令启用插件\n\t\n4、exit命令退出RabbitMQ容器内部，然后执行 `docker restart rabbitmq` 命令重启RabbitMQ容器\n\n- **第四步 远程访问设置凭证\n```\n# 进入容器\ndocker exec -it rabbitmq bash\n\n# 创建新用户（用户名：admin，密码：Abc123）\nrabbitmqctl add_user admin Abc123\n\n# 赋予管理员权限\nrabbitmqctl set_user_tags admin administrator\n\n# 赋予所有权限（虚拟主机为 /）\nrabbitmqctl set_permissions -p / admin \".*\" \".*\" \".*\"\n```\n\n### 安装redis\n\n- **第一步 拉取镜像\n\n`docker pull redis`\n\n- **第二步 创建Redis配置文件\n\n```\n## 创建目录\nmkdir -p /home/redis/conf\n## 创建文件\ntouch /home/redis/conf/redis.conf\n```\n\n- **第三步 创建redis并启动\n\n```\ndocker run -d \\\n  --name redis \\\n  -p 6379:6379 \\\n  --restart unless-stopped \\\n  -v /home/redis/data:/data \\\n  -v /home/redis/conf/redis.conf:/etc/redis/redis.conf \\\n  redis:latest \\\n  redis-server /etc/redis/redis.conf\n```\n\n- **第四步 进入redis容器\n\n```\n### 直接通过Docker Redis 命令进入Redis控制台\ndocker exec -it redis redis-cli\n### 进入 Redis 控制台\nredis-cli\n### 添加一个变量为 key 为 name , value 为 bella 的内容\n> set name bella\n### 查看 key 为 name 的 value 值\n> get name\n```\n### 安装minio\n```\n docker run \\\n--name minio_one \\\n-p 9000:9000  \\\n-p 9001:9001  \\\n-d \\\n-e \"MINIO_ROOT_USER=admin\" \\\n-e \"MINIO_ROOT_PASSWORD=admin123456\" \\\n-v /root/minio-data:/data \\\n-v /root/minio-config:/root/.minio \\\nminio/minio server  /data --console-address \":9001\"\n```\n\n- docker run：这是Docker命令行工具用来运行一个新容器的命令。\n\t\n- --name minio_one：这个参数为容器指定了一个名称，这里名称被设置为minio_one。使用名称可以更方便地管理容器。\n\t\n- p 9000:9000：这个参数将容器内的9000端口映射到宿主机的9000端口。MinIO服务默认使用9000端口提供API服务。\n\t\n- -p 9001:9001：这个参数将容器内的9001端口映射到宿主机的9001端口。这是MinIO的控制台（Console）端口，用于访问MinIO的图形用户界面。\n\t\n- -d：这个参数告诉Docker以“detached”模式运行容器，即在后台运行。\n\t\n- -e \"MINIO_ROOT_USER=admin\"：设置环境变量MINIO_ROOT_USER，这是访问MinIO服务的用户名称，这里设置为admin。\n\t\n- -e \"MINIO_ROOT_PASSWORD=admin123456\"：设置环境变量MINIO_ROOT_PASSWORD，这是访问MinIO服务的用户密码，这里设置为admin123456。\n\t\n- -v /home/data:/data：这个参数将宿主机的目录/home/data:/data挂载到容器的/data目录。MinIO会将所有数据存储在这个目录。\n\t\n- -v  /root/config:/root/.minio：这个参数将宿主机的目录/root/minio-config挂载到容器的/root/.minio目录。这个目录用于存储MinIO的配置文件和数据。\n\t\n- minio/minio：这是要运行的Docker镜像的名称，这里使用的是官方发布的MinIO镜像。\n\t\n- server /data：这是传递给MinIO程序的命令行参数，告诉MinIO以服务器模式运行，并且使用/data目录作为其数据存储位置。\n\t\n- --console-address \":9001\"：这个参数指定MinIO控制台服务的监听地址和端口。在这个例子中，它设置为监听所有接口上的9001端口。\n\n注意:文件上传时，需要调整-下Linux 服务器的时间与Windows 时间一致!\n```\n第一步:安装ntp服务\nyum -y install ntp\n第二步:开启开机启动服务\nsystemctl enable ntpd\n第三步:启动服务\nsystemctl start ntpd\n第四步:更改时区\ntimedatectl set-timezone Asia/Shanghai\n第五步:启用ntp同步\ntimedatectl set-ntp yes\n第六步:同步时间\nntpq -p\n```\n\n如果启动不了，那么就重构主义，推了重建\n```\n# 强制删除旧容器（保留数据卷）\ndocker rm -f minio_one\n\n# 重新运行 MinIO 容器（使用正确的镜像名称 minio/minio）\ndocker run \\\n--name minio_one \\\n-p 9000:9000 \\\n-p 9001:9001 \\\n-d \\\n-e \"MINIO_ROOT_USER=admin\" \\\n-e \"MINIO_ROOT_PASSWORD=admin123456\" \\\n-v /root/minio-data:/data \\\n-v /root/minio-config:/root/.minio \\\nminio/minio server /data --console-address \":9001\"\n```\n\n### nacos\n\n- 开启nacos\n\n`bash /root/nacos/bin/startup.sh -m standalone`\n\n- 关闭nacos\n\n`bash /root/nacos/bin/shutdown.sh`\n\n## 导入数据库内容\n\n- 只需要在 DataGrip 连接上服务器或者本地的数据库\n\n- 然后再把所需要的数据库和表创建好，数据导入进去\n\n### 逻辑删除\n\n- 物理删除是与之前一样，直接把数据删除，但这样不方便我们恢复数据，所以 mybatis-plus 有一种删除叫逻辑删除\n\n- 我们可以在数据表加一列属性表示为逻辑删除，值为0表示没有删除，值为1表示删除，方便我们恢复数据\n\n官方文档：https://baomidou.com/guides/logic-delete/\n\n第一种方法：\n```yml\nmybatis-plus:\n  global-config:\n    db-config:\n      logic-delete-field: isDelete #默认deleted\n      logic-delete-value: 1\n      logic-not-delete-value: 0\n      id-type: auto\n```\n\n第二种方法：\n添加@TableLogic注解\n```java\n@Data\npublic class User{\n。。。\n    /**\n     * 1删除0正常\n     */\n    @TableLogic(value = \"1\",delval = \"0\")\n    private Integer isDelete;\n。。。\n}\n```\n\n添加完后再使用mp已经封装好的语句都会加上 `where deleted = 0`\n\n### 分页查询\n\n- 实现分页查询前需要配置分页插件\n\n- 分页插件：\n```java\n@Configuration\n@MapperScan(\"scan.your.mapper.package\")\npublic class MybatisPlusConfig {\n\n    /**\n     * 添加分页插件\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); // 如果配置多个插件, 切记分页最后添加\n        // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType\n        return interceptor;\n    }\n}\n```\n\n## 导入配置文件\n\n- 两种导入模式\n\n第一种：像之前一样一条一条创建\n\n第二种：把文件打成压缩包，但是压缩包名称要与组的名字相同（默认是 `DEFAULT_GROUP`）\n![[Pasted image 20250418214153.png]]\n\n\n# 客户端登录\n\n## 微信小程序登录流程\n\n- 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\n\n![[Pasted image 20250419174655.png]]\n\n\n\n\n## 微信小程序登录接口\n\n- 这是接下来需要实现的步骤\n\n项目工程结构：\n![[Pasted image 20250419180421.png]]\n\n### 准备工作\n\n- **导入微信工具包相关依赖\n\n在 service-customer 中引入依赖\n```xml\n<dependency>  \n    <groupId>com.github.binarywang</groupId>  \n    <artifactId>weixin-java-miniapp</artifactId>  \n</dependency>\n```\n\n- **修改 nacos 配置中心文件\n\n\t- 因为查看官方文档可以看到我们后端请求腾讯接口需要三个值：小程序id、密钥和临时票据code，所以我们需要去 nacos 修改配置文件，把密钥和小程序id先作配置\n\t\n\t- 注意查看项目配置文件 `bootstrap.properties` 里 nacos 的 IP 与端口是否正确\n\n\n- 创建配置类来读取配置文件信息\n\n在 service-customer 创建包config，创建类来读取配置文件中的内容\n```java\n@Component\n@Data\n//从配置文件中读取 wx.miniapp 前缀下的字段\n@ConfigurationProperties(prefix = \"wx.miniapp\")\npublic class WxConfigProperties {\n    private String appId;\n    private String secret;\n}\n```\n\n创建微信工具包对象\n```java\n@Component\npublic class WxConfigOperator {\n\n    @Autowired\n    private WxConfigProperties wxConfigProperties;\n\n    @Bean\n    public WxMaService wxMaService() {\n        WxMaDefaultConfigImpl config = new WxMaDefaultConfigImpl();\n        config.setAppid(wxConfigProperties.getAppId());\n        config.setSecret(wxConfigProperties.getSecret());\n\n        WxMaService service = new WxMaServiceImpl();\n        service.setWxMaConfig(config);\n        return service;\n    }\n}\n```\n\n\n### 功能实现-基础功能\n\n- 在 service-customer 的 CustomerInfoController\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/customer/info\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CustomerInfoController {\n\n\t@Autowired\n\tprivate CustomerInfoService customerInfoService;\n\n\t// 微信小程序登录接口\n\t@Operation(summary = \"小程序授权登录\")\n\t@GetMapping(\"login/{code}\")\n\tpublic Result<Long> longin(@PathVariable String code) {\n\t    return Result.ok(customerInfoService.login(code));\n\t}\n}\n```\n\n- service实现接口\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CustomerInfoServiceImpl extends ServiceImpl<CustomerInfoMapper, CustomerInfo> implements CustomerInfoService {\n\n    @Autowired\n    private WxMaService wxMaService;\n\n    @Autowired\n    private CustomerInfoMapper customerInfoMapper;\n\n    @Autowired\n    private CustomerLoginLogMapper customerLoginLogMapper;\n\n    //微信小程序登录\n    @Override\n    public Long login(String code) {\n        String openid = null;\n        // 获取code值，通过微信工具包对象，获取唯一标识openId\n        try {\n            WxMaJscode2SessionResult sessionInfo = wxMaService.getUserService().getSessionInfo(code);\n             openid = sessionInfo.getOpenid();\n        } catch (WxErrorException e) {\n            throw new RuntimeException(e);\n        }\n\n        // 用openId查询数据库是否存在\n        // 如果openId不存在返回null，如果存在返回记录\n        LambdaQueryWrapper<CustomerInfo> wrapper = new LambdaQueryWrapper();\n        wrapper.eq(CustomerInfo::getWxOpenId, openid);\n        CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);\n\n        // 如果不存在，也就是第一次登陆，添加信息到用户表\n        if (customerInfo == null) {\n            customerInfo = new CustomerInfo();\n            //用当前时间戳作为昵称\n            customerInfo.setNickname(String.valueOf(System.currentTimeMillis()));\n            //设置默认头像\n            customerInfo.setAvatarUrl(\"https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg\");\n            //把openId存入用户表\n            customerInfo.setWxOpenId(openid);\n            customerInfoMapper.insert(customerInfo);\n        }\n\n        // 记录登录日志\n        CustomerLoginLog loginLog = new CustomerLoginLog();\n        loginLog.setCustomerId(customerInfo.getId());\n        loginLog.setMsg(\"小程序登录\");\n        customerLoginLogMapper.insert(loginLog);\n\n        // 最后返回用户id\n        return customerInfo.getId();\n    }\n}\n```\n\n### 功能实现-远程调用\n\n- service-customer-client 定义接口\n```java\n@FeignClient(value = \"service-customer\")\npublic interface CustomerInfoFeignClient {\n\n    @GetMapping(\"/customer/info/login/{code}\")\n    public Result<Long> longin(@PathVariable String code);\n    \n}\n```\n\n- 在 web-customer 进行远程调用\ncontroller：\n```java\n@Slf4j\n@Tag(name = \"客户API接口管理\")\n@RestController\n@RequestMapping(\"/customer\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CustomerController {\n\n    @Autowired\n    private CustomerService customerInfoService;\n\n    @Operation(summary = \"小程序授权登录\")\n    @GetMapping(\"/login/{code}\")\n    public Result<String> wxLogin(@PathVariable String code) {\n        return Result.ok(customerInfoService.login(code));\n    }\n}\n```\n\nservice：\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CustomerServiceImpl implements CustomerService {\n\n    // 注入远程调用\n    @Autowired\n    private CustomerInfoFeignClient client;\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Override\n    public String login(String code) {\n\n        // 拿着code进行远程调用，返回用户id\n        Result<Long> longin = client.longin(code);\n\n        // 如果返回失败了。返回错误信息\n        Integer code1 = longin.getCode();\n        if(code1 != 200){\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n\n        // 获取远程调用的用户id\n        Long customerId = longin.getData();\n\n        // 判断返回用户id是否为空，为空则返回错误提示\n        if(customerId == null){\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n\n        // 把用户id放到Redis中，设置过期时间\n        String token = UUID.randomUUID().toString();\n\n        // 返回token\n        redisTemplate.opsForValue().set(RedisConstant.USER_LOGIN_KEY_PREFIX+token,\n                customerId.toString(),\n                RedisConstant.USER_LOGIN_KEY_TIMEOUT,\n                TimeUnit.SECONDS);\n        return token;\n    }\n}\n```\n\n### 功能实现-测试\n\n- 运行乘客端微信小程序（微信开发者工具）\n\n- 启动后端服务\n\t- 启动网关\n\t\n\t- 启动 service-customer 服务\n\t\n\t- 启动 web-customer 服务\n\n把用到的配置文件都检查一遍，重点看看IP地址和开放端口，以及MySQL的远程用户(就是因为这个问题，后面用映射成localhost解决了)\n\n## 获取客户端登录信息\n\n### service-customer 接口\n\n- Controller\n```java\n@Operation(summary = \"获取客户端登录信息\")\n\t@GetMapping(\"/getCustomerLoginInfo/{customerId}\")\n\tpublic Result<CustomerLoginVo> getCustomerLoginInfo(@PathVariable Long customerId) {\n\t\tCustomerLoginVo customerLoginVo = customerInfoService.getCustomerInfoService(customerId);\n\t\treturn Result.ok(customerLoginVo);\n\t}\n```\n\n- service\n```java\n@Override\n    public CustomerLoginVo getCustomerInfoService(Long customerId) {\n\n        // 根据用户id查询用户信息\n//        LambdaQueryWrapper<CustomerInfo> wrapper = new LambdaQueryWrapper();\n//        wrapper.eq(CustomerInfo::getId, customerId);\n//        CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);\n        CustomerInfo info = customerInfoMapper.selectById(customerId);\n        if (info == null) {\n            throw new RuntimeException(\"用户不存在\");\n        }\n\n        // 封装到customerLoginVo对象\n        CustomerLoginVo customerLoginVo = new CustomerLoginVo();\n\n        // springboot的工具类，可以把第一个对象的属性复制到第二个对象的同名属性中\n        BeanUtils.copyProperties(info, customerLoginVo);\n\n        /*\n        * 还有一个属性需要手动拷贝，判断是否存在手机号\n        * StringUtils.hasText(info.getPhone())判断字符串是否有值\n        */\n        customerLoginVo.setIsBindPhone(StringUtils.hasText(info.getPhone()));\n\n        // 返回对象\n        return customerLoginVo;\n    }\n```\n\n### web-customer 接口\n\n- controller\n```java\n@Operation(summary = \"获取客户登录信息\")\n@GetMapping(\"/getCustomerLoginInfo\")\npublic Result<CustomerLoginVo> getCustomerLoginInfo(@RequestHeader(value = \"token\") String token) {\n\n\tCustomerLoginVo customerLoginVo = customerInfoService.getCustomerLoginInfo(token);\n\t// 返回用户对象\n\treturn Result.ok(customerLoginVo);\n}\n```\n\n- service\n\t- 这里的token要和前面设置的一样\n\t- redisTemplate.opsForValue().get() 就是把redis当成一个map容器，通过键值对的方式来存储或查询\n```java\n@Override\npublic CustomerLoginVo getCustomerLoginInfo(String token) {\n\t/*\n\t * 从请求头中获取token字符串\n\t * 根据token查询redis\n\t */\n\tString customerId = (String) redisTemplate.opsForValue().get(RedisConstant.USER_LOGIN_KEY_PREFIX+token);\n\n\t// 根据用户id进行远程调用，获取用户信息\n\tif(!StringUtils.hasText(customerId)){\n\t\tthrow new GuiguException(ResultCodeEnum.DATA_ERROR);\n\t}\n\n\tResult<CustomerLoginVo> customerLoginInfo = client.getCustomerLoginInfo(Long.parseLong(customerId));\n\tInteger code = customerLoginInfo.getCode();\n\tif(code != 200){\n\t\tthrow new GuiguException(ResultCodeEnum.DATA_ERROR);\n\t}\n\tCustomerLoginVo data = customerLoginInfo.getData();\n\tif(data == null){\n\t\tthrow new GuiguException(ResultCodeEnum.DATA_ERROR);\n\t}\n\treturn data;\n}\n```\n\n## 登录校验\n\n这里选用 AOP面向切面加自定义注解完成，有想过用拦截器来做，但是路径太多，懒得配置了（高情商，更希望学习底层知识）\n\n### 创建自定义注解\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LoginDetection {\n    \n}\n```\n\n### 创建切面类\n\n```java\n@Component\n@Aspect\npublic class LoginAspect {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    // 环绕通知，运行前后都触发\n    // 切入点表达式，用来指定那些规则的方法进行增强\n    @Around(\"execution(* com.atguigu.daijia.*.controller.*.*(..)) && @annotation(loginDetection)\")\n    public Object login(ProceedingJoinPoint proceedingJoinPoint,\n                        LoginDetection loginDetection) throws Throwable {\n\n        // 获取request对象，并且从请求头获取token\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        ServletRequestAttributes sra = (ServletRequestAttributes) requestAttributes;\n\n        String token = sra.getRequest().getHeader(\"token\");\n\n\n        // 判断token是否有效，如果为空或过期，返回登录提示\n        if(!StringUtils.hasText(token)){\n            throw new GuiguException(ResultCodeEnum.LOGIN_AUTH);\n        }\n\n        // token不为空，查询redis、对应用户id，把用户id放到ThreadLocal里面\n        String customerId = (String) redisTemplate.opsForValue().get(RedisConstant.USER_LOGIN_KEY_PREFIX + token);\n        \n        if(StringUtils.hasText(customerId)){\n            AuthContextHolder.setUserId(Long.parseLong(customerId));\n        }\n        \n        // 执行目标方法\n        return proceedingJoinPoint.proceed();\n    }\n}\n```\n\n### 把之前的getCustomerLoginInfo用上注解\n在web-customer中的service里 getCustomerLoginInfo 做修改，用上我们刚刚写的注解\n```java\n@Operation(summary = \"获取客户登录信息\")\n    @LoginDetection\n    @GetMapping(\"/getCustomerLoginInfo\")\n    public Result<CustomerLoginVo> getCustomerLoginInfo() {\n\n        // 从ThreadLocal获取用户id\n        Long userId = AuthContextHolder.getUserId();\n\n        // 调用service\n        CustomerLoginVo customerLoginVo = customerInfoService.getCustomerInfo(userId);\n\n        // 返回用户对象\n        return Result.ok(customerLoginVo);\n    }\n```\n\nservice\n```java\n@Override\npublic CustomerLoginVo getCustomerInfo(Long customerId) {\n\n\tResult<CustomerLoginVo> customerLoginInfo = client.getCustomerLoginInfo(customerId);\n\tInteger code = customerLoginInfo.getCode();\n\tif(code != 200){\n\t\tthrow new GuiguException(ResultCodeEnum.DATA_ERROR);\n\t}\n\tCustomerLoginVo data = customerLoginInfo.getData();\n\tif(data == null){\n\t\tthrow new GuiguException(ResultCodeEnum.DATA_ERROR);\n\t}\n\treturn data;\n}\n```\n\n## 获取乘客手机号\n\n可恶，写完的时候发现个人版的微信开发无法使用这个，白写，最后不做判断直接改成true了\n### controller\n\n```java\n@Operation(summary = \"更新客户微信手机号码\")\n@PostMapping(\"/updateWxPhoneNumber\")\npublic Result<Boolean> updateWxPhoneNumber(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) {\n\treturn Result.ok(customerInfoService.updateWxPhoneNumber(updateWxPhoneForm));\n}\n```\n\n### service\n\n```java\n// 更新客户微信手机号码\n@Override\npublic Boolean updateWxPhoneNumber(UpdateWxPhoneForm updateWxPhoneForm) {\n\n\t// 根据code查询用户信息\n\ttry {\n\t\tWxMaPhoneNumberInfo phoneNoInfo = wxMaService.getUserService().getPhoneNoInfo(updateWxPhoneForm.getCode());\n\n\t\t// 更新用户信息\n\t\tLong customerId = updateWxPhoneForm.getCustomerId();\n\t\tCustomerInfo customerInfo = customerInfoMapper.selectById(customerId);\n\t\tcustomerInfo.setPhone(phoneNoInfo.getPhoneNumber());\n\t\tcustomerInfoMapper.updateById(customerInfo);\n\n\t\treturn true;\n\t} catch (WxErrorException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n```\n\n### web-customer\n\n- controller\n企业版\n```java\n@Operation(summary = \"更新用户微信手机号\")\n@LoginDetection\n@PostMapping(\"/updateWxPhone\")\npublic Result updateWxPhone(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) {\n\tupdateWxPhoneForm.setCustomerId(AuthContextHolder.getUserId());\n\treturn Result.ok(customerInfoService.updateWxPhoneNumber(updateWxPhoneForm));\n}\n```\n\n个人版：\n```java\n@Operation(summary = \"更新用户微信手机号\")\n@LoginDetection\n@PostMapping(\"/updateWxPhone\")\npublic Result updateWxPhone(@RequestBody UpdateWxPhoneForm updateWxPhoneForm) {\n\tupdateWxPhoneForm.setCustomerId(AuthContextHolder.getUserId());\n\treturn Result.ok(true);\n}\n```\n\n- service\n```java\n@Override\npublic boolean updateWxPhoneNumber(UpdateWxPhoneForm updateWxPhoneForm) {\n\tResult<Boolean> booleanResult = client.updateWxPhoneNumber(updateWxPhoneForm);\n\treturn true;\n}\n```\n\n# 司机端登录\n\n### **司机开启接单的条件：**\n1、登录\n\n2、认证通过\n\n3、建立了腾讯云人员库人员\n\n4、当日验证了人脸识别\n\n## 准备工作与流程\n\n- 准备共奏\n\n因为司机端要完成认证模块，比如身份证，驾驶证之类的，所以我们需要用到腾讯云的对象存储COS\n还有腾讯云的OCR来识别身份证和驾驶证\n\n- 流程如下\n\t- 司机端登录功能\n\t- 获取用户信息\n\t- 腾讯云对象存储COS\n\t- 上传信息接口\n\t- 腾讯云OCR，识别身份证与驾驶证\n\t- 人脸识别\n\n\n* 修改项目配置文件和Nacos里面配置文件内容\n\n* 创建类，读取配置文件内容，微信小程序id和秘钥，这个跟客户端的一样，直接复制过来\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"wx.miniapp\")\npublic class WxConfigProperties {\n    private String appId;\n    private String secret;\n}\n```\n\n* 创建类，初始化微信工具包相关对象\n```java\n@Component\npublic class WxConfigOperator {\n\n    @Autowired\n    private WxConfigProperties wxConfigProperties;\n\n    @Bean\n    public WxMaService wxMaService() {\n        //微信小程序id和秘钥\n        WxMaDefaultConfigImpl wxMaConfig = new WxMaDefaultConfigImpl();\n        wxMaConfig.setAppid(wxConfigProperties.getAppId());\n        wxMaConfig.setSecret(wxConfigProperties.getSecret());\n        WxMaService service = new WxMaServiceImpl();\n        service.setWxMaConfig(wxMaConfig);\n        return service;\n    }\n}\n```\n\n## 司机端登录功能\n\n\n这个步骤跟之前客户端差不多\n\n- service：\n\t- 就是获取code，然后通过code加密钥和小程序id去获取用户的唯一表示openid\n\t- 判断这个用户是不是第一次登录\n\t- 是的话初始化用户\n\t- 返回id\n- web-service:\n\t- 获取code，调用service\n\t- 远程调用获取数据\n\t- 生成token\n\t- 放入redis\n\t- 返回token\n\n\n### service-drive\n\nDriverInfoController\n```java\n@Slf4j\n@Tag(name = \"司机API接口管理\")\n@RestController\n@RequestMapping(value=\"/driver/info\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class DriverInfoController {\n\n    @Autowired\n    private DriverInfoService driverInfoService;\n\n    @Operation(summary = \"小程序授权登录\")\n    @GetMapping(\"/login/{code}\")\n    public Result<Long> login(@PathVariable(\"code\") String code) {\n        return Result.ok(driverInfoService.login(code));\n    }\n}\n```\n\nDriverInfoServiceImpl\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class DriverInfoServiceImpl extends ServiceImpl<DriverInfoMapper, DriverInfo> implements DriverInfoService {\n\n    @Autowired\n    private WxMaService wxMaService;\n\n    @Autowired\n    private DriverInfoMapper driverInfoMapper;\n\n    @Autowired\n    private DriverSetMapper driverSetMapper;\n\n    @Autowired\n    private DriverAccountMapper driverAccountMapper;\n\n    @Autowired\n    private DriverLoginLogMapper driverLoginLogMapper;\n\n    // 小程序授权登录\n    @Override\n    public Long login(String code) {\n        try {\n            // 通过code+密钥+小程序id获取用户唯一标识openid\n            WxMaJscode2SessionResult sessionInfo = wxMaService.getUserService().getSessionInfo(code);\n            String openid = sessionInfo.getOpenid();\n\n            // 根据openid查询用户信息\n            LambdaQueryWrapper<DriverInfo> wrapper = new LambdaQueryWrapper<>();\n            wrapper.eq(DriverInfo::getWxOpenId, openid);\n            DriverInfo driverInfo = driverInfoMapper.selectOne(wrapper);\n\n            if(driverInfo == null){\n                // 添加司机基本信息\n                driverInfo = new DriverInfo();\n                driverInfo.setNickname(String.valueOf(System.currentTimeMillis()));\n                driverInfo.setAvatarUrl(\"https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg\");\n                driverInfo.setWxOpenId(openid);\n                driverInfoMapper.insert(driverInfo);\n\n                // 初始化司机设置\n                DriverSet driverSet = new DriverSet();\n                driverSet.setDriverId(driverInfo.getId());\n                driverSet.setOrderDistance(new BigDecimal(0));//0：无限制\n                driverSet.setAcceptDistance(new BigDecimal(SystemConstant.ACCEPT_DISTANCE));//默认接单范围：5公里\n                driverSet.setIsAutoAccept(0);//0：否 1：是\n                driverSetMapper.insert(driverSet);\n\n                // 初始化司机账户信息\n                DriverAccount driverAccount = new DriverAccount();\n                driverAccount.setDriverId(driverInfo.getId());\n                driverAccountMapper.insert(driverAccount);\n            }\n\n            // 更新登录日志\n            DriverLoginLog loginLog = new DriverLoginLog();\n            loginLog.setDriverId(driverInfo.getId());\n            loginLog.setMsg(\"小程序登录\");\n            driverLoginLogMapper.insert(loginLog);\n\n            // 返回用户id\n            return driverInfo.getId();\n        } catch (WxErrorException e) {\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n    }\n}\n```\n\n### service-drive-client\n```java\n@FeignClient(value = \"service-driver\")\npublic interface DriverInfoFeignClient {\n\n    // 小程序授权登录\n    @GetMapping(\"/driver/info/login/{code}\")\n    public Result<Long> login(@PathVariable(\"code\") String code);\n}\n```\n\n### web-drive\n\ncontroller\n```java\n@Slf4j\n@Tag(name = \"司机API接口管理\")\n@RestController\n@RequestMapping(value=\"/driver\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class DriverController {\n\n    @Autowired\n    private DriverService driverService;\n\n    @Operation(summary = \"小程序授权登录\")\n    @GetMapping(\"/login/{code}\")\n    public Result<String> login(@PathVariable(\"code\") String code) {\n        return Result.ok(driverService.login(code));\n    }\n}\n```\n\nservice\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class DriverServiceImpl implements DriverService {\n\n    @Autowired\n    private DriverInfoFeignClient driverInfoFeignClient;\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    // 小程序授权登录\n    @Override\n    public String login(String code) {\n        Result<Long> result = driverInfoFeignClient.login(code);\n        if(result.getCode() != 200){\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n        Long data = result.getData();\n        if(data == null){\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n        String token = UUID.randomUUID().toString().replace(\"-\",\"\");\n        redisTemplate.opsForValue().set(RedisConstant.USER_LOGIN_KEY_PREFIX + token,\n                data.toString(),\n                RedisConstant.USER_LOGIN_KEY_TIMEOUT,\n                TimeUnit.SECONDS);\n\n        return token;\n    }\n}\n```\n\n## 获取登录司机信息\n\n### service-driver\n\ncontroller\n```java\n@Operation(summary = \"获取司机登录信息\")  \n@GetMapping(\"/getDriverLoginInfo/{driverId}\")  \npublic Result<DriverLoginVo> getDriverInfo(@PathVariable(\"driverId\") long driverId) {  \n    DriverLoginVo driverLoginVo = driverInfoService.getDriverInfo(driverId);  \n    return Result.ok(driverLoginVo);  \n}\n```\n\nservice\n```java\n// 获取司机登录信息\n@Override\npublic DriverLoginVo getDriverInfo(long driverId) {\n\t// 通过id查询司机信息\n\tDriverInfo driverInfo = driverInfoMapper.selectById(driverId);\n\t\n\t// 赋予到vo对象中\n\tDriverLoginVo driverLoginVo = new DriverLoginVo();\n\tBeanUtils.copyProperties(driverInfo, driverLoginVo);\n\n\t// 查询是否需要建档人脸识别\n\tString faceModelId = driverInfo.getFaceModelId();\n\tboolean isArchiveFace = StringUtils.hasText(faceModelId);\n\tdriverLoginVo.setIsArchiveFace(isArchiveFace);\n\treturn driverLoginVo;\n}\n```\n\n service-driver-client\n```java\n@FeignClient(value = \"service-driver\")\npublic interface DriverInfoFeignClient {\n\n    // 小程序授权登录\n    @GetMapping(\"/driver/info/login/{code}\")\n    public Result<Long> login(@PathVariable(\"code\") String code);\n\n    // 获取登录司机信息\n    @GetMapping(\"/driver/info/getDriverLoginInfo/{driverId}\")\n    public Result<DriverLoginVo> getDriverInfo(@PathVariable(\"driverId\") long driverId);\n}\n```\n\n### web-driver\n\ncontroller\n```java\n@Operation(summary = \"获取登录司机信息\")\n@LoginDetection\n@GetMapping(\"/getDriverLoginInfo\")\npublic Result<DriverLoginVo> getDriverLoginInfo() {\n\treturn Result.ok(driverService.getDriverLoginVo());\n}\n```\n\nservice\n```java\n@Override\npublic DriverLoginVo getDriverLoginVo() {\n\tLong driverId = AuthContextHolder.getUserId();\n\tResult<DriverLoginVo> driverInfo = driverInfoFeignClient.getDriverInfo(driverId);\n\treturn driverInfo.getData();\n}\n```\n\n### 测试一下前面的代码\n\n- 打开微信开发者工具\n- 改好相关配置文件\n- nacos\n- 启动后端服务\n\t- 网关服务service-gateway\n\t- 司机端基础服务service-driver\n\t- 对外访问服务web-driver\n\n可恶，在这里前面web-driver里面controller的路径写错了，一直访问不上，还有nacos里面的配置忘记修改成映射后的端口\n\n## 开通腾讯云对象存储COS\n\n### 准备工作\n\n- 注册并实名腾讯云\n- 找到对象存储\n- 创建储存桶\n- 创建并保存密钥和id\n\n### 思路\n\n在 web-driver：\n- 获取文件以及存放路径\n- 远程调用实现文件上传\n- 返回 vo 对象\n\n在 service-driver：\n- 导入依赖\n- 获取上传文件及路径\n- 修改配置文件\n- 基于腾讯云官方文档调用实现上传\n- 返回 vo 对象\n\n注意点：因为保密隐私，我们这里的存储桶肯定是私密的，但是我们又要让用户能看到上传后的结果，因此我们需要创建一个临时地址，让客户看到存储内容\n\n### web-service\n\n- controller\n```java\n@Tag(name = \"上传管理接口\")\n@RestController\n@RequestMapping(\"file\")\npublic class FileController {\n\n    @Autowired\n    private CosService cosService;\n\n    // 文件上传接口\n    @Operation(summary = \"上传\")\n    @LoginDetection\n    @PostMapping(\"/upload\")\n    public Result<CosUploadVo> upload(@RequestPart(\"file\") MultipartFile file,\n                                      @RequestParam(value = \"path\", defaultValue = \"auth\") String path) {\n        CosUploadVo cosUploadVo = cosService.uploadFile(file, path);\n        return Result.ok(cosUploadVo);\n    }\n}\n```\n\n- service\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CosServiceImpl implements CosService {\n\n    @Autowired\n    private CosFeignClient cosFeignClient;\n\n    // 文件上传接口\n    @Override\n    public CosUploadVo uploadFile(MultipartFile file, String path) {\n        // 远程调用获取vo\n        Result<CosUploadVo> result =  cosFeignClient.upload(file, path);\n        CosUploadVo cosUploadVo = result.getData();\n        return cosUploadVo;\n    }\n}\n```\n\n### service-driver-client\n\n```java\n@FeignClient(value = \"service-driver\")\npublic interface CosFeignClient {\n\n    /*\n    * 文件上传\n    * MediaType 表示上传类型\n    */\n    @PostMapping(value = \"/cos/upload\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n    public Result<CosUploadVo> upload(@RequestPart(\"file\") MultipartFile file,\n                                      @RequestParam(value = \"path\") String path);\n}\n```\n\n### service-driver\n\n- 导入依赖\n```xml\n<dependency>\n     <groupId>com.qcloud</groupId>\n     <artifactId>cos_api</artifactId>\n     <version>5.6.227</version>\n</dependency>\n```\n\n- 修改配置文件\n\n- 创建类读取配置文件内容\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"tencent.cloud\")\npublic class TencentCloudProperties {\n    private String secretId;\n    private String secretKey;\n    private String region;\n    private String bucketPrivate;\n}\n```\n\n- controller\n```java\n@Slf4j\n@Tag(name = \"腾讯云cos上传接口管理\")\n@RestController\n@RequestMapping(value=\"/cos\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CosController {\n\n    @Autowired\n    private CosService cosService;\n\n    @Operation(summary = \"上传\")\n    @PostMapping(\"/upload\")\n    public Result<CosUploadVo> upload(@RequestPart(\"file\") MultipartFile file,\n                                      @RequestParam(\"path\") String path) {\n        CosUploadVo cosUploadVo = cosService.upload(file, path);\n        return Result.ok(cosUploadVo);\n    }\n}\n```\n\n- service\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class CosServiceImpl implements CosService {\n\n    @Autowired\n    private TencentCloudProperties tencentCloudProperties;\n\n    // 文件上传\n   @Override\n    public CosUploadVo upload(MultipartFile file, String path) {\n\n        // 获取cos客户端\n        COSClient cosClient = getCosClient();\n\n        // 文件上传\n        // 设置文件元数据信息\n        ObjectMetadata metadata = new ObjectMetadata();\n        metadata.setContentLength(file.getSize());\n        metadata.setContentEncoding(\"UTF-8\");\n        metadata.setContentType(file.getContentType());\n\n        // 向储存桶保存文件\n        String fileType = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\".\")); //文件后缀名\n        String uploadPath = \"/driver/\" + path + \"/\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + fileType;\n        // 01.jpg\n        // /driver/auth/0o98754.jpg\n        PutObjectRequest putObjectRequest = null;\n        try {\n            //1 bucket名称\n            //2\n            putObjectRequest = new PutObjectRequest(tencentCloudProperties.getBucketPrivate(),\n                    uploadPath,\n                    file.getInputStream(),\n                    metadata);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        putObjectRequest.setStorageClass(StorageClass.Standard);\n        PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); //上传文件\n        cosClient.shutdown();\n\n        //返回vo对象\n        CosUploadVo cosUploadVo = new CosUploadVo();\n        cosUploadVo.setUrl(uploadPath);\n        // 图片临时访问回显url\n        cosUploadVo.setShowUrl(this.getImagerUrl(uploadPath));\n        return cosUploadVo;\n    }\n```\n\n提取CosClient\n```java\nprivate COSClient getCosClient() {\n\t// 1 初始化用户身份信息（secretId, secretKey）。\n\tString secretId = tencentCloudProperties.getSecretId();\n\tString secretKey = tencentCloudProperties.getSecretKey();\n\tCOSCredentials cred = new BasicCOSCredentials(secretId, secretKey);\n\t// 2 设置 bucket 的地域\n\tRegion region = new Region(tencentCloudProperties.getRegion());\n\tClientConfig clientConfig = new ClientConfig(region);\n\t// 这里建议设置使用 https 协议\n\tclientConfig.setHttpProtocol(HttpProtocol.https);\n\t// 3 生成 cos 客户端。\n\tCOSClient cosClient = new COSClient(cred, clientConfig);\n\treturn cosClient;\n}\n```\n\n获取临时签名url\n```java\n@Override\npublic String getImagerUrl(String path) {\n\tif(!StringUtils.hasText(path)){\n\t\treturn \"\";\n\t}\n\tCOSClient cosClient = getCosClient();\n\tGeneratePresignedUrlRequest request =\n\t\t\tnew GeneratePresignedUrlRequest(tencentCloudProperties.getBucketPrivate(),\n\t\t\t\t\tpath,\n\t\t\t\t\tHttpMethodName.GET);\n\t// 设置临时URL有效期\n\tDateTime dateTime = new DateTime().plusMinutes(15);\n\trequest.setExpiration(dateTime.toDate());\n\t// 调用方法获取\n\tURL url = cosClient.generatePresignedUrl(request);\n\tcosClient.shutdown();\n\treturn url.toString();\n}\n```\n\n这一大段看着很复杂，其实大部分都是腾讯云官方文档里面的内容，我们只需要修改一下参数即可\n\n\n## 腾讯云身份证与驾驶证识别接口\n\n### 思路\n\n司机注册成功后，应该需要去实名认证，这里可以用到腾讯云的身份识别和云存储功能，身份证和驾驶证上传的步骤都差不多，这里就写在一起了\n\n那我们现在计划很明确了\n\nweb-driver：\n- 获取上传文件\n- 远程调用获取认证信息\n- 返回认证信息\n\nservice-driver：\n- 上传认证图片\n- 调用腾讯云相关接口完成认证\n- 返回认证信息\n\n### service-driver\n\n- controller：\n```java\n@Slf4j\n@Tag(name = \"腾讯云识别接口管理\")\n@RestController\n@RequestMapping(value=\"/ocr\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OcrController {\n\n    @Autowired\n    private OcrService ocrService;\n\n    @Operation(summary = \"身份证识别\")\n    @PostMapping(\"/idCardOcr\")\n    public Result<IdCardOcrVo> idCardOcr(@RequestPart(\"file\") MultipartFile file) {\n        IdCardOcrVo idCardOcrVo = ocrService.idCardOcr(file);\n        return Result.ok(idCardOcrVo);\n    }\n\n\t@Operation(summary = \"驾驶证识别\")  \n\t@PostMapping(\"/driverLicenseOcr\")  \n\tpublic Result<DriverLicenseOcrVo> driverLicenseOcr(@RequestPart(\"file\") MultipartFile file) {  \n\t    DriverLicenseOcrVo driverLicenseOcrVo = ocrService.driverLicenseOcr(file);  \n\t    return Result.ok(driverLicenseOcrVo);  \n\t}\n}\n```\n\n- service：\n导入依赖：\n```java\n<dependency>  \n    <groupId>com.tencentcloudapi</groupId>  \n    <artifactId>tencentcloud-sdk-java</artifactId>  \n    <version>${tencentcloud.version}</version>  \n</dependency>\n```\n\n看着代码很多，其实全都是从腾讯云官网拉过来修改配置的\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OcrServiceImpl implements OcrService {\n\n    @Autowired\n    private TencentCloudProperties tencentCloudProperties;\n\n    @Autowired\n    private CosService cosService;\n\n    // 身份证识别\n    @Override\n    public IdCardOcrVo idCardOcr(MultipartFile file) {\n        try{\n            // file转换成base64\n            byte[] base64 = Base64.encodeBase64(file.getBytes());\n            String fileBase64 = new String(base64);\n            // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密\n            Credential cred = new Credential(tencentCloudProperties.getSecretId(),\n                    tencentCloudProperties.getSecretKey());\n            // 实例化一个http选项，可选的，没有特殊需求可以跳过\n            HttpProfile httpProfile = new HttpProfile();\n            httpProfile.setEndpoint(\"ocr.tencentcloudapi.com\");\n            // 实例化一个client选项，可选的，没有特殊需求可以跳过\n            ClientProfile clientProfile = new ClientProfile();\n            clientProfile.setHttpProfile(httpProfile);\n            // 实例化要请求产品的client对象,clientProfile是可选的\n            OcrClient client = new OcrClient(cred,tencentCloudProperties.getRegion(), clientProfile);\n            // 实例化一个请求对象,每个接口都会对应一个request对象\n            IDCardOCRRequest req = new IDCardOCRRequest();\n            //设置文件\n            req.setImageBase64(fileBase64);\n\n            // 返回的resp是一个IDCardOCRResponse的实例，与请求对象对应\n            IDCardOCRResponse resp = client.IDCardOCR(req);\n\n            //转换为IdCardOcrVo对象\n            IdCardOcrVo idCardOcrVo = new IdCardOcrVo();\n            if (StringUtils.hasText(resp.getName())) {\n                //身份证正面\n                idCardOcrVo.setName(resp.getName());\n                idCardOcrVo.setGender(\"男\".equals(resp.getSex()) ? \"1\" : \"2\");\n                idCardOcrVo.setBirthday(DateTimeFormat.forPattern(\"yyyy/MM/dd\").parseDateTime(resp.getBirth()).toDate());\n                idCardOcrVo.setIdcardNo(resp.getIdNum());\n                idCardOcrVo.setIdcardAddress(resp.getAddress());\n\n                //上传身份证正面图片到腾讯云cos\n                CosUploadVo cosUploadVo = cosService.upload(file, \"idCard\");\n                idCardOcrVo.setIdcardFrontUrl(cosUploadVo.getUrl());\n                idCardOcrVo.setIdcardFrontShowUrl(cosUploadVo.getShowUrl());\n            } else {\n                //身份证反面\n                //证件有效期：\"2010.07.21-2020.07.21\"\n                String idcardExpireString = resp.getValidDate().split(\"-\")[1];\n                idCardOcrVo.setIdcardExpire(DateTimeFormat.forPattern(\"yyyy.MM.dd\").parseDateTime(idcardExpireString).toDate());\n                //上传身份证反面图片到腾讯云cos\n                CosUploadVo cosUploadVo = cosService.upload(file, \"idCard\");\n                idCardOcrVo.setIdcardBackUrl(cosUploadVo.getUrl());\n                idCardOcrVo.setIdcardBackShowUrl(cosUploadVo.getShowUrl());\n            }\n            return idCardOcrVo;\n        } catch (Exception e) {\n            throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n        }\n    }\n\n\t//驾驶证识别  \n\t@Override  \n\tpublic DriverLicenseOcrVo driverLicenseOcr(MultipartFile file) {  \n\t    try{  \n\t        //图片转换base64格式字符串  \n\t        byte[] base64 = Base64.encodeBase64(file.getBytes());  \n\t        String fileBase64 = new String(base64);  \n\t  \n\t        // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密  \n\t        Credential cred = new Credential(tencentCloudProperties.getSecretId(),  \n\t                tencentCloudProperties.getSecretKey());  \n\t        // 实例化一个http选项，可选的，没有特殊需求可以跳过  \n\t        HttpProfile httpProfile = new HttpProfile();  \n\t        httpProfile.setEndpoint(\"ocr.tencentcloudapi.com\");  \n\t        // 实例化一个client选项，可选的，没有特殊需求可以跳过  \n\t        ClientProfile clientProfile = new ClientProfile();  \n\t        clientProfile.setHttpProfile(httpProfile);  \n\t        // 实例化要请求产品的client对象,clientProfile是可选的  \n\t        OcrClient client = new OcrClient(cred, tencentCloudProperties.getRegion(),  \n\t                clientProfile);  \n\t        // 实例化一个请求对象,每个接口都会对应一个request对象  \n\t        DriverLicenseOCRRequest req = new DriverLicenseOCRRequest();  \n\t        req.setImageBase64(fileBase64);  \n\t  \n\t        // 返回的resp是一个DriverLicenseOCRResponse的实例，与请求对象对应  \n\t        DriverLicenseOCRResponse resp = client.DriverLicenseOCR(req);  \n\t  \n\t        //封装到vo对象里面  \n\t        DriverLicenseOcrVo driverLicenseOcrVo = new DriverLicenseOcrVo();  \n\t        if (StringUtils.hasText(resp.getName())) {  \n\t            //驾驶证正面  \n\t            //驾驶证名称要与身份证名称一致  \n\t            driverLicenseOcrVo.setName(resp.getName());  \n\t            driverLicenseOcrVo.setDriverLicenseClazz(resp.getClass_());  \n\t            driverLicenseOcrVo.setDriverLicenseNo(resp.getCardCode());  \n\t            driverLicenseOcrVo.setDriverLicenseIssueDate(DateTimeFormat.forPattern(\"yyyy-MM-dd\").parseDateTime(resp.getDateOfFirstIssue()).toDate());  \n\t            driverLicenseOcrVo.setDriverLicenseExpire(DateTimeFormat.forPattern(\"yyyy-MM-dd\").parseDateTime(resp.getEndDate()).toDate());  \n\t  \n\t            //上传驾驶证反面图片到腾讯云cos  \n\t            CosUploadVo cosUploadVo = cosService.upload(file, \"driverLicense\");  \n\t            driverLicenseOcrVo.setDriverLicenseFrontUrl(cosUploadVo.getUrl());  \n\t            driverLicenseOcrVo.setDriverLicenseFrontShowUrl(cosUploadVo.getShowUrl());  \n\t        } else {  \n\t            //驾驶证反面  \n\t            //上传驾驶证反面图片到腾讯云cos  \n\t            CosUploadVo cosUploadVo =  cosService.upload(file, \"driverLicense\");  \n\t            driverLicenseOcrVo.setDriverLicenseBackUrl(cosUploadVo.getUrl());  \n\t            driverLicenseOcrVo.setDriverLicenseBackShowUrl(cosUploadVo.getShowUrl());  \n\t        }  \n\t  \n\t        return driverLicenseOcrVo;  \n\t    } catch (Exception e) {  \n\t        e.printStackTrace();  \n\t        throw new GuiguException(ResultCodeEnum.DATA_ERROR);  \n\t    }  \n\t}\n}\n```\n\n### service-client\n\n```java\n@FeignClient(value = \"service-driver\")  \npublic interface OcrFeignClient {  \n  \n    @PostMapping(value = \"/ocr/idCardOcr\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)  \n    Result<IdCardOcrVo> idCardOcr(@RequestPart(\"file\") MultipartFile file);  \n  \n    @PostMapping(value = \"/ocr/driverLicenseOcr\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)  \n    Result<DriverLicenseOcrVo> driverLicenseOcr(@RequestPart(\"file\") MultipartFile file);  \n}\n```\n\n\n### web-service\n\n- controller\n```java\n@Slf4j  \n@Tag(name = \"腾讯云识别接口管理\")  \n@RestController  \n@RequestMapping(value=\"/ocr\")  \n@SuppressWarnings({\"unchecked\", \"rawtypes\"})  \npublic class OcrController {  \n  \n    @Autowired  \n    private OcrService ocrService;  \n  \n    @Operation(summary = \"身份证识别\")  \n    @LoginDetection  \n    @PostMapping(\"/idCardOcr\")  \n    public Result<IdCardOcrVo> uploadDriverLicenseOcr(@RequestPart(\"file\")MultipartFile file){  \n        return Result.ok(ocrService.idCardOcr(file));  \n    }  \n  \n    @Operation(summary = \"驾驶证识别\")  \n    @LoginDetection  \n    @PostMapping(\"/driverLicenseOcr\")  \n    public Result<DriverLicenseOcrVo> driverLicenseOcr(@RequestPart(\"file\")MultipartFile file){  \n        return Result.ok(ocrService.driverLicenseOcr(file));  \n    }  \n}\n```\n\n- serivce\n```java\n@Slf4j  \n@Service  \n@SuppressWarnings({\"unchecked\", \"rawtypes\"})  \npublic class OcrServiceImpl implements OcrService {  \n  \n    @Autowired  \n    private OcrFeignClient ocrFeignClient;  \n  \n    // 身份证  \n    @Override  \n    public IdCardOcrVo idCardOcr(MultipartFile file) {  \n        Result<IdCardOcrVo> ocrVoResult = ocrFeignClient.idCardOcr(file);  \n        return ocrVoResult.getData();  \n    }  \n  \n    // 驾驶证  \n    @Override  \n    public DriverLicenseOcrVo driverLicenseOcr(MultipartFile file) {  \n        Result<DriverLicenseOcrVo> result = ocrFeignClient.driverLicenseOcr(file);  \n        return result.getData();  \n    }  \n}\n```\n\n## 获取司机认证信息\n\n### 思路\n\n司机登录后会进入认证界面，判单是否认证，进入认证界面是会显示回显的图片\n\n其实这个很简单，因为腾讯云的那个文字识别会返回参数出来，我们只需要把回显地址返回回去就行\n\ndriver-service\n- 通过id来传入回显地址\n\ndriver-web\n- 调用该\n\n### service-driver\n\n- controller\n```java\n@Operation(summary = \"获取司机认证信息\")\n@GetMapping(\"/getDriverAuthInfo/{driverId}\")\npublic Result<DriverAuthInfoVo> getDriverAuthInfo(@PathVariable Long driverId) {\n    DriverAuthInfoVo driverAuthInfoVo = driverInfoService.getDriverAuthInfo(driverId);\n    return Result.ok(driverAuthInfoVo);\n}\n```\n\n- service\n```java\n```java\n//获取司机认证信息\n@Override\npublic DriverAuthInfoVo getDriverAuthInfo(Long driverId) {\n    DriverInfo driverInfo = driverInfoMapper.selectById(driverId);\n    DriverAuthInfoVo driverAuthInfoVo = new DriverAuthInfoVo();\n    BeanUtils.copyProperties(driverInfo,driverAuthInfoVo);\n    driverAuthInfoVo.setIdcardBackShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardBackUrl()));\n        driverAuthInfoVo.setIdcardFrontShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardFrontUrl()));\n\n    driverAuthInfoVo.setIdcardHandShowUrl(cosService.getImageUrl(driverAuthInfoVo.getIdcardHandUrl()));\n\n    driverAuthInfoVo.setDriverLicenseFrontShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseFrontUrl()));\n\n    driverAuthInfoVo.setDriverLicenseBackShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseBackUrl()));\n\n    driverAuthInfoVo.setDriverLicenseHandShowUrl(cosService.getImageUrl(driverAuthInfoVo.getDriverLicenseHandUrl()));\n    return driverAuthInfoVo;\n\n}\n```\n\n### service-client\n```java\n@GetMapping(\"/driver/info/getDriverAuthInfo/{driverId}\")\nResult<DriverAuthInfoVo> getDriverAuthInfo(@PathVariable(\"driverId\") Long driverId);\n```\n\n\n### web-serive\n\n- controller\n```java\n@Operation(summary = \"获取司机认证信息\")\n@GuiguLogin\n@GetMapping(\"/getDriverAuthInfo\")\npublic Result<DriverAuthInfoVo> getDriverAuthInfo() {\n    //获取登录用户id，当前是司机id\n    Long driverId = AuthContextHolder.getUserId();\n    return Result.ok(driverService.getDriverAuthInfo(driverId));\n}\n```\n\n- serivce\n```java\n//司机认证信息\n@Override\npublic DriverAuthInfoVo getDriverAuthInfo(Long driverId) {\n    Result<DriverAuthInfoVo> authInfoVoResult = driverInfoFeignClient.getDriverAuthInfo(driverId);\n    DriverAuthInfoVo driverAuthInfoVo = authInfoVoResult.getData();\n    return driverAuthInfoVo;\n}\n```\n\n## 修改司机认证信息\n\n### 思路\n\n前端点击提交后，后端需要更新客户认证信息\n​    0:  未认证 【刚注册完为未认证状态】\n​    1：审核中 【提交了认证信息后变为审核中】\n​    2：认证通过 【后台审核通过】\n​   -1：认证未通过【后台审核不通过】\n\n这个和上面差不多，其他就不写了，就写一个service\n\n```java\n// 更新司机认证信息\n@Override\npublic boolean updateDriverAuthInfo(UpdateDriverAuthInfoForm update) {\n\tLong driverId = update.getDriverId();\n\tDriverInfo driverInfo = new DriverInfo();\n\tdriverInfo.setId(driverId);\n\tBeanUtils.copyProperties(update, driverInfo);\n\treturn this.updateById(driverInfo);\n}\n```\n\n## 开通人脸识别\n\n腾讯云文档：[人脸识别_人脸搜索_人脸检测_人脸比对-腾讯云](https://cloud.tencent.com/product/facerecognition)\n\n1、开通腾讯云人脸识别\n2、创建人员库\n\n### 创建司机人脸模型\n\n创建人脸识别模型之后，腾讯云返回模型id，获取模型id，更新到数据库表，但是因为这是调用腾讯云接口，所以如果之前已经有人拿这张图片创建过则不会创建新的模型id，而是返回之前创建的id\n\n- 修改配置文件\n- 修改配置类\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"tencent.cloud\")\npublic class TencentCloudProperties {\n\n    private String secretId;\n    private String secretKey;\n    private String region;\n    private String bucketPrivate;\n\n    private String persionGroupId;\n}\n```\n\n- 根据腾讯云文档来实现代码 [API Explorer - 云 API - 控制台](https://console.cloud.tencent.com/api/explorer?Product=iai&Version=2020-03-03&Action=CreatePerson)\n\n### service-driver\n\n后面都是只写重要的代码实现，一般的调用就不写了\n\n```java\n// 创建司机人脸模型\n@Override\npublic Boolean creatDriverFaceModel(DriverFaceModelForm driverFaceModelForm) {\n\t//根据司机id获取司机信息\n\tDriverInfo driverInfo =\n\t\t\tdriverInfoMapper.selectById(driverFaceModelForm.getDriverId());\n\ttry{\n\t\tCredential cred = new Credential(tencentCloudProperties.getSecretId(),\n\t\t\t\ttencentCloudProperties.getSecretKey());\n\t\t// 实例化一个http选项，可选的，没有特殊需求可以跳过\n\t\tHttpProfile httpProfile = new HttpProfile();\n\t\thttpProfile.setEndpoint(\"iai.tencentcloudapi.com\");\n\t\t// 实例化一个client选项，可选的，没有特殊需求可以跳过\n\t\tClientProfile clientProfile = new ClientProfile();\n\t\tclientProfile.setHttpProfile(httpProfile);\n\t\t// 实例化要请求产品的client对象,clientProfile是可选的\n\t\tIaiClient client = new IaiClient(cred, tencentCloudProperties.getRegion(),\n\t\t\t\tclientProfile);\n\t\t// 实例化一个请求对象,每个接口都会对应一个request对象\n\t\tCreatePersonRequest req = new CreatePersonRequest();\n\t\t//设置相关值\n\t\treq.setGroupId(tencentCloudProperties.getPersionGroupId());\n\t\t//基本信息\n\t\treq.setPersonId(String.valueOf(driverInfo.getId()));\n\t\treq.setGender(Long.parseLong(driverInfo.getGender()));\n\t\treq.setQualityControl(4L);\n\t\treq.setUniquePersonControl(4L);\n\t\treq.setPersonName(driverInfo.getName());\n\t\treq.setImage(driverFaceModelForm.getImageBase64());\n\n\t\t// 返回的resp是一个CreatePersonResponse的实例，与请求对象对应\n\t\tCreatePersonResponse resp = client.CreatePerson(req);\n\t\t// 输出json格式的字符串回包\n\t\tSystem.out.println(AbstractModel.toJsonString(resp));\n\t\tString faceId = resp.getFaceId();\n\t\tif(StringUtils.hasText(faceId)) {\n\t\t\tdriverInfo.setFaceModelId(faceId);\n\t\t\tdriverInfoMapper.updateById(driverInfo);\n\t\t}\n\t} catch (TencentCloudSDKException e) {\n\t\te.printStackTrace();\n\t\treturn false;\n\t}\n\treturn true;\n}\n```\n\n# 预估订单数据\n\n## 查找客户端当前订单\n\n当一个客户发起订单前先要查询是否有发起并且没有完成的订单，如果有订单未完成，则会弹出进行中的订单\n\n## 预估驾驶路线\n\n- 访问腾讯官网 https://lbs.qq.com/\n\n- 进行注册，手机号或者微信或者其他方式\n\n- 使用注册账号进行登录，找到控制台\n\n- 在应用管理 -- 我的应用 ，创建应用\n\n- 在创建应用中，添加key\n\n- 修改nacos配置文件\n\n- 编写接口\n\n下面实现接口，具体内容就是请求腾讯云提供的接口，按照接口传参数，然后返回需要的结果\n\n腾讯官方文档：[WebService API | 腾讯位置服务](https://lbs.qq.com/service/webService/webServiceGuide/route/webServiceRoute)\n\n- 编写配置类\n```java\n@Configuration\npublic class MyConfig {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n- service\n```java\n@Slf4j  \n@Service  \n@SuppressWarnings({\"unchecked\", \"rawtypes\"})  \npublic class MapServiceImpl implements MapService {  \n  \n    @Autowired  \n    private RestTemplate restTemplate;  \n  \n    @Value(\"${tencent.map.key}\")  \n    private String key;  \n  \n    //计算驾驶线路  \n    @Override  \n    public DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) {  \n        //请求腾讯提供接口，按照接口要求传递相关参数，返回需要结果  \n        //使用HttpClient，目前Spring封装调用工具使用RestTemplate  \n        //定义调用腾讯地址  \n        String url = \"https://apis.map.qq.com/ws/direction/v1/driving/?from={from}&to={to}&key={key}\";  \n  \n        //封装传递参数  \n        Map<String,String> map = new HashMap();  \n        //开始位置  \n        // 经纬度：比如 北纬40 东京116  \n        map.put(\"from\",calculateDrivingLineForm.getStartPointLatitude()+\",\"+calculateDrivingLineForm.getStartPointLongitude());  \n        //结束位置  \n        map.put(\"to\",calculateDrivingLineForm.getEndPointLatitude()+\",\"+calculateDrivingLineForm.getEndPointLongitude());  \n        //key  \n        map.put(\"key\",key);  \n  \n        //使用RestTemplate调用 GET        JSONObject result = restTemplate.getForObject(url, JSONObject.class, map);  \n        //处理返回结果  \n        //判断调用是否成功  \n        int status = Objects.requireNonNull(result).getIntValue(\"status\");  \n        if(status != 0) {//失败  \n            throw new GuiguException(ResultCodeEnum.MAP_FAIL);  \n        }  \n  \n        //获取返回路线信息  \n        JSONObject route =  \n                result.getJSONObject(\"result\").getJSONArray(\"routes\").getJSONObject(0);  \n  \n        //创建vo对象  \n        DrivingLineVo drivingLineVo = new DrivingLineVo();  \n        //预估时间  \n        drivingLineVo.setDuration(route.getBigDecimal(\"duration\"));  \n        //距离  6.583 == 6.58 / 6.59        drivingLineVo.setDistance(route.getBigDecimal(\"distance\")  \n                .divide(new BigDecimal(1000))  \n                .setScale(2, RoundingMode.HALF_UP));  \n        //路线  \n        drivingLineVo.setPolyline(route.getJSONArray(\"polyline\"));  \n  \n        return drivingLineVo;  \n    }  \n}\n```\n\n## 预估订单金额\n\n### 整合规则引擎Drools\n\n- 引入依赖\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.drools</groupId>\n        <artifactId>drools-core</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.drools</groupId>\n        <artifactId>drools-compiler</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.drools</groupId>\n        <artifactId>drools-decisiontables</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.drools</groupId>\n        <artifactId>drools-mvel</artifactId>\n    </dependency>\n</dependencies>\n```\n\n- 创建Drools配置类\n```java\n@Configuration\npublic class DroolsConfig {\n    // 制定规则文件的路径\n    private static final String RULES_CUSTOMER_RULES_DRL = \"rules/FeeRule.drl\";\n\n    @Bean\n    public KieContainer kieContainer() {\n        KieServices kieServices = KieServices.Factory.get();\n\n        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();\n        kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_CUSTOMER_RULES_DRL));\n        KieBuilder kb = kieServices.newKieBuilder(kieFileSystem);\n        kb.buildAll();\n\n        KieModule kieModule = kb.getKieModule();\n        KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());\n        return kieContainer;\n    }\n}\n```\n\n- 创建规则文件\n\n### 封装费用规则接口\n\n#### 实体类\n\n- 两个实体类，输入对象和输出对象\n\n- 输入对象\n```java\n@Data\npublic class FeeRuleRequest {\n\n    @Schema(description = \"代驾里程\")// swagger里面的描述\n    private BigDecimal distance;\n\n    @Schema(description = \"代驾时间\")\n    private String startTime;\n\n    @Schema(description = \"等候分钟\")\n    private Integer waitMinute;\n}\n```\n\n- 输出对象\n```java\n@Data\npublic class FeeRuleResponse {\n\n\n    @Schema(description = \"总金额\")\n    private BigDecimal totalAmount;\n\n    @Schema(description = \"里程费\")\n    private BigDecimal distanceFee;\n\n    @Schema(description = \"等时费用\")\n    private BigDecimal waitFee;\n\n    @Schema(description = \"远程费\")\n    private BigDecimal longDistanceFee;\n\n    @Schema(description = \"基础里程（公里）\")\n    private BigDecimal baseDistance;\n\n    @Schema(description = \"基础里程费（元）\")\n    private BigDecimal baseDistanceFee;\n\n    @Schema(description = \"超出基础里程的里程（公里）\")\n    private BigDecimal exceedDistance;\n\n    @Schema(description = \"超出基础里程的价格（元/公里）\")\n    private BigDecimal exceedDistancePrice;\n\n    @Schema(description = \"基础等时分钟（分钟）\")\n    private Integer baseWaitMinute;\n\n    @Schema(description = \"超出基础等时的分钟（分钟）\")\n    private Integer exceedWaitMinute;\n\n    @Schema(description = \"超出基础分钟的价格（元/分钟）\")\n    private BigDecimal exceedWaitMinutePrice;\n\n    @Schema(description = \"基础远途里程（公里）\")\n    private BigDecimal baseLongDistance;\n\n    @Schema(description = \"超出基础远程里程的里程（公里）\")\n    private BigDecimal exceedLongDistance;\n\n    @Schema(description = \"超出基础远程里程的价格（元/公里）\")\n    private BigDecimal exceedLongDistancePrice;\n}\n\n```\n\n#### 费用规则文件\n\n1.起步价  \n    00:00:00-06:59:59  19元(含3公里)  \n    07:00:00-23:59:59  19元(含5公里)\n2.里程费  \n    超出起步里程后开始计算  \n    00:00:00-06:59:59   4元/1公里  \n    07:00:00-23:59:59   3元/1公里\n3.等候费  \n    等候10分钟后  1元/1分钟\n4.远途费  \n    订单行程超出12公里后每公里1元\n5.计算总金额  \n    订单总金额 = 基础里程费 + 超出基础里程的费 + 等候费 + 远程费\n\n\n```drl\n//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问\npackage  com.atguigu.daijia\n\nimport com.atguigu.daijia.model.form.rules.FeeRuleRequest;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nglobal com.atguigu.daijia.model.vo.rules.FeeRuleResponse feeRuleResponse;\n\n/**\n1.起步价\n    00:00:00-06:59:59  19元(含3公里)\n    07:00:00-23:59:59  19元(含5公里)\n*/\nrule \"起步价 00:00:00-06:59:59  19元(含3公里)\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(startTime >= \"00:00:00\" && startTime <= \"06:59:59\")\n    then\n        feeRuleResponse.setBaseDistance(new BigDecimal(\"3.0\"));\n        feeRuleResponse.setBaseDistanceFee(new BigDecimal(\"19.0\"));\n        //3公里内里程费为0\n        feeRuleResponse.setExceedDistance(new BigDecimal(\"0.0\"));\n        feeRuleResponse.setExceedDistancePrice(new BigDecimal(\"4.0\"));\n        System.out.println(\"00:00:00-06:59:59 \" + feeRuleResponse.getBaseDistance() + \"公里，起步价:\" + feeRuleResponse.getBaseDistanceFee() + \"元\");\nend\nrule \"起步价 07:00:00-23:59:59  19元(含5公里)\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(startTime >= \"07:00:00\" && startTime <= \"23:59:59\")\n    then\n        feeRuleResponse.setBaseDistance(new BigDecimal(\"5.0\"));\n        feeRuleResponse.setBaseDistanceFee(new BigDecimal(\"19.0\"));\n\n        //5公里内里程费为0\n        feeRuleResponse.setExceedDistance(new BigDecimal(\"0.0\"));\n        feeRuleResponse.setExceedDistancePrice(new BigDecimal(\"3.0\"));\n        System.out.println(\"07:00:00-23:59:59 \" + feeRuleResponse.getBaseDistance() + \"公里，起步价:\" + feeRuleResponse.getBaseDistanceFee() + \"元\");\nend\n\n/**\n2.里程费\n    超出起步里程后开始计算\n    00:00:00-06:59:59   4元/1公里\n    07:00:00-23:59:59   3元/1公里\n*/\nrule \"里程费 00:00:00-06:59:59 4元/1公里\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(startTime >= \"00:00:00\"\n            && startTime <= \"06:59:59\"\n            && distance.doubleValue() > 3.0)\n    then\n        BigDecimal exceedDistance = $rule.getDistance().subtract(new BigDecimal(\"3.0\"));\n        feeRuleResponse.setExceedDistance(exceedDistance);\n        feeRuleResponse.setExceedDistancePrice(new BigDecimal(\"4.0\"));\n        System.out.println(\"里程费，超出里程:\" + feeRuleResponse.getExceedDistance() + \"公里，单价：\" + feeRuleResponse.getExceedDistancePrice());\nend\nrule \"里程费 07:00:00-23:59:59 3元/1公里\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(startTime >= \"07:00:00\"\n            && startTime <= \"23:59:59\"\n            && distance.doubleValue() > 5.0)\n    then\n        BigDecimal exceedDistance = $rule.getDistance().subtract(new BigDecimal(\"5.0\"));\n        feeRuleResponse.setExceedDistance(exceedDistance);\n        feeRuleResponse.setExceedDistancePrice(new BigDecimal(\"3.0\"));\n        System.out.println(\"里程费，超出里程:\" + feeRuleResponse.getExceedDistance() + \"公里，单价：\" + feeRuleResponse.getExceedDistancePrice());\nend\n\n/**\n3.等候费\n    等候10分钟后  1元/1分钟\n*/\nrule \"等候费 等候10分钟后 1元/1分钟\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(waitMinute > 10)\n    then\n        Integer exceedWaitMinute = $rule.getWaitMinute() - 10;\n        feeRuleResponse.setBaseWaitMinute(10);\n        feeRuleResponse.setExceedWaitMinute(exceedWaitMinute);\n        feeRuleResponse.setExceedWaitMinutePrice(new BigDecimal(\"1.0\"));\n        System.out.println(\"等候费，超出分钟:\" + feeRuleResponse.getExceedWaitMinute() + \"分钟，单价：\" + feeRuleResponse.getExceedWaitMinutePrice());\nend\nrule \"无等候费\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(waitMinute <= 10)\n    then\n        feeRuleResponse.setBaseWaitMinute(10);\n        feeRuleResponse.setExceedWaitMinute(0);\n        feeRuleResponse.setExceedWaitMinutePrice(new BigDecimal(\"1.0\"));\n        System.out.println(\"等候费：无\");\nend\n\n/**\n4.远途费\n    订单行程超出12公里后每公里1元\n*/\nrule \"远途费 订单行程超出12公里后每公里1元\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(distance.doubleValue() > 12.0)\n    then\n        BigDecimal exceedLongDistance = $rule.getDistance().subtract(new BigDecimal(\"12.0\"));\n        feeRuleResponse.setBaseLongDistance(new BigDecimal(\"12.0\"));\n        feeRuleResponse.setExceedLongDistance(exceedLongDistance);\n        feeRuleResponse.setExceedLongDistancePrice(new BigDecimal(\"1.0\"));\n        System.out.println(\"远途费，超出公里:\" + feeRuleResponse.getExceedLongDistance() + \"公里，单价：\" + feeRuleResponse.getExceedLongDistancePrice());\nend\nrule \"无远途费\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(distance.doubleValue() <= 12.0)\n    then\n        feeRuleResponse.setBaseLongDistance(new BigDecimal(\"12.0\"));\n        feeRuleResponse.setExceedLongDistance(new BigDecimal(\"0\"));\n        feeRuleResponse.setExceedLongDistancePrice(new BigDecimal(\"0\"));\n        System.out.println(\"远途费：无\");\nend\n\n/**\n5.计算总金额\n    订单总金额 = 基础里程费 + 超出基础里程的费 + 等候费 + 远程费\n*/\nrule \"计算总金额\"\n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行\n    no-loop true         //防止陷入死循环\n    when\n        /*规则条件，到工作内存中查找FeeRuleRequest对象\n        里面出来的结果只能是ture或者false\n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/\n        $rule:FeeRuleRequest(distance.doubleValue() > 0.0)\n    then\n        //订单总金额 = 基础里程费 + 超出基础里程的费 + 等候费 + 远程费\n        BigDecimal distanceFee = feeRuleResponse.getBaseDistanceFee().add(feeRuleResponse.getExceedDistance().multiply(feeRuleResponse.getExceedDistancePrice()));\n        BigDecimal waitFee = new BigDecimal(feeRuleResponse.getExceedWaitMinute()).multiply(feeRuleResponse.getExceedWaitMinutePrice());\n        BigDecimal longDistanceFee = feeRuleResponse.getExceedLongDistance().multiply(feeRuleResponse.getExceedLongDistancePrice());\n        BigDecimal totalAmount = distanceFee.add(waitFee).add(longDistanceFee);\n        feeRuleResponse.setDistanceFee(distanceFee);\n        feeRuleResponse.setWaitFee(waitFee);\n        feeRuleResponse.setLongDistanceFee(longDistanceFee);\n        feeRuleResponse.setTotalAmount(totalAmount);\n        System.out.println(\"计算总金额:\" + feeRuleResponse.getTotalAmount() + \"元\");\nend\n```\n\n#### 预估订单金额接口\n\n- FeeRuleController\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/rules/fee\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class FeeRuleController {\n\n    @Autowired\n    private FeeRuleService feeRuleService;\n    @Operation(summary = \"计算订单费用\")\n    @PostMapping(\"/calculateOrderFee\")\n    public Result<FeeRuleResponseVo> calculateOrderFee(@RequestBody FeeRuleRequestForm calculateOrderFeeForm) {\n        FeeRuleResponseVo feeRuleResponseVo = feeRuleService.calculateOrderFee(calculateOrderFeeForm);\n        return Result.ok(feeRuleResponseVo);\n    }\n}\n```\n\n- FeeRuleService\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class FeeRuleServiceImpl implements FeeRuleService {\n\n    @Autowired\n    private KieContainer kieContainer;\n\n    // 计算订单费用\n    @Override\n    public FeeRuleResponseVo calculateOrderFee(FeeRuleRequestForm form) {\n        // 封装输入对象\n        FeeRuleRequest request = new FeeRuleRequest();\n        request.setDistance(form.getDistance());\n        Date startTime = form.getStartTime();\n        request.setStartTime(new DateTime(startTime).toString(\"HH:mm:ss\"));\n        request.setWaitMinute(form.getWaitMinute());\n\n        // Drools执行规则\n        KieSession session = kieContainer.newKieSession();\n        // 封装返回对象\n        FeeRuleResponseVo response = new FeeRuleResponseVo();\n        session.setGlobal(\"feeRuleResponse\",response);\n\n        session.insert(request);\n        session.fireAllRules();\n        session.dispose();\n\n        // 封装数据到输出对象\n        FeeRuleResponseVo vo = new FeeRuleResponseVo();\n        BeanUtils.copyProperties(response,vo);\n        return vo;\n    }\n}\n\n```\n\n#### 远程调用接口\n\n```java\n@FeignClient(value = \"service-rules\")\npublic interface FeeRuleFeignClient {\n\n    /**\n     * 计算订单费用\n     * @param calculateOrderFeeForm\n     * @return\n     */\n    @PostMapping(\"/rules/fee/calculateOrderFee\")\n    Result<FeeRuleResponseVo> calculateOrderFee(@RequestBody FeeRuleRequestForm calculateOrderFeeForm);\n}\n```\n\n\n### 预估订单数据接口\n\n-  OrderController\n```java\n@Autowired  \nprivate OrderService orderService;  \n  \n@Operation(summary = \"预估订单数据\")  \n@LoginDetection  \n@PostMapping(\"/expectOrder\")  \npublic Result<ExpectOrderVo> expectOrder(@RequestBody ExpectOrderForm expectOrderForm) {  \n    return Result.ok(orderService.expectOrder(expectOrderForm));  \n}\n```\n\n- OrderService\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OrderServiceImpl implements OrderService {\n\n    @Autowired\n    private MapFeignClient mapFeignClient;\n\n    @Autowired\n    private FeeRuleFeignClient feeRuleFeignClient;\n\n    // 预估订单数据\n    @Override\n    public ExpectOrderVo expectOrder(ExpectOrderForm expectOrderForm) {\n        //获取驾驶线路\n        CalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();\n        BeanUtils.copyProperties(expectOrderForm,calculateDrivingLineForm);\n        Result<DrivingLineVo> drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);\n        DrivingLineVo drivingLineVo = drivingLineVoResult.getData();\n\n        //获取订单费用\n        FeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();\n        calculateOrderFeeForm.setDistance(drivingLineVo.getDistance());\n        calculateOrderFeeForm.setStartTime(new Date());\n        calculateOrderFeeForm.setWaitMinute(0);\n        Result<FeeRuleResponseVo> feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);\n        FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();\n\n        //封装ExpectOrderVo\n        ExpectOrderVo expectOrderVo = new ExpectOrderVo();\n        expectOrderVo.setDrivingLineVo(drivingLineVo);\n        expectOrderVo.setFeeRuleResponseVo(feeRuleResponseVo);\n        return expectOrderVo;\n    }\n}\n```\n\n\n# 乘客下单（一）\n\n点击 `呼叫代驾` 会生成代驾订单，在 `order_info` 里添加订单数据\n\n## 乘客下单接口\n\n- controller 不写了，就是调用获取数据\n\n- service\n```java\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> implements OrderInfoService {\n\n    @Autowired\n    private OrderInfoMapper orderInfoMapper;\n\n    @Autowired\n    private OrderStatusLogMapper orderStatusLogMapper;\n\n    // 乘客下单\n    @Override\n    public Long saveOrderInfo(OrderInfoForm orderInfoForm) {\n        // 向order_info表中插入数据\n        OrderInfo orderInfo = new OrderInfo();\n        BeanUtils.copyProperties(orderInfoForm, orderInfo);\n\n        orderInfo.setOrderNo(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));\n        orderInfo.setStatus(OrderStatus.WAITING_ACCEPT.getStatus());\n\n        orderInfoMapper.insert(orderInfo);\n\n        // 记录日志\n        this.log(orderInfo.getId(), orderInfo.getStatus());\n        \n        return orderInfo.getId();\n    }\n\n    public void log(Long orderId, Integer status) {\n        OrderStatusLog orderStatusLog = new OrderStatusLog();\n        orderStatusLog.setOrderId(orderId);\n        orderStatusLog.setOrderStatus(status);\n        orderStatusLog.setOperateTime(new Date());\n        orderStatusLogMapper.insert(orderStatusLog);\n    }\n}\n```\n\n- 远程调用\n```java\n@FeignClient(value = \"service-order\")\npublic interface OrderInfoFeignClient {\n\n    /**\n     * 保存订单信息\n     * @param orderInfoForm\n     * @return\n     */\n    @PostMapping(\"/order/info/saveOrderInfo\")\n    Result<Long> saveOrderInfo(@RequestBody OrderInfoForm orderInfoForm);\n}\n```\n\n- web-service\n```java\n@Override\npublic Long submitOrder(SubmitOrderForm submitOrderForm) {\n\t//1 重新计算驾驶线路\n\tCalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();\n\tBeanUtils.copyProperties(submitOrderForm,submitOrderForm);\n\tResult<DrivingLineVo> drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);\n\tDrivingLineVo drivingLineVo = drivingLineVoResult.getData();\n\n\t//2 重新订单费用\n\tFeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();\n\tcalculateOrderFeeForm.setDistance(drivingLineVo.getDistance());\n\tcalculateOrderFeeForm.setStartTime(new Date());\n\tcalculateOrderFeeForm.setWaitMinute(0);\n\tResult<FeeRuleResponseVo> feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);\n\tFeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();\n\n\t//封装数据\n\tOrderInfoForm orderInfoForm = new OrderInfoForm();\n\tBeanUtils.copyProperties(submitOrderForm,orderInfoForm);\n\torderInfoForm.setExpectDistance(drivingLineVo.getDistance());\n\torderInfoForm.setExpectAmount(feeRuleResponseVo.getTotalAmount());\n\tResult<Long> orderInfoResult = orderInfoFeignClient.saveOrderInfo(orderInfoForm);\n\tLong orderId = orderInfoResult.getData();\n\n\t//TODO 查询附近可以接单司机\n\n\treturn orderId;\n}\n```\n\n## 查询订单状态\n\n### 订单微服务模块接口\n\n- 根据订单id得到订单状态\n\n- OrderInfoController\n```java\n@Operation(summary = \"根据订单id获取订单状态\")\n@GetMapping(\"/getOrderStatus/{orderId}\")\npublic Result<Integer> getOrderStatus(@PathVariable Long orderId) {\n    return Result.ok(orderInfoService.getOrderStatus(orderId));\n}\n```\n\n- service\n```java\n@Override  \npublic Integer getOrderStatus(Long orderId) {  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId, orderId);  \n    wrapper.select(OrderInfo::getStatus);  \n  \n    OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);  \n  \n    if(orderInfo == null){  \n        return OrderStatus.NULL_ORDER.getStatus();  \n    }  \n    return orderInfo.getStatus();  \n}\n```\n\n- 远程调用\n```java\n/**\n * 根据订单id获取订单状态\n * @param orderId\n * @return\n */\n@GetMapping(\"/order/info/getOrderStatus/{orderId}\")\nResult<Integer> getOrderStatus(@PathVariable(\"orderId\") Long orderId);\n```\n\n### 远程调用\n\n#### 乘客端 web-customer\ncontroller\n```java\n@Operation(summary = \"查询订单状态\")  \n@LoginDetection  \n@GetMapping(\"/getOrderStatus/{orderId}\")  \npublic Result<Integer> getOrderStatus(@PathVariable Long orderId) {  \n    return Result.ok(orderService.getOrderStatus(orderId));  \n}\n```\n\nservice\n```java\n@Override\npublic Integer getOrderStatus(Long orderId) {\n    Result<Integer> integerResult = orderInfoFeignClient.getOrderStatus(orderId);\n    return integerResult.getData();\n}\n```\n\n#### 司机端 web-driver\ncontroller\n```java\n@Tag(name = \"订单API接口管理\")\n@RestController\n@RequestMapping(\"/order\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OrderController {\n\n    @Autowired\n    private OrderService orderService;\n    \n    @Operation(summary = \"查询订单状态\")\n    @GuiguLogin\n    @GetMapping(\"/getOrderStatus/{orderId}\")\n    public Result<Integer> getOrderStatus(@PathVariable Long orderId) {\n        return Result.ok(orderService.getOrderStatus(orderId));\n    }\n}\n```\n\nservice\n```java\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class OrderServiceImpl implements OrderService {\n\n    @Autowired\n    private OrderInfoFeignClient orderInfoFeignClient;\n\n    @Override\n    public Integer getOrderStatus(Long orderId) {\n        return orderInfoFeignClient.getOrderStatus(orderId).getData();\n    }\n}\n```\n\n# 乘客下单（二）\n\n## 搜索附件可以下单的司机\n\n### Redis的GEO功能\n\n- **GEOADD 添加位置信息\n\n```shell\nGEOADD zhangsan 116.403963 39.915119 tiananmen 116.417876 39.915411 wangfujing 116.404354 39.904748 qianmen\n```\n\n- **GEORADIUS 搜索范围以内消息\n\n```shell\nGEORADIUS zhangsan 116.4000 39.9000 1 km WITHDIST\n```\n## 实时更新司机的位置信息\n\n### 封装位置相关接口\n\nservice.service-map\n\ncontroller\n```java\n@Tag(name = \"位置API接口管理\")\n@RestController\n@RequestMapping(\"/map/location\")\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class LocationController {\n\n    @Autowired\n    private LocationService locationService;\n\n    //司机开启接单，更新司机位置信息\n    @Operation(summary = \"开启接单服务：更新司机经纬度位置\")\n    @PostMapping(\"/updateDriverLocation\")\n    public Result<Boolean> updateDriverLocation(@RequestBody\n                                                UpdateDriverLocationForm updateDriverLocationForm) {\n        Boolean flag = locationService.updateDriverLocation(updateDriverLocationForm);\n        return Result.ok(flag);\n    }\n\n    //司机关闭接单，删除司机位置信息\n    @Operation(summary = \"关闭接单服务：删除司机经纬度位置\")\n    @DeleteMapping(\"/removeDriverLocation/{driverId}\")\n    public Result<Boolean> removeDriverLocation(@PathVariable Long driverId) {\n        return Result.ok(locationService.removeDriverLocation(driverId));\n    }\n}\n```\n\nservice\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class LocationServiceImpl implements LocationService {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    // 更新司机位置信息\n    @Override\n    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) {\n        Point point = new Point(updateDriverLocationForm.getLongitude().doubleValue(),\n                updateDriverLocationForm.getLatitude().doubleValue());\n        redisTemplate.opsForGeo().add(RedisConstant.DRIVER_GEO_LOCATION,\n                                point,\n                                updateDriverLocationForm.getDriverId().toString());\n        return true;\n    }\n\n    // 删除司机位置信息\n    @Override\n    public Boolean removeDriverLocation(Long driverId) {\n        redisTemplate.opsForGeo().remove(RedisConstant.DRIVER_GEO_LOCATION,driverId.toString());\n        return true;\n    }\n}\n```\n\n### 远程调用定义\n\nservice-client.service-map-client\n\n```java\n@FeignClient(value = \"service-map\")\npublic interface LocationFeignClient {\n\n    /**\n     * 开启接单服务：更新司机经纬度位置\n     * @param updateDriverLocationForm\n     * @return\n     */\n    @PostMapping(\"/map/location/updateDriverLocation\")\n    Result<Boolean> updateDriverLocation(@RequestBody UpdateDriverLocationForm updateDriverLocationForm);\n\n    /**\n     * 关闭接单服务：删除司机经纬度位置\n     * @param driverId\n     * @return\n     */\n    @DeleteMapping(\"/map/location/removeDriverLocation/{driverId}\")\n    Result<Boolean> removeDriverLocation(@PathVariable(\"driverId\") Long driverId);\n}\n```\n\n### 司机web端\n\nweb.web-driver.controller\n\ncontroller\n```java\n@Slf4j  \n@Tag(name = \"位置API接口管理\")  \n@RestController  \n@RequestMapping(value=\"/location\")  \n@SuppressWarnings({\"unchecked\", \"rawtypes\"})  \npublic class LocationController {  \n  \n    @Autowired  \n    private LocationService locationService;  \n  \n    @Operation(summary = \"开启接单服务：更新司机经纬度位置\")  \n    @LoginDetection  \n    @PostMapping(\"/updateDriverLocation\")  \n    public Result<Boolean> updateDriverLocation(@RequestBody UpdateDriverLocationForm updateDriverLocationForm) {  \n        Long driverId = AuthContextHolder.getUserId();  \n        updateDriverLocationForm.setDriverId(driverId);  \n        return Result.ok(locationService.updateDriverLocation(updateDriverLocationForm));  \n    }  \n}\n```\n\nservice\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class LocationServiceImpl implements LocationService {\n\n    @Autowired\n    private LocationFeignClient locationFeignClient;\n\n    // 更新司机消息\n    @Override\n    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) {\n        Result<Boolean> booleanResult = locationFeignClient.updateDriverLocation(updateDriverLocationForm);\n        return booleanResult.getData();\n    }\n}\n```\n\n## 获取司机个性化设置信息\n\n### 封装查询司机个性化信息接口\n\nservice.service-driver.driver\n\ncontroller\n```java\n@Operation(summary = \"获取司机设置信息\")\n@GetMapping(\"/getDriverSet/{driverId}\")\npublic Result<DriverSet> getDriverSet(@PathVariable Long driverId) {\n\treturn Result.ok(driverInfoService.getDriverSet(driverId));\n}\n```\n\nservice\n```java\n@Override\npublic DriverSet getDriverSet(Long driverId) {\n\tLambdaQueryWrapper<DriverSet> wrapper = new LambdaQueryWrapper<>();\n\twrapper.eq(DriverSet::getDriverId, driverId);\n\tDriverSet driverSet = driverSetMapper.selectOne(wrapper);\n\treturn driverSet;\n}\n```\n\n### 远程调用\n\nservice-client.serivce-driver-client.DriverInfoFeignClient\n\n```java\n@GetMapping(\"/driver/info/getDriverSet/{driverId}\")  \nResult<DriverSet> getDriverSet(@PathVariable(\"driverId\") Long driverId);\n```\n\n### 修改司机web端\n\nweb.web-driver.controller\n\n```java\n@Slf4j\n@Service\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class LocationServiceImpl implements LocationService {\n\n    @Autowired\n    private LocationFeignClient locationFeignClient;\n\n    @Autowired\n    private DriverInfoFeignClient driverInfoFeignClient;\n\n    // 更新司机消息\n    @Override\n    public Boolean updateDriverLocation(UpdateDriverLocationForm updateDriverLocationForm) {\n        Long driverId = updateDriverLocationForm.getDriverId();\n        Result<DriverSet> driverSet = driverInfoFeignClient.getDriverSet(driverId);\n        DriverSet data = driverSet.getData();\n\n        if(data.getServiceStatus() == 1){\n            Result<Boolean> booleanResult = locationFeignClient.updateDriverLocation(updateDriverLocationForm);\n            return booleanResult.getData();\n        }else {\n            throw new GuiguException(ResultCodeEnum.NO_START_SERVICE);\n        }\n    }\n}\n```\n\n\n## 搜索附件适合接单的司机\n\n### 封装搜索接单司机接口\n\nservice-map.map\n\ncontroller\n```java\n@Operation(summary = \"搜索附近满足条件的司机\")\n@PostMapping(\"/searchNearByDriver\")\npublic Result<List<NearByDriverVo>> searchNearByDriver(@RequestBody\n\t\t\t\t\t\t\t\t\t\t\t\t\t   SearchNearByDriverForm searchNearByDriverForm) {\n\treturn Result.ok(locationService.searchNearByDriver(searchNearByDriverForm));\n}\n```\n\nservice\n```java\n//搜索附近满足条件的司机\n@Override\npublic List<NearByDriverVo> searchNearByDriver(SearchNearByDriverForm searchNearByDriverForm) {\n    //搜索经纬度位置5公里以内的司机\n    //1 操作redis里面geo\n    //创建point，经纬度位置\n    Point point = new Point(searchNearByDriverForm.getLongitude().doubleValue(),\n            searchNearByDriverForm.getLatitude().doubleValue());\n\n    //定义距离，5公里\n    Distance distance = new Distance(SystemConstant.NEARBY_DRIVER_RADIUS,\n                           RedisGeoCommands.DistanceUnit.KILOMETERS);\n\n    //创建circle对象，point  distance\n    Circle circle = new Circle(point,distance);\n\n    //定义GEO参数，设置返回结果包含内容\n    RedisGeoCommands.GeoRadiusCommandArgs args =\n            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()\n                    .includeDistance()  //包含距离\n                    .includeCoordinates() //包含坐标\n                    .sortAscending(); //升序\n\n    GeoResults<RedisGeoCommands.GeoLocation<String>> result =\n            redisTemplate.opsForGeo().radius(RedisConstant.DRIVER_GEO_LOCATION, circle, args);\n\n    //2 查询redis最终返回list集合\n    List<GeoResult<RedisGeoCommands.GeoLocation<String>>> content = result.getContent();\n\n    //3 对查询list集合进行处理\n    // 遍历list集合，得到每个司机信息\n    // 根据每个司机个性化设置信息判断\n    List<NearByDriverVo> list = new ArrayList<>();\n    if(!CollectionUtils.isEmpty(content)) {\n        Iterator<GeoResult<RedisGeoCommands.GeoLocation<String>>> iterator = content.iterator();\n        while(iterator.hasNext()) {\n            GeoResult<RedisGeoCommands.GeoLocation<String>> item = iterator.next();\n\n            //获取司机id\n            Long driverId = Long.parseLong(item.getContent().getName());\n\n            //远程调用，根据司机id个性化设置信息\n            Result<DriverSet> driverSetResult = driverInfoFeignClient.getDriverSet(driverId);\n            DriverSet driverSet = driverSetResult.getData();\n\n            //判断订单里程order_distance\n            BigDecimal orderDistance = driverSet.getOrderDistance();\n            //orderDistance==0，司机没有限制的\n            //如果不等于0 ，比如30，接单30公里代驾订单。\n            //接单距离 - 当前单子距离  < 0,不复合条件\n            // 30          35\n            if(orderDistance.doubleValue() != 0\n                    && orderDistance.subtract(searchNearByDriverForm.getMileageDistance()).doubleValue()<0) {\n                continue;\n            }\n\n            //判断接单里程 accept_distance\n            //当前接单距离\n            BigDecimal currentDistance =\n                    new BigDecimal(item.getDistance().getValue()).setScale(2, RoundingMode.HALF_UP);\n\n            BigDecimal acceptDistance = driverSet.getAcceptDistance();\n            if(acceptDistance.doubleValue() !=0\n            && acceptDistance.subtract(currentDistance).doubleValue()<0) {\n                continue;\n            }\n\n            //封装复合条件数据\n            NearByDriverVo nearByDriverVo = new NearByDriverVo();\n            nearByDriverVo.setDriverId(driverId);\n            nearByDriverVo.setDistance(currentDistance);\n            list.add(nearByDriverVo);\n\n        }\n\n    }\n    return list;\n}\n```\n\n## 接口测试\n\n* 启动相关服务\n\nservice-map 和 service-driver\n\n* 使用Swagger进行接口测试\n\nhttp://localhost:8503/doc.html#/home\n\n第一个接口测试用例及结果\n![[Pasted image 20250528233022.png]]\n\n发现错误来源于redis，开始排查\n\n排查成功，犯了两个很低级的错误\n- 测试错误接口\n- nacos没有改配置文件，导致redis连接不上\n\n再次测试为成功\n![[Pasted image 20250528233937.png]]\n\n第二个接口测试用例及结果\n![[Pasted image 20250528234733.png]]\n\n还是失败，挠头了，去看看报错是什么\n![[Pasted image 20250528235311.png]]\n\n空对象？ok啊，结合自己聪明的大脑以及一点外界帮助，得出原因是因为司机只有一个，但是却有三满足条件司机的数据，程序蒙了，不知道返回哪个\n\n解决方法是：因为是测试嘛，也不用太严谨，自己手动在数据库里面凭空产生点司机出来就行\n\n再次测试，成功\n![[Pasted image 20250528235542.png]]\n\n\n## 集成XXL-JOB\n\nservice.serivce-dispatch模块\n\n### 导入依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.xuxueli</groupId>\n        <artifactId>xxl-job-core</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### 执行器配置\n\n- 修改nacos配置文件 `service-dispatch-dev.yaml`\n\n- 创建XXL-JOB配置类\n```java\nimport com.xxl.job.core.executor.impl.XxlJobSpringExecutor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n  \n\n@Configuration\n\npublic class XxlJobConfig {\n\n    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);\n\n    @Value(\"${xxl.job.admin.addresses}\")\n    private String adminAddresses;\n\n    @Value(\"${xxl.job.accessToken}\")\n    private String accessToken;\n\n    @Value(\"${xxl.job.executor.appname}\")\n    private String appname;\n\n    @Value(\"${xxl.job.executor.address}\")\n    private String address;\n\n    @Value(\"${xxl.job.executor.ip}\")\n    private String ip;\n\n    @Value(\"${xxl.job.executor.port}\")\n    private int port;\n\n    @Value(\"${xxl.job.executor.logpath}\")\n    private String logPath;\n\n    @Value(\"${xxl.job.executor.logretentiondays}\")\n    private int logRetentionDays;\n\n    @Bean\n    public XxlJobSpringExecutor xxlJobExecutor() {\n        logger.info(\">>>>>>>>>>> xxl-job config init.\");\n        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();\n        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);\n        xxlJobSpringExecutor.setAppname(appname);\n        xxlJobSpringExecutor.setAddress(address);\n        xxlJobSpringExecutor.setIp(ip);\n        xxlJobSpringExecutor.setPort(port);\n        xxlJobSpringExecutor.setAccessToken(accessToken);\n        xxlJobSpringExecutor.setLogPath(logPath);\n        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);\n\n        return xxlJobSpringExecutor;\n    }\n}\n```\n\n### 编写任务job方法测试是否成功\n\n```java\n@Component\npublic class DispatchJobHandler {\n    \n    @XxlJob(\"firstJobHandler\")\n    public void testJobHandler() {\n        System.out.println(\"xxl-job项目集成测试\");\n    }\n}\n```\n\n\n### 测试\n\n第一步，启动相关服务\n\n- 调度中心\n- 执行器项目服务\n\n第二步，在调度中心创建任务\n\n第三步，启动任务\n\n测试的时候遇到点小问题：\n- 先运行调度中心再运行项目\n- 失败要留意xxl的错误日志，哪里有问题就删哪里\n\n\n## 封装XXL-JOB客户端\n\n### 调度中心创建任务方法\n\n在xxl-job-admin中的controller中创建\n\nJobInfoController把原来的添加删除修改任务替换\n```java\n\t//自定义任务操作的方法\n\t//添加任务\n\t@RequestMapping(\"/addJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> addJobInfo(@RequestBody XxlJobInfo jobInfo) {\n\t\treturn xxlJobService.add(jobInfo);\n\t}\n\n\t//删除任务\n\t@RequestMapping(\"/removeJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> removeJob(@RequestBody XxlJobInfo jobInfo) {\n\t\treturn xxlJobService.remove(jobInfo.getId());\n\t}\n\n\t//修改任务\n\t@RequestMapping(\"/updateJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> updateJob(@RequestBody XxlJobInfo jobInfo) {\n\t\treturn xxlJobService.update(jobInfo);\n\t}\n\n\t//停止任务\n\t@RequestMapping(\"/stopJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> pauseJob(@RequestBody XxlJobInfo jobInfo) {\n\t\treturn xxlJobService.stop(jobInfo.getId());\n\t}\n\n\t//启动任务\n\t@RequestMapping(\"/startJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> startJob(@RequestBody XxlJobInfo jobInfo) {\n\t\treturn xxlJobService.start(jobInfo.getId());\n\t}\n\n\t//添加并启动任务\n\t@RequestMapping(\"/addAndStartJob\")\n\t@ResponseBody\n\t@PermissionLimit(limit = false)\n\tpublic ReturnT<String> addAndStartJob(@RequestBody XxlJobInfo jobInfo) {\n\t\tReturnT<String> result = xxlJobService.add(jobInfo);\n\n\t\tString content = result.getContent();\n\t\tint id = Integer.parseInt(content);\n\t\txxlJobService.start(id);\n\n\t\t//立即执行一次\n\t\tJobTriggerPoolHelper.trigger(id, TriggerTypeEnum.MANUAL, -1, null, jobInfo.getExecutorParam(), \"\");\n\t\treturn result;\n\t}\n```\n\n\n### 执行器项目配置文件添加任务方法\n\n- 修改nacos配置文件 `service-dispatch-dev.yaml`\n- 在job.admin下\n```yml\nclient:\n  jobGroupId: 1\n  addUrl: ${xxl.job.admin.addresses}/jobinfo/addJob\n  removeUrl: ${xxl.job.admin.addresses}/jobinfo/removeJob\n  startJobUrl: ${xxl.job.admin.addresses}/jobinfo/startJob\n  stopJobUrl: ${xxl.job.admin.addresses}/jobinfo/stopJob\n  addAndStartUrl: ${xxl.job.admin.addresses}/jobinfo/addAndStartJob\n```\n\n### 添加相关配置类service-dispatch\n\n- 创建配置类，读取配置文件里面的调用的调度中心的操作方法\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"xxl.job.client\")\npublic class XxlJobClientConfig {\n\n    private Integer jobGroupId;\n    private String addUrl;\n    private String removeUrl;\n    private String startJobUrl;\n    private String stopJobUrl;\n    private String addAndStartUrl;\n}\n```\n\n* 创建客户端类，编写调用调度中心里面的方法\n```java\nimport com.alibaba.fastjson.JSONObject;\nimport com.atguigu.daijia.common.execption.GuiguException;\nimport com.atguigu.daijia.common.result.ResultCodeEnum;\nimport com.atguigu.daijia.dispatch.xxl.config.XxlJobClientConfig;\nimport com.atguigu.daijia.model.entity.dispatch.XxlJobInfo;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\n\n@Slf4j\n@Component\npublic class XxlJobClient {\n\n    @Autowired\n    private XxlJobClientConfig xxlJobClientConfig;\n\n    //客户端调用服务端里面的方法\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @SneakyThrows\n    public Long addJob(String executorHandler, String param, String corn, String desc){\n        XxlJobInfo xxlJobInfo = new XxlJobInfo();\n        xxlJobInfo.setJobGroup(xxlJobClientConfig.getJobGroupId());\n        xxlJobInfo.setJobDesc(desc);\n        xxlJobInfo.setAuthor(\"qy\");\n        xxlJobInfo.setScheduleType(\"CRON\");\n        xxlJobInfo.setScheduleConf(corn);\n        xxlJobInfo.setGlueType(\"BEAN\");\n        xxlJobInfo.setExecutorHandler(executorHandler);\n        xxlJobInfo.setExecutorParam(param);\n        xxlJobInfo.setExecutorRouteStrategy(\"FIRST\");\n        xxlJobInfo.setExecutorBlockStrategy(\"SERIAL_EXECUTION\");\n        xxlJobInfo.setMisfireStrategy(\"FIRE_ONCE_NOW\");\n        xxlJobInfo.setExecutorTimeout(0);\n        xxlJobInfo.setExecutorFailRetryCount(0);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<XxlJobInfo> request = new HttpEntity<>(xxlJobInfo, headers);\n\n        String url = xxlJobClientConfig.getAddUrl();\n        ResponseEntity<JSONObject> response =\n                restTemplate.postForEntity(url, request, JSONObject.class);\n\n        if(response.getStatusCode().value() == 200 && response.getBody().getIntValue(\"code\") == 200) {\n            log.info(\"增加xxl执行任务成功,返回信息:{}\", response.getBody().toJSONString());\n            //content为任务id\n            return response.getBody().getLong(\"content\");\n        }\n        log.info(\"调用xxl增加执行任务失败:{}\", response.getBody().toJSONString());\n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n    }\n\n    public Boolean startJob(Long jobId) {\n        XxlJobInfo xxlJobInfo = new XxlJobInfo();\n        xxlJobInfo.setId(jobId.intValue());\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<XxlJobInfo> request = new HttpEntity<>(xxlJobInfo, headers);\n\n        String url = xxlJobClientConfig.getStartJobUrl();\n        ResponseEntity<JSONObject> response = restTemplate.postForEntity(url, request, JSONObject.class);\n        if(response.getStatusCode().value() == 200 && response.getBody().getIntValue(\"code\") == 200) {\n            log.info(\"启动xxl执行任务成功:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n            return true;\n        }\n        log.info(\"启动xxl执行任务失败:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n    }\n\n    public Boolean stopJob(Long jobId) {\n        XxlJobInfo xxlJobInfo = new XxlJobInfo();\n        xxlJobInfo.setId(jobId.intValue());\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<XxlJobInfo> request = new HttpEntity<>(xxlJobInfo, headers);\n\n        String url = xxlJobClientConfig.getStopJobUrl();\n        ResponseEntity<JSONObject> response = restTemplate.postForEntity(url, request, JSONObject.class);\n        if(response.getStatusCode().value() == 200 && response.getBody().getIntValue(\"code\") == 200) {\n            log.info(\"停止xxl执行任务成功:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n            return true;\n        }\n        log.info(\"停止xxl执行任务失败:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n    }\n\n    public Boolean removeJob(Long jobId) {\n        XxlJobInfo xxlJobInfo = new XxlJobInfo();\n        xxlJobInfo.setId(jobId.intValue());\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<XxlJobInfo> request = new HttpEntity<>(xxlJobInfo, headers);\n\n        String url = xxlJobClientConfig.getRemoveUrl();\n        ResponseEntity<JSONObject> response = restTemplate.postForEntity(url, request, JSONObject.class);\n        if(response.getStatusCode().value() == 200 && response.getBody().getIntValue(\"code\") == 200) {\n            log.info(\"删除xxl执行任务成功:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n            return true;\n        }\n        log.info(\"删除xxl执行任务失败:{},返回信息:{}\", jobId, response.getBody().toJSONString());\n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n    }\n\n    //添加并启动任务\n    public Long addAndStart(String executorHandler, String param, String corn, String desc) {\n        XxlJobInfo xxlJobInfo = new XxlJobInfo();\n        xxlJobInfo.setJobGroup(xxlJobClientConfig.getJobGroupId());\n        xxlJobInfo.setJobDesc(desc);\n        xxlJobInfo.setAuthor(\"qy\");\n        xxlJobInfo.setScheduleType(\"CRON\");\n        xxlJobInfo.setScheduleConf(corn);\n        xxlJobInfo.setGlueType(\"BEAN\");\n        xxlJobInfo.setExecutorHandler(executorHandler);\n        xxlJobInfo.setExecutorParam(param);\n        xxlJobInfo.setExecutorRouteStrategy(\"FIRST\");\n        xxlJobInfo.setExecutorBlockStrategy(\"SERIAL_EXECUTION\");\n        xxlJobInfo.setMisfireStrategy(\"FIRE_ONCE_NOW\");\n        xxlJobInfo.setExecutorTimeout(0);\n        xxlJobInfo.setExecutorFailRetryCount(0);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<XxlJobInfo> request = new HttpEntity<>(xxlJobInfo, headers);\n\n        //获取调度中心请求路径\n        String url = xxlJobClientConfig.getAddAndStartUrl();\n\n        //restTemplate\n        ResponseEntity<JSONObject> response = restTemplate.postForEntity(url, request, JSONObject.class);\n        if(response.getStatusCode().value() == 200 && response.getBody().getIntValue(\"code\") == 200) {\n            log.info(\"增加并开始执行xxl任务成功,返回信息:{}\", response.getBody().toJSONString());\n            //content为任务id\n            return response.getBody().getLong(\"content\");\n        }\n        log.info(\"增加并开始执行xxl任务失败:{}\", response.getBody().toJSONString());\n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);\n    }\n}\n```\n\n### 启动类配置RestTemplate\n\n直接把RestTemplate写在启动类里\n```java\n@SpringBootApplication  \n@EnableDiscoveryClient  \n@EnableFeignClients  \npublic class ServiceDispatchApplication {  \n  \n    public static void main(String[] args) {  \n        SpringApplication.run(ServiceDispatchApplication.class, args);  \n    }  \n  \n    @Bean  \n    public RestTemplate restTemplate() {  \n        return new RestTemplate();  \n    }  \n}\n```\n\n## 创建并启动任务接口\n\nservice-dispatch\n\ncontroller\n```java\n// 创建并启动任务调度方法\n@Operation(summary = \"添加并开始新订单任务调度\")\n@PostMapping(\"/addAndStartTask\")\npublic Result<Long> addAndStartTask(@RequestBody NewOrderTaskVo newOrderTaskVo) {\n\tLong id = newOrderService.addAndStartTask(newOrderTaskVo);\n\treturn Result.ok(id);\n}\n```\n\nservice\n```java\n// 添加并开始新订单任务调度\n@Override\npublic Long addAndStartTask(NewOrderTaskVo newOrderTaskVo) {\n\t// 判断当前订单是否开启任务调度\n\tLambdaQueryWrapper<OrderJob> wrapper = new LambdaQueryWrapper<>();\n\twrapper.eq(OrderJob::getOrderId, newOrderTaskVo.getOrderId());\n\tOrderJob orderJob = orderJobMapper.selectOne(wrapper);\n\n\t// 没有启动，进行操作\n\tif(orderJob == null){\n\t\t//创建并启动任务调度\n\t\t//String executorHandler 执行任务job方法\n\t\t// String param\n\t\t// String corn 执行cron表达式\n\t\t// String desc 描述信息\n\t\tLong id = xxlJobClient.addAndStart(\"newOrderTaskHandler\",\n\t\t\t\t\"\", \"0 0/1 * * * ?\",\n\t\t\t\t\"新创建订单任务调度：\" + newOrderTaskVo.getOrderId());\n\n\t\torderJob = new OrderJob();\n\t\torderJob.setOrderId(newOrderTaskVo.getOrderId());\n\t\torderJob.setJobId(id);\n\t\torderJob.setParameter(JSONObject.toJSONString(newOrderTaskVo));\n\n\t\torderJobMapper.insert(orderJob);\n\t}\n\n\treturn orderJob.getJobId();\n}\n```\n\n### 远程调用\n\nservice-client\nservice-dispatch-client\n```java\n@FeignClient(value = \"service-dispatch\")\npublic interface NewOrderFeignClient {\n\n    /**\n     * 添加新订单任务\n     * @param newOrderDispatchVo\n     * @return\n     */\n    @PostMapping(\"/dispatch/newOrder/addAndStartTask\")\n    Result<Long> addAndStartTask(@RequestBody NewOrderTaskVo newOrderDispatchVo);\n}\n```\n\n\n## 开发具体任务job方法\n\nJobHandler\n```java\npublic class JobHandler {\n\n    @Autowired\n    private XxlJobLogMapper xxlJobLogMapper;\n    \n    @Autowired\n    private NewOrderService newOrderService;\n    \n    @XxlJob(\"newOrderTaskHandler\")\n    public void newOrderTaskHandler() {\n\n        //记录任务调度日志\n        XxlJobLog xxlJobLog = new XxlJobLog();\n        xxlJobLog.setJobId(XxlJobHelper.getJobId());\n        long startTime = System.currentTimeMillis();\n\n        try {\n            //执行任务：搜索附近代驾司机\n            newOrderService.executeTask(XxlJobHelper.getJobId());\n\n            //成功状态\n            xxlJobLog.setStatus(1);\n        } catch (Exception e) {\n            //失败状态\n            xxlJobLog.setStatus(0);\n            xxlJobLog.setError(e.getMessage());\n            e.printStackTrace();\n        } finally {\n            long times = System.currentTimeMillis()- startTime;\n            //TODO 完善long\n            xxlJobLog.setTimes((int)times);\n            xxlJobLogMapper.insert(xxlJobLog);\n        }\n    }\n}\n```\n\n- 远程调用\nservice-driver-client\nLocationFeignClient\n```java\n    // 搜索附近满足条件的司机\n    @PostMapping(\"/map/location/searchNearByDriver\")\n    public Result<List<NearByDriverVo>> searchNearByDriver(@RequestBody SearchNearByDriverForm searchNearByDriverForm);\n```\n\nservice-dispatch\nNewOrderServiceImpl\n```java\n@Autowired\nprivate LocationFeignClient locationFeignClient;\n\n@Autowired\nprivate OrderInfoFeignClient orderInfoFeignClient;\n\n@Autowired\nprivate RedisTemplate redisTemplate;\n\n// 搜索附件司机\n@Override\npublic void executeTask(long jobId) {\n\t// 根据jobid查询当前任务是否已经创建\n\tLambdaQueryWrapper<OrderJob> wrapper = new LambdaQueryWrapper<>();\n\twrapper.eq(OrderJob::getJobId, jobId);\n\tOrderJob orderJob = orderJobMapper.selectOne(wrapper);\n\tif(orderJob == null){\n\t\treturn;\n\t}\n\t// 查询订单状态，如果是接单状态，继续执行，否则停止\n\tString parameter = orderJob.getParameter();\n\tNewOrderTaskVo newOrderTaskVo = JSONObject.parseObject(parameter, NewOrderTaskVo.class);\n\tInteger status = orderInfoFeignClient.getOrderStatus(newOrderTaskVo.getOrderId()).getData();\n\n\tif(status.intValue() != OrderStatus.WAITING_ACCEPT.getStatus().intValue()){\n\t\txxlJobClient.stopJob(jobId);\n\t\treturn;\n\t}\n\t// 远程调用，查询正在接单的司机集合\n\tSearchNearByDriverForm from = new SearchNearByDriverForm();\n\tSearchNearByDriverForm searchNearByDriverForm = new SearchNearByDriverForm();\n\tsearchNearByDriverForm.setLongitude(newOrderTaskVo.getStartPointLongitude());\n\tsearchNearByDriverForm.setLatitude(newOrderTaskVo.getStartPointLatitude());\n\tList<NearByDriverVo> result = locationFeignClient.searchNearByDriver(from).getData();\n\n\t// 遍历满足条件的司机集合，为每个司机创建临时队列，存储新订单信息\n\tresult.forEach(driver -> {\n\t\tString repeatKey =\n\t\t\t\tRedisConstant.DRIVER_ORDER_REPEAT_LIST+newOrderTaskVo.getOrderId();\n\t\tBoolean isMember = redisTemplate.opsForSet().isMember(repeatKey, driver.getDriverId());\n\t\tif(!isMember){\n\t\t\t// 把订单信息推送刚给满足条件的司机\n\t\t\tredisTemplate.opsForSet().add(parameter, driver.getDriverId());\n\t\t\t// 设置过期时间15分钟(一分钟等待)\n\t\t\tredisTemplate.expire(repeatKey,\n\t\t\t\t\tRedisConstant.DRIVER_ORDER_REPEAT_LIST_EXPIRES_TIME,\n\t\t\t\t\tTimeUnit.MINUTES);\n\n\t\t\tNewOrderDataVo newOrderDataVo = new NewOrderDataVo();\n\t\t\tnewOrderDataVo.setOrderId(newOrderTaskVo.getOrderId());\n\t\t\tnewOrderDataVo.setStartLocation(newOrderTaskVo.getStartLocation());\n\t\t\tnewOrderDataVo.setEndLocation(newOrderTaskVo.getEndLocation());\n\t\t\tnewOrderDataVo.setExpectAmount(newOrderTaskVo.getExpectAmount());\n\t\t\tnewOrderDataVo.setExpectDistance(newOrderTaskVo.getExpectDistance());\n\t\t\tnewOrderDataVo.setExpectTime(newOrderTaskVo.getExpectTime());\n\t\t\tnewOrderDataVo.setFavourFee(newOrderTaskVo.getFavourFee());\n\t\t\tnewOrderDataVo.setDistance(driver.getDistance());\n\t\t\tnewOrderDataVo.setCreateTime(newOrderTaskVo.getCreateTime());\n\t\t\t// 新订单保存司机的临时队列\n\t\t\tString key = RedisConstant.DRIVER_ORDER_TEMP_LIST+driver.getDriverId();\n\t\t\tredisTemplate.opsForList().leftPush(key, JSONObject.toJSONString(newOrderDataVo));\n\t\t\t// 设置过期时间，一分钟\n\t\t\tredisTemplate.expire(key, RedisConstant.DRIVER_ORDER_TEMP_LIST_EXPIRES_TIME, TimeUnit.MINUTES);\n\t\t}\n\t});\n}\n```\n\n## 乘客下单添加任务调度\n\nweb-customer\n补充之前OrderServiceImpl里写的查询附近可以接单司机\n```java\n@Autowired  \nprivate NewOrderFeignClient newOrderFeignClient;\n\n@Override\npublic Long submitOrder(SubmitOrderForm submitOrderForm) {\n\t//1 重新计算驾驶线路\n\tCalculateDrivingLineForm calculateDrivingLineForm = new CalculateDrivingLineForm();\n\tBeanUtils.copyProperties(submitOrderForm,submitOrderForm);\n\tResult<DrivingLineVo> drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);\n\tDrivingLineVo drivingLineVo = drivingLineVoResult.getData();\n\n\t//2 重新订单费用\n\tFeeRuleRequestForm calculateOrderFeeForm = new FeeRuleRequestForm();\n\tcalculateOrderFeeForm.setDistance(drivingLineVo.getDistance());\n\tcalculateOrderFeeForm.setStartTime(new Date());\n\tcalculateOrderFeeForm.setWaitMinute(0);\n\tResult<FeeRuleResponseVo> feeRuleResponseVoResult = feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm);\n\tFeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoResult.getData();\n\n\t//封装数据\n\tOrderInfoForm orderInfoForm = new OrderInfoForm();\n\tBeanUtils.copyProperties(submitOrderForm,orderInfoForm);\n\torderInfoForm.setExpectDistance(drivingLineVo.getDistance());\n\torderInfoForm.setExpectAmount(feeRuleResponseVo.getTotalAmount());\n\tResult<Long> orderInfoResult = orderInfoFeignClient.saveOrderInfo(orderInfoForm);\n\tLong orderId = orderInfoResult.getData();\n\n\t// 任务调度：查询附近可以接单司机\n\tNewOrderTaskVo newOrderTaskVo = new NewOrderTaskVo();\n\tnewOrderTaskVo.setOrderId(orderId);\n\tnewOrderTaskVo.setStartLocation(orderInfoForm.getStartLocation());\n\tnewOrderTaskVo.setStartPointLongitude(orderInfoForm.getStartPointLongitude());\n\tnewOrderTaskVo.setStartPointLatitude(orderInfoForm.getStartPointLatitude());\n\tnewOrderTaskVo.setEndLocation(orderInfoForm.getEndLocation());\n\tnewOrderTaskVo.setEndPointLongitude(orderInfoForm.getEndPointLongitude());\n\tnewOrderTaskVo.setEndPointLatitude(orderInfoForm.getEndPointLatitude());\n\tnewOrderTaskVo.setExpectAmount(orderInfoForm.getExpectAmount());\n\tnewOrderTaskVo.setExpectDistance(orderInfoForm.getExpectDistance());\n\tnewOrderTaskVo.setExpectTime(drivingLineVo.getDuration());\n\tnewOrderTaskVo.setFavourFee(orderInfoForm.getFavourFee());\n\tnewOrderTaskVo.setCreateTime(new Date());\n\tLong jobId = newOrderFeignClient.addAndStartTask(newOrderTaskVo).getData();\n\n\treturn orderId;\n}\n```\n\n## 司机获取最新订单数据\n\nservice-dispatch\n\n### 查询最新订单和清空司机队列数据\n\nNewOrderController\n```java\n@Operation(summary = \"查询司机新订单数据\")\n@GetMapping(\"/findNewOrderQueueData/{driverId}\")\npublic Result<List<NewOrderDataVo>> findNewOrderQueueData(@PathVariable Long driverId) {\n\treturn Result.ok(newOrderService.findNewOrderQueueData(driverId));\n}\n\n@Operation(summary = \"清空新订单队列数据\")\n@GetMapping(\"/clearNewOrderQueueData/{driverId}\")\npublic Result<Boolean> clearNewOrderQueueData(@PathVariable Long driverId) {\n\treturn Result.ok(newOrderService.clearNewOrderQueueData(driverId));\n}\n```\n\nNewOrderServiceImpl\n```java\n//获取最新订单\n@Override\npublic List<NewOrderDataVo> findNewOrderQueueData(Long driverId) {\n    List<NewOrderDataVo> list = new ArrayList<>();\n    String key = RedisConstant.DRIVER_ORDER_TEMP_LIST + driverId;\n    Long size = redisTemplate.opsForList().size(key);\n    if(size > 0) {\n        for (int i = 0; i < size; i++) {\n            String content = (String)redisTemplate.opsForList().leftPop(key);\n            NewOrderDataVo newOrderDataVo = JSONObject.parseObject(content,NewOrderDataVo.class);\n            list.add(newOrderDataVo);\n        }\n    }\n    return list;\n}\n\n//清空队列数据\n@Override\npublic Boolean clearNewOrderQueueData(Long driverId) {\n    String key = RedisConstant.DRIVER_ORDER_TEMP_LIST + driverId;\n    redisTemplate.delete(key);\n    return true;\n}\n```\n\n### 远程调用\n\nservice-dispatch\n\nNewOrderFeignClient\n\n```java\n// 查询司机新订单数据\n@GetMapping(\"/dispatch/newOrder/findNewOrderQueueData/{driverId}\")\nResult<List<NewOrderDataVo>> findNewOrderQueueData(@PathVariable(\"driverId\") Long driverId);\n\n// 清空新订单队列数据\n@GetMapping(\"/dispatch/newOrder/clearNewOrderQueueData/{driverId}\")\nResult<Boolean> clearNewOrderQueueData(@PathVariable(\"driverId\") Long driverId);\n```\n\n### 司机web端调用\n\nOrderController\n```java\n@Operation(summary = \"查询司机新订单数据\")  \n@LoginDetection  \n@GetMapping(\"/findNewOrderQueueData\")  \npublic Result<List<NewOrderDataVo>> findNewOrderQueueData() {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.findNewOrderQueueData(driverId));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate NewOrderFeignClient newOrderFeignClient;\n\n@Override  \npublic List<NewOrderDataVo> findNewOrderQueueData(Long driverId) {  \n    return newOrderFeignClient.findNewOrderQueueData(driverId).getData();  \n}\n```\n\n# 司机接单\n\n## 需求\n\n- 乘客下单后，新订单信息已经放在司机临时队列，然后可以开始接单了\n\n首先，司机登录、认证（身份证、驾驶证、创建人脸模型）\n第二，司机每天接单前都需要人脸识别\n第三，司机开始接单，更新接单状态\n第四，司机接单后，删除司机之前存储在redis里面的位置信息\n第五，司机接单后，清空临时队列新订单信息\n\n## 查找司机端当前订单\n\n设定是接单去需要验证司机是否有未完成的订单，暂时不管\n\n* 后续完成，暂时跳过\n\n```java\n@Operation(summary = \"查找司机端当前订单\")  \n@LoginDetection  \n@GetMapping(\"/searchDriverCurrentOrder\")  \npublic Result<CurrentOrderInfoVo> searchDriverCurrentOrder() {  \n    CurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();  \n    // TODO 后续完善  \n    currentOrderInfoVo.setIsHasCurrentOrder(false);  \n    return Result.ok(currentOrderInfoVo);  \n}\n```\n\n## 判断司机在当日是否人脸识别\n\n### service-driver\n\nDriverInfoController\n```java\n@Operation(summary = \"判断司机当日是否进行过人脸识别\")  \n@GetMapping(\"/isFaceRecognition/{driverId}\")  \nResult<Boolean> isFaceRecognition(@PathVariable(\"driverId\") Long driverId) {  \n    return Result.ok(driverInfoService.isFaceRecognition(driverId));  \n}\n```\n\nservice\n```java\n// 判断司机当日是否进行过人脸识别  \n@Override  \npublic Boolean isFaceRecognition(Long driverId) {  \n    //根据司机id + 当日日期进行查询  \n    LambdaQueryWrapper<DriverFaceRecognition> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(DriverFaceRecognition::getDriverId,driverId);  \n    // 年-月-日 格式  \n    wrapper.eq(DriverFaceRecognition::getFaceDate,new DateTime().toString(\"yyyy-MM-dd\"));  \n    //调用mapper方法  \n    Long count = driverFaceRecognitionMapper.selectCount(wrapper);  \n  \n    return count != 0;  \n}\n```\n\n远程调用\n\nDriverInfoFeignClient\n```java\n// 判断司机当日是否进行过人脸识别  \n@GetMapping(\"/driver/info/isFaceRecognition/{driverId}\")  \nResult<Boolean> isFaceRecognition(@PathVariable(\"driverId\") Long driverId);\n```\n\n\n### web端调用\n\nDriverController\n```java\n@Operation(summary = \"判断司机当日是否进行过人脸识别\")  \n@LoginDetection  \n@GetMapping(\"/isFaceRecognition\")  \nResult<Boolean> isFaceRecognition() {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(driverService.isFaceRecognition(driverId));  \n}\n```\n\nservice\n```java\n// 判断司机当日是否进行过人脸识别  \n@Override  \npublic Boolean isFaceRecognition(Long driverId) {  \n    Result<Boolean> faceRecognition = driverInfoFeignClient.isFaceRecognition(driverId);  \n    return faceRecognition.getData();  \n}\n```\n\n## 人脸识别接口\n\n* 进行人脸识别，基于腾讯云实现\n* 之前创建人脸识别模型，基于之前创建人脸模型完成当前识别功能\n* 找到腾讯云文档1：照片比对\nhttps://console.cloud.tencent.com/api/explorer?Product=iai&Version=2020-03-03&Action=VerifyFace\n\n* 找到腾讯云文档2：人脸静态活体检测\nhttps://console.cloud.tencent.com/api/explorer?Product=iai&Version=2020-03-03&Action=DetectLiveFace\n\n\n### service-driver\n\nDriverInfoController\n```java\n@Operation(summary = \"验证司机人脸\")\n@PostMapping(\"/verifyDriverFace\")\npublic Result<Boolean> verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm) {\n    return Result.ok(driverInfoService.verifyDriverFace(driverFaceModelForm));\n}\n```\n\nservice\n```java\n// 验证司机人脸  \n@Override  \npublic Boolean verifyDriverFace(DriverFaceModelForm driverFaceModelForm) {  \n    // 照片比对  \n    try{  \n        // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密  \n        // 代码泄露可能会导致 SecretId 和 SecretKey 泄露，并威胁账号下所有资源的安全性  \n        // 以下代码示例仅供参考，建议采用更安全的方式来使用密钥  \n        // 请参见：https://cloud.tencent.com/document/product/1278/85305  \n        // 密钥可前往官网控制台 https://console.cloud.tencent.com/cam/capi 进行获取  \n        Credential cred = new Credential(tencentCloudProperties.getSecretId(),  \n                tencentCloudProperties.getSecretKey());  \n        // 使用临时密钥示例  \n        // Credential cred = new Credential(\"SecretId\", \"SecretKey\", \"Token\");  \n        // 实例化一个http选项，可选的，没有特殊需求可以跳过  \n        HttpProfile httpProfile = new HttpProfile();  \n        httpProfile.setEndpoint(\"iai.tencentcloudapi.com\");  \n        // 实例化一个client选项，可选的，没有特殊需求可以跳过  \n        ClientProfile clientProfile = new ClientProfile();  \n        clientProfile.setHttpProfile(httpProfile);  \n  \n        // 实例化要请求产品的client对象,clientProfile是可选的  \n        IaiClient client = new IaiClient(cred,  \n                tencentCloudProperties.getRegion(), clientProfile);  \n        // 实例化一个请求对象,每个接口都会对应一个request对象  \n        VerifyFaceRequest req = new VerifyFaceRequest();  \n        // 设置相关参数  \n        req.setImage(driverFaceModelForm.getImageBase64());  \n        req.setPersonId(String.valueOf(driverFaceModelForm.getDriverId()));  \n  \n        // 返回的resp是一个VerifyFaceResponse的实例，与请求对象对应  \n        VerifyFaceResponse resp = client.VerifyFace(req);  \n        // 输出json格式的字符串回包  \n        System.out.println(AbstractModel.toJsonString(resp));  \n        if(resp.getIsMatch()){  \n            // 静态活体检测  \n            Boolean isSuccess = this.detectLiveFace(driverFaceModelForm.getImageBase64());  \n            if(isSuccess){  \n                // 都没问题，添加塑胶到认证表中  \n                DriverFaceRecognition driverFaceRecognition = new DriverFaceRecognition();  \n                driverFaceRecognition.setDriverId(driverFaceModelForm.getDriverId());  \n                driverFaceRecognition.setFaceDate(new Date());  \n                driverFaceRecognitionMapper.insert(driverFaceRecognition);  \n                return true;  \n            }  \n        }  \n    } catch (TencentCloudSDKException e) {  \n        System.out.println(e.toString());  \n    }  \n  \n    throw new GuiguException(ResultCodeEnum.DATA_ERROR);  \n}  \n  \n//人脸静态活体检测  \nprivate Boolean detectLiveFace(String imageBase64) {  \n    try{  \n        // 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密  \n        // 代码泄露可能会导致 SecretId 和 SecretKey 泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考，建议采用更安全的方式来使用密钥，请参见：https://cloud.tencent.com/document/product/1278/85305  \n        // 密钥可前往官网控制台 https://console.cloud.tencent.com/cam/capi 进行获取  \n        Credential cred = new Credential(tencentCloudProperties.getSecretId(),  \n                tencentCloudProperties.getSecretKey());  \n        // 实例化一个http选项，可选的，没有特殊需求可以跳过  \n        HttpProfile httpProfile = new HttpProfile();  \n        httpProfile.setEndpoint(\"iai.tencentcloudapi.com\");  \n        // 实例化一个client选项，可选的，没有特殊需求可以跳过  \n        ClientProfile clientProfile = new ClientProfile();  \n        clientProfile.setHttpProfile(httpProfile);  \n        // 实例化要请求产品的client对象,clientProfile是可选的  \n        IaiClient client = new IaiClient(cred, tencentCloudProperties.getRegion(),  \n                clientProfile);  \n        // 实例化一个请求对象,每个接口都会对应一个request对象  \n        DetectLiveFaceRequest req = new DetectLiveFaceRequest();  \n        req.setImage(imageBase64);  \n        // 返回的resp是一个DetectLiveFaceResponse的实例，与请求对象对应  \n        DetectLiveFaceResponse resp = client.DetectLiveFace(req);  \n        // 输出json格式的字符串回包  \n        System.out.println(DetectLiveFaceResponse.toJsonString(resp));  \n        if(resp.getIsLiveness()) {  \n            return true;  \n        }  \n    } catch (TencentCloudSDKException e) {  \n        System.out.println(e.toString());  \n    }  \n    return false;  \n}\n```\n\n### 远程调用 service-driver-client\n\nDriverInfoFeignClient\n```java\n// 验证司机人脸  \n@PostMapping(\"/driver/info/verifyDriverFace\")  \nResult<Boolean> verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm);\n```\n\n### web-driver\n\nDriverController\n```java\n@Operation(summary = \"验证司机人脸\")  \n@LoginDetection  \n@PostMapping(\"/verifyDriverFace\")  \npublic Result<Boolean> verifyDriverFace(@RequestBody DriverFaceModelForm driverFaceModelForm) {  \n    driverFaceModelForm.setDriverId(AuthContextHolder.getUserId());  \n    return Result.ok(driverService.verifyDriverFace(driverFaceModelForm));  \n}\n```\n\nservice\n```java\n// 验证司机人脸  \n@Override  \npublic Boolean verifyDriverFace(DriverFaceModelForm driverFaceModelForm) {  \n    Result<Boolean> booleanResult = driverInfoFeignClient.verifyDriverFace(driverFaceModelForm);  \n    return booleanResult.getData();  \n}\n```\n\n\n## 更新司机接单状态\n\nDriverInfoController\n```java\n@Operation(summary = \"更新接单状态\")  \n@GetMapping(\"/updateServiceStatus/{driverId}/{status}\")  \npublic Result<Boolean> updateServiceStatus(@PathVariable Long driverId, @PathVariable Integer status) {  \n    return Result.ok(driverInfoService.updateServiceStatus(driverId, status));  \n}\n```\n\nservice\n```java\n@Override  \npublic Boolean updateServiceStatus(Long driverId, Integer status) {  \n    LambdaQueryWrapper<DriverSet> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(DriverSet::getDriverId,driverId);  \n    DriverSet driverSet = new DriverSet();  \n    driverSet.setServiceStatus(status);  \n    driverSetMapper.update(driverSet,wrapper);  \n    return true;  \n}\n```\n\n远程调用DriverInfoFeignClient\n```java\n// 更新接单状态  \n@GetMapping(\"/driver/info/updateServiceStatus/{driverId}/{status}\")  \nResult<Boolean> updateServiceStatus(@PathVariable(\"driverId\") Long driverId, @PathVariable(\"status\") Integer status);\n```\n\n## 开启接单服务web接口\n\n在web-driver中进行编写\n\n司机开启接单后，上传位置信息到redis的GEO，才能被任务调度搜索到司机信息，开始抢单\n\n### DriverController\n\n```java\n@Operation(summary = \"开始接单服务\")  \n@LoginDetection  \n@GetMapping(\"/startService\")  \npublic Result<Boolean> startService() {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(driverService.startService(driverId));  \n}\n```\n\n### DriverServiceImpl\n\n```java\n@Autowired  \nprivate LocationFeignClient locationFeignClient;  \n  \n@Autowired  \nprivate NewOrderFeignClient newOrderFeignClient;\n\n// 开始接单服务  \n@Override  \npublic Boolean startService(Long driverId) {  \n    //1 判断完成认证  \n    DriverLoginVo driverLoginVo = driverInfoFeignClient.getDriverLoginInfo(driverId).getData();  \n    if(driverLoginVo.getAuthStatus()!=2) {  \n        throw new GuiguException(ResultCodeEnum.AUTH_ERROR);  \n    }  \n  \n    //2 判断当日是否人脸识别  \n    Boolean isFace = driverInfoFeignClient.isFaceRecognition(driverId).getData();  \n    if(!isFace) {  \n        throw new GuiguException(ResultCodeEnum.FACE_ERROR);  \n    }  \n  \n    //3 更新订单状态 1 开始接单  \n    driverInfoFeignClient.updateServiceStatus(driverId,1);  \n  \n    //4 删除redis司机位置信息  \n    locationFeignClient.removeDriverLocation(driverId);  \n  \n    //5 清空司机临时队列数据  \n    newOrderFeignClient.clearNewOrderQueueData(driverId);  \n    return true;  \n}\n```\n\n## 停止接单服务web接口\n\nDriverController\n```java\n@Operation(summary = \"停止接单服务\")  \n@LoginDetection  \n@GetMapping(\"/stopService\")  \npublic Result<Boolean> stopService() {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(driverService.stopService(driverId));  \n}\n```\n\nDriverServiceImpl\n```java\n//停止接单服务  \n@Override  \npublic Boolean stopService(Long driverId) {  \n    //更新司机的接单状态 0   \n    driverInfoFeignClient.updateServiceStatus(driverId,0);  \n  \n    //删除司机位置信息  \n    locationFeignClient.removeDriverLocation(driverId);  \n  \n    //清空司机临时队列  \n    newOrderFeignClient.clearNewOrderQueueData(driverId);  \n    return true;  \n}\n```\n\n\n# 司机抢单\n\n## 抢单接口\n\n### 微服务抢单接口\n\nservice-order模块内\n\nOrderInfoController\n```java\n@Operation(summary = \"司机抢单\")  \n@GetMapping(\"/robNewOrder/{driverId}/{orderId}\")  \npublic Result<Boolean> robNewOrder(@PathVariable Long driverId, @PathVariable Long orderId) {  \n    return Result.ok(orderInfoService.robNewOrder(driverId, orderId));  \n}\n```\n\n\n在OrderInfoServiceImpl之前保存订单 方法修改\n```java\n@Autowired  \nprivate RedisTemplate redisTemplate;\n\n//乘客下单  \n@Override  \npublic Long saveOrderInfo(OrderInfoForm orderInfoForm) {  \n    //order_info添加订单数据  \n    OrderInfo orderInfo = new OrderInfo();  \n    BeanUtils.copyProperties(orderInfoForm,orderInfo);  \n    //订单号  \n    String orderNo = UUID.randomUUID().toString().replaceAll(\"-\",\"\");  \n    orderInfo.setOrderNo(orderNo);  \n    //订单状态  \n    orderInfo.setStatus(OrderStatus.WAITING_ACCEPT.getStatus());  \n    orderInfoMapper.insert(orderInfo);  \n  \n    //记录日志  \n    this.log(orderInfo.getId(),orderInfo.getStatus());  \n  \n    //向redis添加标识  \n    //接单标识，标识不存在了说明不在等待接单状态了  \n    redisTemplate.opsForValue().set(RedisConstant.ORDER_ACCEPT_MARK,  \n            \"0\", RedisConstant.ORDER_ACCEPT_MARK_EXPIRES_TIME, TimeUnit.MINUTES);  \n  \n    return orderInfo.getId();  \n}\n```\n\nOrderInfoServiceImpl新增司机抢单方法\n```java\n//司机抢单  \n@Override  \npublic Boolean robNewOrder(Long driverId, Long orderId) {  \n    //判断订单是否存在，通过Redis，减少数据库压力  \n    if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) {  \n        //抢单失败  \n        throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n    }  \n  \n    //司机抢单  \n    //修改order_info表订单状态值2：已经接单 + 司机id + 司机接单时间  \n    //修改条件：根据订单id  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId,orderId);  \n    OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);  \n    //设置  \n    orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());  \n    orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());  \n    orderInfo.setDriverId(driverId);  \n    orderInfo.setAcceptTime(new Date());  \n    //调用方法修改  \n    int rows = orderInfoMapper.updateById(orderInfo);  \n    if(rows != 1) {  \n        //抢单失败  \n        throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n    }  \n  \n    //删除抢单标识  \n    redisTemplate.delete(RedisConstant.ORDER_ACCEPT_MARK);  \n    return true;  \n}\n```\n\n\n远程调用\n```java\n/**  \n * 司机抢单  \n * @param driverId  \n * @param orderId  \n * @return  \n */  \n@GetMapping(\"/order/info/robNewOrder/{driverId}/{orderId}\")  \nResult<Boolean> robNewOrder(@PathVariable(\"driverId\") Long driverId, @PathVariable(\"orderId\") Long orderId);\n```\n\n### 司机web端接口\n\nOrderController\n```java\n@Operation(summary = \"司机抢单\")  \n@LoginDetection  \n@GetMapping(\"/robNewOrder/{orderId}\")  \npublic Result<Boolean> robNewOrder(@PathVariable Long orderId) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.robNewOrder(driverId, orderId));  \n}\n```\n\nservice\n```java\n// 司机抢单  \n@Override  \npublic Boolean robNewOrder(Long driverId, Long orderId) {  \n    Result<Boolean> booleanResult = orderInfoFeignClient.robNewOrder(driverId, orderId);  \n    return booleanResult.getData();  \n}\n```\n\n### 添加Redisson分布式锁到司机抢单\n\n在service里service-order中OrderInfoServiceImpl添加分布式锁\n\n修改之前写的robNewOrder\n```java\n@Autowired  \nprivate RedissonClient redissonClient;\n\n//司机抢单  \n@Override  \npublic Boolean robNewOrder(Long driverId, Long orderId) {  \n    //判断订单是否存在，通过Redis，减少数据库压力  \n    if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) {  \n        //抢单失败  \n        throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n    }  \n  \n    //创建锁  \n    RLock lock = redissonClient.getLock(RedisConstant.ROB_NEW_ORDER_LOCK + orderId);  \n  \n    try {  \n        //获取锁  \n        boolean flag = lock.tryLock(RedisConstant.ROB_NEW_ORDER_LOCK_WAIT_TIME,  \n                RedisConstant.ROB_NEW_ORDER_LOCK_LEASE_TIME,   \n                TimeUnit.SECONDS);  \n        if(flag) {  \n            if(!redisTemplate.hasKey(RedisConstant.ORDER_ACCEPT_MARK)) {  \n                //抢单失败  \n                throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n            }  \n            //司机抢单  \n            //修改order_info表订单状态值2：已经接单 + 司机id + 司机接单时间  \n            //修改条件：根据订单id  \n            LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n            wrapper.eq(OrderInfo::getId,orderId);  \n            OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);  \n            //设置  \n            orderInfo.setStatus(OrderStatus.ACCEPTED.getStatus());  \n            orderInfo.setDriverId(driverId);  \n            orderInfo.setAcceptTime(new Date());  \n            //调用方法修改  \n            int rows = orderInfoMapper.updateById(orderInfo);  \n            if(rows != 1) {  \n                //抢单失败  \n                throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n            }  \n  \n            //删除抢单标识  \n            redisTemplate.delete(RedisConstant.ORDER_ACCEPT_MARK);  \n        }  \n    }catch (Exception e) {  \n        //抢单失败  \n        throw new GuiguException(ResultCodeEnum.COB_NEW_ORDER_FAIL);  \n    }finally {  \n        //释放  \n        if(lock.isLocked()) {  \n            lock.unlock();  \n        }  \n    }  \n    return true;  \n}\n```\n\n\n# 订单执行（一）\n\n## 加载当前订单\n\n### 需求\n\n- 无论是司机端，还是乘客端，遇到页面切换，重新登录小程序等，只要回到首页面，查看当前是否有正在执行的订单，如果有跳转到当前订单的执行页面\n\n### 乘客端查找当前订单\n\n#### 订单微服务接口\n\n- OrderInfoController\n```java\n@Operation(summary = \"乘客端查找当前订单\")\n@GetMapping(\"/searchCustomerCurrentOrder/{customerId}\")\npublic Result<CurrentOrderInfoVo> searchCustomerCurrentOrder(@PathVariable Long customerId) {\n    return Result.ok(orderInfoService.searchCustomerCurrentOrder(customerId));\n}\n```\n\nOrderInfoServiceImpl\n```java\n@Autowired  \nprivate RedissonClient redissonClient;\n\n//乘客端查找当前订单  \n@Override  \npublic CurrentOrderInfoVo searchCustomerCurrentOrder(Long customerId) {  \n    //封装条件  \n    //乘客id  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getCustomerId,customerId);  \n  \n    //各种状态  \n    Integer[] statusArray = {  \n            OrderStatus.ACCEPTED.getStatus(),  \n            OrderStatus.DRIVER_ARRIVED.getStatus(),  \n            OrderStatus.UPDATE_CART_INFO.getStatus(),  \n            OrderStatus.START_SERVICE.getStatus(),  \n            OrderStatus.END_SERVICE.getStatus(),  \n            OrderStatus.UNPAID.getStatus()  \n    };  \n    wrapper.in(OrderInfo::getStatus,statusArray);  \n  \n    //获取最新一条记录  \n    wrapper.orderByDesc(OrderInfo::getId);  \n    wrapper.last(\" limit 1\");  \n  \n    //调用方法  \n    OrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);  \n  \n    //封装到CurrentOrderInfoVo  \n    CurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();  \n    if(orderInfo != null) {  \n        currentOrderInfoVo.setOrderId(orderInfo.getId());  \n        currentOrderInfoVo.setStatus(orderInfo.getStatus());  \n        currentOrderInfoVo.setIsHasCurrentOrder(true);  \n    } else {  \n        currentOrderInfoVo.setIsHasCurrentOrder(false);  \n    }  \n    return currentOrderInfoVo;  \n}\n```\n\n#### 远程调用\nserivce-order-client\nOrderInfoFeignClient\n```java\n/**  \n * 乘客端查找当前订单  \n * @param customerId  \n * @return  \n */  \n@GetMapping(\"/order/info/searchCustomerCurrentOrder/{customerId}\")  \nResult<CurrentOrderInfoVo> searchCustomerCurrentOrder(@PathVariable(\"customerId\") Long customerId);\n```\n\n#### 乘客web端接口\n\nweb-customer\nOrderController\n```java\n@Operation(summary = \"乘客端查找当前订单\")  \n@LoginDetection  \n@GetMapping(\"/searchCustomerCurrentOrder\")  \npublic Result<CurrentOrderInfoVo> searchCustomerCurrentOrder() {  \n    Long customerId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.searchCustomerCurrentOrder(customerId));  \n}\n```\n\nOrderServiceImpl\n```java\n// 乘客端查找当前订单  \n@Override  \npublic CurrentOrderInfoVo searchCustomerCurrentOrder(Long customerId) {  \n    Result<CurrentOrderInfoVo> currentOrderInfoVoResult = orderInfoFeignClient.searchCustomerCurrentOrder(customerId);  \n    return currentOrderInfoVoResult.getData();  \n}\n```\n\n### 司机端查找当前订单\n\n#### 订单微服务接口\nservice-order\nOrderInfoController\n```java\n@Operation(summary = \"司机端查找当前订单\")\n@GetMapping(\"/searchDriverCurrentOrder/{driverId}\")\npublic Result<CurrentOrderInfoVo> searchDriverCurrentOrder(@PathVariable Long driverId) {\n    return Result.ok(orderInfoService.searchDriverCurrentOrder(driverId));\n}\n```\n\nservice\n```java\n// 司机端查找当前订单\n@Override\npublic CurrentOrderInfoVo searchDriverCurrentOrder(Long driverId) {\n\t//封装条件\n\tLambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();\n\twrapper.eq(OrderInfo::getDriverId,driverId);\n\tInteger[] statusArray = {\n\t\t\tOrderStatus.ACCEPTED.getStatus(),\n\t\t\tOrderStatus.DRIVER_ARRIVED.getStatus(),\n\t\t\tOrderStatus.UPDATE_CART_INFO.getStatus(),\n\t\t\tOrderStatus.START_SERVICE.getStatus(),\n\t\t\tOrderStatus.END_SERVICE.getStatus()\n\t};\n\twrapper.in(OrderInfo::getStatus,statusArray);\n\twrapper.orderByDesc(OrderInfo::getId);\n\twrapper.last(\" limit 1\");\n\tOrderInfo orderInfo = orderInfoMapper.selectOne(wrapper);\n\t//封装到vo\n\tCurrentOrderInfoVo currentOrderInfoVo = new CurrentOrderInfoVo();\n\tif(null != orderInfo) {\n\t\tcurrentOrderInfoVo.setStatus(orderInfo.getStatus());\n\t\tcurrentOrderInfoVo.setOrderId(orderInfo.getId());\n\t\tcurrentOrderInfoVo.setIsHasCurrentOrder(true);\n\t} else {\n\t\tcurrentOrderInfoVo.setIsHasCurrentOrder(false);\n\t}\n\treturn currentOrderInfoVo;\n}\n```\n#### 远程调用\n\nservice-order-client\nOrderInfoFeignClient\n```java\n/**\n * 司机端查找当前订单\n * @param driverId\n * @return\n */\n@GetMapping(\"/order/info/searchDriverCurrentOrder/{driverId}\")\nResult<CurrentOrderInfoVo> searchDriverCurrentOrder(@PathVariable(\"driverId\") Long driverId);\n```\n\n#### 司机端web接口\n\nweb-driver\nOrderController\n```java\n@Operation(summary = \"司机端查找当前订单\")  \n@LoginDetection  \n@GetMapping(\"/searchDriverCurrentOrder\")  \npublic Result<CurrentOrderInfoVo> searchDriverCurrentOrder() {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.searchDriverCurrentOrder(driverId));  \n}\n```\n\nservice\n```java\n// 司机端查找当前订单  \n@Override  \npublic CurrentOrderInfoVo searchDriverCurrentOrder(Long driverId) {  \n    return orderInfoFeignClient.searchDriverCurrentOrder(driverId).getData();  \n}\n```\n\n### 获取订单信息\n\n#### 订单微服务接口\n\nservice-order\nOrderInfoController\n```java\n@Operation(summary = \"根据订单id获取订单信息\")\n@GetMapping(\"/getOrderInfo/{orderId}\")\npublic Result<OrderInfo> getOrderInfo(@PathVariable Long orderId) {\n    return Result.ok(orderInfoService.getById(orderId));\n}\n```\n\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**\n * 根据订单id获取订单信息\n * @param orderId\n * @return\n */\n@GetMapping(\"/order/info/getOrderInfo/{orderId}\")\nResult<OrderInfo> getOrderInfo(@PathVariable(\"orderId\") Long orderId);\n```\n\n#### 乘客端web接口\n\nOrderController\n```java\n@Operation(summary = \"获取订单信息\")  \n@LoginDetection  \n@GetMapping(\"/getOrderInfo/{orderId}\")  \npublic Result<OrderInfoVo> getOrderInfo(@PathVariable Long orderId) {  \n    Long customerId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.getOrderInfo(orderId, customerId));  \n}\n```\n\nservice\n```java\n// 获取订单信息  \n@Override  \npublic OrderInfoVo getOrderInfo(Long orderId, Long customerId) {  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();  \n    //判断  \n    if(orderInfo.getCustomerId() != customerId) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    OrderInfoVo orderInfoVo = new OrderInfoVo();  \n    orderInfoVo.setOrderId(orderId);  \n    BeanUtils.copyProperties(orderInfo,orderInfoVo);  \n    return orderInfoVo;  \n}\n```\n\n#### 司机端web接口\n\nOrderController\n```java\n@Operation(summary = \"获取订单账单详细信息\")  \n@LoginDetection  \n@GetMapping(\"/getOrderInfo/{orderId}\")  \npublic Result<OrderInfoVo> getOrderInfo(@PathVariable Long orderId) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.getOrderInfo(orderId, driverId));  \n}\n```\n\nservice\n```java\n@Override\npublic OrderInfoVo getOrderInfo(Long orderId, Long driverId) {\n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();\n    if(orderInfo.getDriverId() != driverId) {\n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);\n    }\n    OrderInfoVo orderInfoVo = new OrderInfoVo();\n    orderInfoVo.setOrderId(orderId);\n    BeanUtils.copyProperties(orderInfo,orderInfoVo);\n    return orderInfoVo;\n}\n```\n\n## 司乘同显\n\n### 司机端同显\n\n- 司机所在地址就是司乘同显开始位置，订单地址就是司乘同显的终点\n- 计算司机司乘同显最佳路线\n\n#### 司机端web\n\nOrderController\n```java\n@Operation(summary = \"计算最佳驾驶线路\")  \n@LoginDetection  \n@PostMapping(\"/calculateDrivingLine\")  \npublic Result<DrivingLineVo> calculateDrivingLine(@RequestBody CalculateDrivingLineForm calculateDrivingLineForm) {  \n    return Result.ok(orderService.calculateDrivingLine(calculateDrivingLineForm));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate MapFeignClient mapFeignClient;\n\n// 计算最佳驾驶线路  \n@Override  \npublic DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) {  \n    Result<DrivingLineVo> drivingLineVoResult = mapFeignClient.calculateDrivingLine(calculateDrivingLineForm);  \n    return drivingLineVoResult.getData();  \n}\n```\n\n### 更新位置到redis\n\n- 实时更新司机位置到redis\n\n#### 地图微服务接口service-map\n\nLocationController\n```java\n@Operation(summary = \"司机赶往代驾起始点：更新订单地址到缓存\")  \n@PostMapping(\"/updateOrderLocationToCache\")  \npublic Result<Boolean> updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm) {  \n    return Result.ok(locationService.updateOrderLocationToCache(updateOrderLocationForm));  \n}\n```\n\nservice\n```java\n// 司机赶往代驾起始点：更新订单地址到缓存  \n@Override  \npublic Boolean updateOrderLocationToCache(UpdateOrderLocationForm updateOrderLocationForm) {  \n  \n    OrderLocationVo orderLocationVo = new OrderLocationVo();  \n    orderLocationVo.setLongitude(updateOrderLocationForm.getLongitude());  \n    orderLocationVo.setLatitude(updateOrderLocationForm.getLatitude());  \n  \n    String key = RedisConstant.UPDATE_ORDER_LOCATION + updateOrderLocationForm.getOrderId();  \n    redisTemplate.opsForValue().set(key, orderLocationVo);  \n    return true;  \n}\n```\n\n#### 远程调用service-map-client\n\nLocationFeignClient\n```java\n/**  \n * 司机赶往代驾起始点：更新订单地址到缓存  \n * @param updateOrderLocationForm  \n * @return  \n */  \n@PostMapping(\"/map/location/updateOrderLocationToCache\")  \nResult<Boolean> updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm);\n```\n\n\n#### 司机web端\n\nLocationController\n```java\n@Operation(summary = \"司机赶往代驾起始点：更新订单位置到Redis缓存\")  \n@LoginDetection  \n@PostMapping(\"/updateOrderLocationToCache\")  \npublic Result updateOrderLocationToCache(@RequestBody UpdateOrderLocationForm updateOrderLocationForm) {  \n    return Result.ok(locationService.updateOrderLocationToCache(updateOrderLocationForm));  \n}\n```\n\nservice\n```java\n// 司机赶往代驾起始点：更新订单位置到Redis缓存  \n@Override  \npublic Boolean updateOrderLocationToCache(UpdateOrderLocationForm updateOrderLocationForm) {  \n    return locationFeignClient.updateOrderLocationToCache(updateOrderLocationForm).getData();  \n}\n```\n\n### 获取司机基本信息\n\n- 乘客端进入司乘同显界面可以看到司机的基本信息.\n\n#### 司机微服务接口service-driver\n\nDriverInfoController\n```java\n@Operation(summary = \"获取司机基本信息\")  \n@GetMapping(\"/getDriverInfo/{driverId}\")  \npublic Result<DriverInfoVo> getDriverInfoOrder(@PathVariable Long driverId) {  \n    return Result.ok(driverInfoService.getDriverInfoOrder(driverId));  \n}\n```\n\nservice\n```java\n//获取司机基本信息  \n@Override  \npublic DriverInfoVo getDriverInfoOrder(Long driverId) {  \n    //司机id获取基本信息  \n    DriverInfo driverInfo = driverInfoMapper.selectById(driverId);  \n  \n    //封装DriverInfoVo  \n    DriverInfoVo driverInfoVo = new DriverInfoVo();  \n    BeanUtils.copyProperties(driverInfo,driverInfoVo);  \n  \n    //计算驾龄  \n    //获取当前年  \n    int currentYear = new DateTime().getYear();  \n    //获取驾驶证初次领证日期  \n    //driver_license_issue_date  \n    int firstYear = new DateTime(driverInfo.getDriverLicenseIssueDate()).getYear();  \n    int driverLicenseAge = currentYear - firstYear;  \n    driverInfoVo.setDriverLicenseAge(driverLicenseAge);  \n  \n    return driverInfoVo;  \n}\n```\n\n#### 远程调用\n\nDriverInfoFeignClient\n```java\n/**\n * 获取司机基本信息\n * @param driverId\n * @return\n */\n@GetMapping(\"/driver/info/getDriverInfo/{driverId}\")\nResult<DriverInfoVo> getDriverInfo(@PathVariable(\"driverId\") Long driverId);\n```\n\n#### 乘客端web接口\n\nOrderController\n```java\n@Operation(summary = \"根据订单id获取司机基本信息\")  \n@LoginDetection  \n@GetMapping(\"/getDriverInfo/{orderId}\")  \npublic Result<DriverInfoVo> getDriverInfo(@PathVariable Long orderId) {  \n    Long customerId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.getDriverInfo(orderId, customerId));  \n}\n```\n\nservice\n```java\n// 根据订单id获取司机基本信息  \n@Override  \npublic DriverInfoVo getDriverInfo(Long orderId, Long customerId) {  \n    //根据订单id获取订单信息  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();  \n    if(orderInfo.getCustomerId() != customerId) {  \n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);  \n    }  \n    return driverInfoFeignClient.getDriverInfo(orderInfo.getDriverId()).getData();  \n}\n```\n\n### 乘客端获取司机经纬度位置\n\n- 乘客查看司机位置\n\n#### 地图微服务接口service-map\n\nLocationController\n```java\n@Operation(summary = \"司机赶往代驾起始点：获取订单经纬度位置\")  \n@GetMapping(\"/getCacheOrderLocation/{orderId}\")  \npublic Result<OrderLocationVo> getCacheOrderLocation(@PathVariable Long orderId) { \n    return Result.ok(locationService.getCacheOrderLocation(orderId));  \n}\n```\n\nservice\n```java\n// 司机赶往代驾起始点：获取订单经纬度位置  \n@Override  \npublic OrderLocationVo getCacheOrderLocation(Long orderId) {  \n    String key = RedisConstant.UPDATE_ORDER_LOCATION + orderId;  \n    OrderLocationVo orderLocationVo = (OrderLocationVo)redisTemplate.opsForValue().get(key);  \n    return orderLocationVo;  \n}\n```\n\n#### 远程调用\n\nLocationFeignClient\n```java\n/**  \n * 司机赶往代驾起始点：获取订单经纬度位置  \n * @param orderId  \n * @return  \n */  \n@GetMapping(\"/map/location/getCacheOrderLocation/{orderId}\")  \nResult<OrderLocationVo> getCacheOrderLocation(@PathVariable(\"orderId\") Long orderId);\n```\n\n#### 乘客端web接口\n\nOrderController\n```java\n@Operation(summary = \"司机赶往代驾起始点：获取订单经纬度位置\")  \n@GetMapping(\"/getCacheOrderLocation/{orderId}\")  \npublic Result<OrderLocationVo> getCacheOrderLocation(@PathVariable Long orderId) {  \n    return Result.ok(orderService.getCacheOrderLocation(orderId));  \n}\n```\n\nservice\n```java\n// 司机赶往代驾起始点：获取订单经纬度位置  \n@Override  \npublic OrderLocationVo getCacheOrderLocation(Long orderId) {  \n    return locationFeignClient.getCacheOrderLocation(orderId).getData();  \n}\n```\n\n### 乘客端同显\n\n#### 乘客端web接口\n\nOrderController\n```java\n@Operation(summary = \"计算最佳驾驶线路\")  \n@LoginDetection  \n@PostMapping(\"/calculateDrivingLine\")  \npublic Result<DrivingLineVo> calculateDrivingLine(@RequestBody CalculateDrivingLineForm calculateDrivingLineForm) {  \n    return Result.ok(orderService.calculateDrivingLine(calculateDrivingLineForm));  \n}\n```\n\nservice\n```java\n// 计算最佳驾驶线路  \n@Override  \npublic DrivingLineVo calculateDrivingLine(CalculateDrivingLineForm calculateDrivingLineForm) {  \n    return mapFeignClient.calculateDrivingLine(calculateDrivingLineForm).getData();  \n}\n```\n\n\n## 司机到达起始点\n\n- 司机到达起始点后更新订单数据\n- 更新订单状态：司机已到达\n- 更新订单到达时间\n\n### 订单微服务接口service-order\n\nOrderInfoController\n```java\n@Operation(summary = \"司机到达起始点\")  \n@GetMapping(\"/driverArriveStartLocation/{orderId}/{driverId}\")  \npublic Result<Boolean> driverArriveStartLocation(@PathVariable Long orderId, @PathVariable Long driverId) {  \n    return Result.ok(orderInfoService.driverArriveStartLocation(orderId, driverId));  \n}\n```\n\nservice\n```java\n//司机到达起始点  \n@Override  \npublic Boolean driverArriveStartLocation(Long orderId, Long driverId) {  \n    // 更新订单状态和到达时间，条件：orderId + driverId  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId,orderId);  \n    wrapper.eq(OrderInfo::getDriverId,driverId);  \n  \n    OrderInfo orderInfo = new OrderInfo();  \n    orderInfo.setStatus(OrderStatus.DRIVER_ARRIVED.getStatus());  \n    orderInfo.setArriveTime(new Date());  \n  \n    int rows = orderInfoMapper.update(orderInfo, wrapper);  \n  \n    if(rows == 1) {  \n        return true;  \n    } else {  \n        throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);  \n    }  \n}\n```\n\n### 远程调用service-order-client\n\nOrderInfoFeignClient\n```java\n/**\n * 司机到达起始点\n * @param orderId\n * @param driverId\n * @return\n */\n@GetMapping(\"/order/info/driverArriveStartLocation/{orderId}/{driverId}\")\nResult<Boolean> driverArriveStartLocation(@PathVariable(\"orderId\") Long orderId, @PathVariable(\"driverId\") Long driverId);\n```\n\n### 司机web调用\n\nOrderController\n```java\n@Operation(summary = \"司机到达代驾起始地点\")  \n@LoginDetection  \n@GetMapping(\"/driverArriveStartLocation/{orderId}\")  \npublic Result<Boolean> driverArriveStartLocation(@PathVariable Long orderId) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.driverArriveStartLocation(orderId, driverId));  \n}\n```\n\n```java\n// 司机到达代驾起始地点  \n@Override  \npublic Boolean driverArriveStartLocation(Long orderId, Long driverId) {  \n    return orderInfoFeignClient.driverArriveStartLocation(orderId, driverId).getData();  \n}\n```\n\n## 司机更新代驾车辆信息\n\n### 订单微服务接口service-order\n\nOrderInfoController\n```java\n@Operation(summary = \"更新代驾车辆信息\")  \n@PostMapping(\"/updateOrderCart\")  \npublic Result<Boolean> updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm) {  \n    return Result.ok(orderInfoService.updateOrderCart(updateOrderCartForm));  \n}\n```\n\nservice\n```java\n// 更新代驾车辆信息  \n@Override  \npublic Boolean updateOrderCart(UpdateOrderCartForm updateOrderCartForm) {  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId,updateOrderCartForm.getOrderId());  \n    wrapper.eq(OrderInfo::getDriverId,updateOrderCartForm.getDriverId());  \n  \n    OrderInfo orderInfo = new OrderInfo();  \n    BeanUtils.copyProperties(updateOrderCartForm,orderInfo);  \n    orderInfo.setStatus(OrderStatus.UPDATE_CART_INFO.getStatus());  \n  \n    int rows = orderInfoMapper.update(orderInfo, wrapper);  \n    if(rows == 1) {  \n        return true;  \n    } else {  \n        throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);  \n    }  \n}\n```\n\n### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 更新代驾车辆信息  \n * @param updateOrderCartForm  \n * @return  \n */  \n@PostMapping(\"/order/info//updateOrderCart\")  \nResult<Boolean> updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm);\n```\n\n\n### 司机web端接口\n\nOrderController\n```java\n@Operation(summary = \"更新代驾车辆信息\")  \n@LoginDetection  \n@PostMapping(\"/updateOrderCart\")  \npublic Result<Boolean> updateOrderCart(@RequestBody UpdateOrderCartForm updateOrderCartForm) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    updateOrderCartForm.setDriverId(driverId);  \n    return Result.ok(orderService.updateOrderCart(updateOrderCartForm));  \n}\n```\n\nservice\n```java\n// 更新代驾车辆信息  \n@Override  \npublic Boolean updateOrderCart(UpdateOrderCartForm updateOrderCartForm) {  \n    return orderInfoFeignClient.updateOrderCart(updateOrderCartForm).getData();  \n}\n```\n\n## 测试\n\n- 启动项目：\n\t- XxlJobAdminApplication\n\t- ServerGatewayApplication :8600/\n\t- ServiceCustomerApplication :8501/\n\t- ServiceDispatchApplication :8509/\n\t- ServiceDriverApplication :8502/\n\t- ServiceMapApplication :8503/\n\t- ServiceOrderApplication:8505/\n\t- ServiceRulesApplication :8504/\n\t- WebCustomerApplication :8601/\n\t- WebDriverApplication :8602/\n\n- 清除之前的数据\n\n- 启动微信开发者工具\n\n修改前面的代码web-driver\n\nFileController\n```java\n@Autowired  \nprivate CosService cosService;  \n  \n//文件上传接口  \n@Operation(summary = \"上传\")  \n//@LoginDetection  \n@PostMapping(\"/upload\")  \npublic Result<String> upload(@RequestPart(\"file\") MultipartFile file,  \n                                  @RequestParam(name = \"path\",defaultValue = \"auth\") String path) {  \n    CosUploadVo cosUploadVo = cosService.uploadFile(file,path);  \n    String showUrl = cosUploadVo.getShowUrl();  \n    return Result.ok(showUrl);  \n}\n```\n\n\n# 订单执行（二）\n\n## 开始服务\n\n- 更新订单状态\n\n### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"开始服务\")  \n@PostMapping(\"/startDrive\")  \npublic Result<Boolean> startDriver(@RequestBody StartDriveForm startDriveForm) {  \n    Boolean flag = orderInfoService.startDriver(startDriveForm);  \n    return Result.ok(flag);  \n}\n```\n\nservice\n```java\n//开始代驾服务  \n@Override  \npublic Boolean startDriver(StartDriveForm startDriveForm) {  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId,startDriveForm.getOrderId());  \n    wrapper.eq(OrderInfo::getDriverId,startDriveForm.getDriverId());  \n  \n    OrderInfo orderInfo = new OrderInfo();  \n    orderInfo.setStatus(OrderStatus.START_SERVICE.getStatus());  \n    orderInfo.setStartServiceTime(new Date());  \n  \n    int rows = orderInfoMapper.update(orderInfo, wrapper);  \n    if(rows == 1) {  \n        return true;  \n    } else {  \n        throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);  \n    }  \n}\n```\n\n\n### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 开始代驾服务  \n * @param startDriveForm  \n * @return  \n */  \n@PostMapping(\"/order/info/startDrive\")  \nResult<Boolean> startDrive(@RequestBody StartDriveForm startDriveForm);\n```\n\n### 司机web端调用\n\nOrderController\n```java\n@Operation(summary = \"开始代驾服务\")  \n@LoginDetection  \n@PostMapping(\"/startDrive\")  \npublic Result<Boolean> startDrive(@RequestBody StartDriveForm startDriveForm) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    startDriveForm.setDriverId(driverId);  \n    return Result.ok(orderService.startDrive(startDriveForm));  \n}\n```\n\nservice\n```java\n// 开始代驾服务  \n@Override  \npublic Boolean startDrive(StartDriveForm startDriveForm) {  \n    return orderInfoFeignClient.startDrive(startDriveForm).getData();  \n}\n```\n\n## 批量保存订单位置信息\n\n- 开始服务后，司机端会实时收集司机位置\n- 定时批量上传位置到后台服务保存到MongoDB\n\n### 地图微服务接口\n\nLocationController\n```java\n@Operation(summary = \"批量保存代驾服务订单位置\")  \n@PostMapping(\"/saveOrderServiceLocation\")  \npublic Result<Boolean> saveOrderServiceLocation(@RequestBody List<OrderServiceLocationForm> orderLocationServiceFormList) {  \n    return Result.ok(locationService.saveOrderServiceLocation(orderLocationServiceFormList));  \n}\n```\n\n编写接口\n```java\n@Repository  \npublic interface OrderServiceLocationRepository extends MongoRepository<OrderServiceLocation, String> {  \n}\n```\n\n导入依赖\n```xml\n<!--mongodb-->  \n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-data-mongodb</artifactId>  \n</dependency>\n```\n\nservice\n```java\n@Autowired  \nprivate OrderServiceLocationRepository orderServiceLocationRepository;\n\n@Override  \npublic Boolean saveOrderServiceLocation(List<OrderServiceLocationForm> orderLocationServiceFormList) {  \n    List<OrderServiceLocation> list = new ArrayList<>();  \n    // 遍历，变成OrderServiceLocation  \n    orderLocationServiceFormList.forEach(orderServiceLocationForm->{  \n        //orderServiceLocationForm -- OrderServiceLocation  \n        OrderServiceLocation orderServiceLocation = new OrderServiceLocation();  \n        BeanUtils.copyProperties(orderServiceLocationForm,orderServiceLocation);  \n        orderServiceLocation.setId(ObjectId.get().toString());  \n        orderServiceLocation.setCreateTime(new Date());  \n  \n        list.add(orderServiceLocation);  \n    });  \n    //批量添加到MongoDB  \n    orderServiceLocationRepository.saveAll(list);  \n    return true;  \n}\n```\n\n\n### 远程调用\n\nLocationFeignClient\n```java\n/**  \n * 开始代驾服务：保存代驾服务订单位置  \n * @param orderLocationServiceFormList  \n * @return  \n */  \n@PostMapping(\"/map/location/saveOrderServiceLocation\")  \nResult<Boolean> saveOrderServiceLocation(@RequestBody List<OrderServiceLocationForm> orderLocationServiceFormList);\n```\n\n### 司机web端调用\n\nLocationController\n```java\n@Operation(summary = \"开始代驾服务：保存代驾服务订单位置\")  \n@PostMapping(\"/saveOrderServiceLocation\")  \npublic Result<Boolean> saveOrderServiceLocation(@RequestBody List<OrderServiceLocationForm> orderLocationServiceFormList) {  \n    return Result.ok(locationService.saveOrderServiceLocation(orderLocationServiceFormList));  \n}\n```\n\nservice\n```java\n// 始代驾服务：保存代驾服务订单位置  \n@Override  \npublic Boolean saveOrderServiceLocation(List<OrderServiceLocationForm> orderLocationServiceFormList) {  \n    return locationFeignClient.saveOrderServiceLocation(orderLocationServiceFormList).getData();  \n}\n```\n\n\n## 获取订单最后一个位置\n\n- 司机开始服务后，乘客端获取司机的最新动向\n\n### 地图微服务接口\n\nLocationController\n```java\n@Operation(summary = \"代驾服务：获取订单服务最后一个位置信息\")  \n@GetMapping(\"/getOrderServiceLastLocation/{orderId}\")  \npublic Result<OrderServiceLastLocationVo> getOrderServiceLastLocation(@PathVariable Long orderId) {  \n    return Result.ok(locationService.getOrderServiceLastLocation(orderId));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate MongoTemplate mongoTemplate;\n\n// 代驾服务：获取订单服务最后一个位置信息  \n@Override  \npublic OrderServiceLastLocationVo getOrderServiceLastLocation(Long orderId) {  \n    //查询MongoDB,查询条件 ：orderId  \n    Query query = new Query();  \n    query.addCriteria(Criteria.where(\"orderId\").is(orderId));  \n    //根据创建时间降序排列  \n    query.with(Sort.by(Sort.Order.desc(\"createTime\")));  \n    //只取一条数据  \n    query.limit(1);  \n  \n    OrderServiceLocation orderServiceLocation =  \n            mongoTemplate.findOne(query, OrderServiceLocation.class);  \n    OrderServiceLastLocationVo orderServiceLastLocationVo = new OrderServiceLastLocationVo();  \n    BeanUtils.copyProperties(orderServiceLocation,orderServiceLastLocationVo);  \n    return orderServiceLastLocationVo;  \n}\n```\n\n### 远程调用\n\nLocationFeignClient\n```java\n/**  \n * 代驾服务：获取订单服务最后一个位置信息  \n * @param orderId  \n * @return  \n */  \n@GetMapping(\"/map/location/getOrderServiceLastLocation/{orderId}\")  \nResult<OrderServiceLastLocationVo> getOrderServiceLastLocation(@PathVariable Long orderId);\n```\n\n### 乘客web端调用\n\nOrderController\n```java\n@Operation(summary = \"代驾服务：获取订单服务最后一个位置信息\")  \n@LoginDetection  \n@GetMapping(\"/getOrderServiceLastLocation/{orderId}\")  \npublic Result<OrderServiceLastLocationVo> getOrderServiceLastLocation(@PathVariable Long orderId) {  \n    return Result.ok(orderService.getOrderServiceLastLocation(orderId));  \n}\n```\n\nservice\n```java\n// 代驾服务：获取订单服务最后一个位置信息  \n@Override  \npublic OrderServiceLastLocationVo getOrderServiceLastLocation(Long orderId) {  \n    return locationFeignClient.getOrderServiceLastLocation(orderId).getData();  \n}\n```\n\n## Minio上传接口\n\n- 司机服务过程中，司机端小程序实时采集录音，把录音和对话文本上传到后台服务，把完整监控保存到Minio\n\n### Minio安装\n\n**使用docker安装**\n\n```shell\n// 创建数据存储目录\nmkdir -p ~/minio/data\n\n// 创建minio\ndocker run \\\n   -p 9000:9000 \\\n   -p 9090:9090 \\\n   --name minio \\\n   -v ~/minio/data:/data \\\n   -e \"MINIO_ROOT_USER=admin\" \\\n   -e \"MINIO_ROOT_PASSWORD=admin123456\" \\\n   -d \\\n   quay.io/minio/minio server /data --console-address \":9090\"\n```\n\n**2 安装到windows里面**\n\n* 找到minio安装文件，放到没有中文没有空格目录\n* 创建空文件夹，作为数据存储目录\n\n* 在windows使用命令启动Minio服务\n\n-- minio.exe server D:\\Desktop\\hhsqdmz\\sort\\minio\\data\n\n### Minio启动\n\n- 访问Minio控制台：ip:9000\n- 默认控制台用户名和密码都是：minioadmin\n\n- 在minio控制台里创建buckets\n- 创建buckets后**记得把Access Policy设为public**\n\n### 司机端web接口\n\n导入依赖\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-data-mongodb</artifactId>  \n</dependency>\n```\n\n修改配置文件common-account.yaml\n```yaml\nminio:\n  endpointUrl: http://localhost:9000\n  accessKey: minioadmin\n  secreKey: minioadmin\n  bucketName: daijia\n```\n\n创建配置类，读取minio的值\n```java\n@Configuration  \n@ConfigurationProperties(prefix=\"minio\") //读取节点  \n@Data  \npublic class MinioProperties {  \n  \n    private String endpointUrl;  \n    private String accessKey;  \n    private String secreKey;  \n    private String bucketName;  \n}\n```\n\nFileController\n```java\n@Autowired  \nprivate FileService fileService;\n\n@Operation(summary = \"上传\")  \n@PostMapping(\"/upload\")  \npublic Result<String> upload(@RequestPart(\"file\") MultipartFile file) {  \n    String url = fileService.upload(file);  \n    return Result.ok(url);  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate MinioProperties minioProperties;  \n  \n// 上传  \n@Override  \npublic String upload(MultipartFile file) {  \n    try {  \n        // 创建一个Minio的客户端对象  \n        MinioClient minioClient = MinioClient.builder()  \n                .endpoint(minioProperties.getEndpointUrl())  \n                .credentials(minioProperties.getAccessKey(), minioProperties.getSecreKey())  \n                .build();  \n  \n        // 判断桶是否存在  \n        boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(minioProperties.getBucketName()).build());  \n        if (!found) {       // 如果不存在，那么此时就创建一个新的桶  \n            minioClient.makeBucket(MakeBucketArgs.builder().bucket(minioProperties.getBucketName()).build());  \n        } else {  // 如果存在打印信息  \n            System.out.println(\"Bucket 'daijia' already exists.\");  \n        }  \n  \n        // 设置存储对象名称  \n        String extFileName = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\".\"));  \n        String fileName = new SimpleDateFormat(\"yyyyMMdd\")  \n                .format(new Date()) + \"/\" + UUID.randomUUID().toString().replace(\"-\" , \"\") + \".\" + extFileName;  \n  \n        PutObjectArgs putObjectArgs = PutObjectArgs.builder()  \n                .bucket(minioProperties.getBucketName())  \n                .stream(file.getInputStream(), file.getSize(), -1)  \n                .object(fileName)  \n                .build();  \n        minioClient.putObject(putObjectArgs) ;  \n  \n        return minioProperties.getEndpointUrl() + \"/\" + minioProperties.getBucketName() + \"/\" + fileName ;  \n  \n    } catch (Exception e) {  \n        throw new GuiguException(ResultCodeEnum.DATA_ERROR);  \n    }  \n}\n```\n\n## 保存订单监控记录数据\n\n- 订单执行过程中，记录对话信息\n- 在前端小程序，同声传译，把录音转换文本，保存文本内存\n\n### 订单微服务接口.\n\n导入依赖\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-data-mongodb</artifactId>  \n</dependency>\n```\n\n添加MongoRepository\n```java\n@Repository  \npublic interface OrderMonitorRecordRepository extends MongoRepository<OrderMonitorRecord, String> {  \n}\n```\n\nOrderMonitorController\n```java\n@Autowired  \nprivate OrderMonitorService orderMonitorService;  \n  \n@Operation(summary = \"保存订单监控记录数据\")  \n@PostMapping(\"/saveOrderMonitorRecord\")  \npublic Result<Boolean> saveMonitorRecord(@RequestBody OrderMonitorRecord orderMonitorRecord) {  \n    return Result.ok(orderMonitorService.saveOrderMonitorRecord(orderMonitorRecord));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate OrderMonitorRecordRepository orderMonitorRecordRepository;  \n  \n// 保存订单监控记录数据  \n@Override  \npublic Boolean saveOrderMonitorRecord(OrderMonitorRecord orderMonitorRecord) {  \n    orderMonitorRecordRepository.save(orderMonitorRecord);  \n    return true;  \n}\n```\n\n### 远程调用\n\nOrderMonitorFeignClient\n```java\n/**  \n * 保存订单监控记录数据  \n * @param orderMonitorRecord  \n * @return  \n */  \n@PostMapping(\"/order/monitor/saveOrderMonitorRecord\")  \nResult<Boolean> saveMonitorRecord(@RequestBody OrderMonitorRecord orderMonitorRecord);\n```\n\n### 司机端web调用\n\nMonitorController\n```java\n@Autowired  \nprivate MonitorService monitorService;  \n  \n@Operation(summary = \"上传录音\")  \n@PostMapping(\"/upload\")  \npublic Result<Boolean> upload(@RequestParam(\"file\") MultipartFile file,  \n                              OrderMonitorForm orderMonitorForm) {  \n  \n    return Result.ok(monitorService.upload(file, orderMonitorForm));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate FileService fileService;  \n  \n@Autowired  \nprivate OrderMonitorFeignClient orderMonitorFeignClient;  \n  \n// 上传录音  \n@Override  \npublic Boolean upload(MultipartFile file, OrderMonitorForm orderMonitorForm) {  \n    //上传文件  \n    String url = fileService.upload(file);  \n  \n    OrderMonitorRecord orderMonitorRecord = new OrderMonitorRecord();  \n    orderMonitorRecord.setOrderId(orderMonitorForm.getOrderId());  \n    orderMonitorRecord.setFileUrl(url);  \n    orderMonitorRecord.setContent(orderMonitorForm.getContent());  \n    orderMonitorFeignClient.saveMonitorRecord(orderMonitorRecord);  \n  \n    return true;  \n}\n```\n\n\n## 订单监控审核\n\n使用腾讯云数据万象实现自动审核\n\n* 官方网址：https://cloud.tencent.com/product/ci\n\n### 腾讯云COS图片审核\n\n#### 封装图片审核方法\n\n在service-driver的CiService\n```java\nBoolean imageAuditing(String path);\n```\n\nCiServiceImpl\n```java\n@Service  \npublic class CiServiceImpl implements CiService {  \n  \n    @Autowired  \n    private TencentCloudProperties tencentCloudProperties;  \n  \n    //图片审核  \n    @Override  \n    public Boolean imageAuditing(String path) {  \n  \n        //1.创建任务请求对象  \n        ImageAuditingRequest request = new ImageAuditingRequest();  \n        //2.添加请求参数 参数详情请见 API 接口文档  \n        //2.1设置请求 bucket        request.setBucketName(tencentCloudProperties.getBucketPrivate());  \n        //2.2设置审核策略 不传则为默认策略（预设）  \n        //request.setBizType(\"\");  \n        //2.3设置 bucket 中的图片位置  \n        request.setObjectKey(path);  \n        //3.调用接口,获取任务响应对象  \n        COSClient client = this.getCosClient();  \n        ImageAuditingResponse response = client.imageAuditing(request);  \n        client.shutdown();  \n        //用于返回该审核场景的审核结果，返回值：0：正常。1：确认为当前场景的违规内容。2：疑似为当前场景的违规内容。  \n        if (!response.getPornInfo().getHitFlag().equals(\"0\")  \n                || !response.getAdsInfo().getHitFlag().equals(\"0\")  \n                || !response.getTerroristInfo().getHitFlag().equals(\"0\")  \n                || !response.getPoliticsInfo().getHitFlag().equals(\"0\")  \n        ) {  \n            return false;  \n        }  \n        return true;  \n    }  \n  \n    public COSClient getCosClient() {  \n        String secretId = tencentCloudProperties.getSecretId();  \n        String secretKey = tencentCloudProperties.getSecretKey();  \n        COSCredentials cred = new BasicCOSCredentials(secretId, secretKey);  \n        // 2 设置 bucket 的地域, COS 地域  \n        Region region = new Region(tencentCloudProperties.getRegion());  \n        ClientConfig clientConfig = new ClientConfig(region);  \n        // 这里建议设置使用 https 协议  \n        clientConfig.setHttpProtocol(HttpProtocol.https);  \n        // 3 生成 cos 客户端。  \n        COSClient cosClient = new COSClient(cred, clientConfig);  \n        return cosClient;  \n    }  \n}\n```\n\n#### 腾讯云COS图片添加审核\n\nCosServiceImpl\n```java\n@Autowired  \nprivate CiService ciService;  \n  \n@Override  \npublic CosUploadVo upload(MultipartFile file, String path) {  \n    //获取cosClient对象  \n    COSClient cosClient = this.getCosClient();  \n    //文件上传  \n    //元数据信息  \n    ObjectMetadata meta = new ObjectMetadata();  \n    meta.setContentLength(file.getSize());  \n    meta.setContentEncoding(\"UTF-8\");  \n    meta.setContentType(file.getContentType());  \n  \n    //向存储桶中保存文件  \n    String fileType = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\".\")); //文件后缀名  \n    String uploadPath = \"/driver/\" + path + \"/\" + UUID.randomUUID().toString().replaceAll(\"-\", \"\") + fileType;  \n    // 01.jpg  \n    // /driver/auth/0o98754.jpg    PutObjectRequest putObjectRequest = null;  \n    try {  \n        //1 bucket名称  \n        //2  \n        putObjectRequest = new PutObjectRequest(tencentCloudProperties.getBucketPrivate(),  \n                uploadPath,  \n                file.getInputStream(),  \n                meta);  \n    } catch (IOException e) {  \n        throw new RuntimeException(e);  \n    }  \n    putObjectRequest.setStorageClass(StorageClass.Standard);  \n    PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); //上传文件  \n    cosClient.shutdown();  \n  \n    // 图片审核  \n    Boolean imageAuditing = ciService.imageAuditing(uploadPath);  \n    if(!imageAuditing){  \n        cosClient.deleteObject(tencentCloudProperties.getBucketPrivate(), uploadPath);  \n        throw new GuiguException(ResultCodeEnum.IMAGE_AUDITION_FAIL);  \n    }  \n  \n    //返回vo对象  \n    CosUploadVo cosUploadVo = new CosUploadVo();  \n    cosUploadVo.setUrl(uploadPath);  \n    //图片临时访问url，回显使用  \n    String imageUrl = this.getImageUrl(uploadPath);  \n    cosUploadVo.setShowUrl(imageUrl);  \n    return cosUploadVo;  \n}\n```\n\n### 封装文本审核接口\n\n#### 司机微服务接口\n\nCiController\n```java\n@Autowired  \nprivate CiService ciService;  \n  \n@Operation(summary = \"文本审核\")  \n@PostMapping(\"/textAuditing\")  \npublic Result<TextAuditingVo> textAuditing(@RequestBody String content) {  \n    return Result.ok(ciService.textAuditing(content));  \n}\n```\n\nservice\n```java\n// 文本审核  \n@Override  \npublic TextAuditingVo textAuditing(String content) {  \n    if(!StringUtils.hasText(content)) {  \n        TextAuditingVo textAuditingVo = new TextAuditingVo();  \n        textAuditingVo.setResult(\"0\");  \n        return textAuditingVo;  \n    }  \n  \n    COSClient cosClient = this.getCosClient();  \n  \n    //1.创建任务请求对象  \n    TextAuditingRequest request = new TextAuditingRequest();  \n    //2.添加请求参数 参数详情请见 API 接口文档  \n    request.setBucketName(tencentCloudProperties.getBucketPrivate());  \n    //2.1.1设置请求内容,文本内容的Base64编码  \n    byte[] encoder = org.apache.commons.codec.binary.Base64.encodeBase64(content.getBytes());  \n    String contentBase64 = new String(encoder);  \n    request.getInput().setContent(contentBase64);  \n    request.getConf().setDetectType(\"all\");  \n  \n    //3.调用接口,获取任务响应对象  \n    TextAuditingResponse response = cosClient.createAuditingTextJobs(request);  \n    AuditingJobsDetail detail = response.getJobsDetail();  \n    TextAuditingVo textAuditingVo = new TextAuditingVo();  \n    if (\"Success\".equals(detail.getState())) {  \n        //检测结果: 0（审核正常），1 （判定为违规敏感文件），2（疑似敏感，建议人工复核）。  \n        String result = detail.getResult();  \n  \n        //违规关键词  \n        StringBuffer keywords = new StringBuffer();  \n        List<SectionInfo> sectionInfoList = detail.getSectionList();  \n        for (SectionInfo info : sectionInfoList) {  \n  \n            String pornInfoKeyword = info.getPornInfo().getKeywords();  \n            String illegalInfoKeyword = info.getIllegalInfo().getKeywords();  \n            String abuseInfoKeyword = info.getAbuseInfo().getKeywords();  \n  \n            if (pornInfoKeyword.length() > 0) {  \n                keywords.append(pornInfoKeyword).append(\",\");  \n            }  \n            if (illegalInfoKeyword.length() > 0) {  \n                keywords.append(illegalInfoKeyword).append(\",\");  \n            }  \n            if (abuseInfoKeyword.length() > 0) {  \n                keywords.append(abuseInfoKeyword).append(\",\");  \n            }  \n        }  \n        textAuditingVo.setResult(result);  \n        textAuditingVo.setKeywords(keywords.toString());  \n    }  \n    return textAuditingVo;  \n}\n```\n\n#### 远程调用\n\nCiFeignClient\n```java\n/**  \n * 文本审核  \n * @param content  \n * @return  \n */  \n@PostMapping(\"/ci/textAuditing\")  \nResult<TextAuditingVo> textAuditing(@RequestBody String content);\n```\n\n\n### 订单监控接口完善\n\n修改web-driver的MonitorServiceImpl\n```java\n@Autowired  \nprivate FileService fileService;  \n  \n@Autowired  \nprivate OrderMonitorFeignClient orderMonitorFeignClient;  \n  \n@Autowired  \nprivate CiFeignClient ciFeignClient;  \n  \n// 上传录音  \n@Override  \npublic Boolean upload(MultipartFile file, OrderMonitorForm orderMonitorForm) {  \n    //上传文件  \n    String url = fileService.upload(file);  \n  \n    OrderMonitorRecord orderMonitorRecord = new OrderMonitorRecord();  \n    orderMonitorRecord.setOrderId(orderMonitorForm.getOrderId());  \n    orderMonitorRecord.setFileUrl(url);  \n    orderMonitorRecord.setContent(orderMonitorForm.getContent());  \n  \n    // 文本审核  \n    TextAuditingVo textAuditingVo = ciFeignClient.textAuditing(orderMonitorForm.getContent()).getData();  \n    orderMonitorRecord.setResult(textAuditingVo.getResult());  \n    orderMonitorRecord.setKeywords(textAuditingVo.getKeywords());  \n  \n    orderMonitorFeignClient.saveMonitorRecord(orderMonitorRecord);  \n  \n    return true;  \n}\n```\n\n\n# 订单执行（三）\n\n## 计算订单实际里程\n\n- 在MongoDB保存订单过程中司机位置信息，把MongoDB存储司机位置信息获取出来，以时间排序，连接每个点，成为实际距离\n\n### 准备计算距离工具类\n\ncommon-util中的LocationUtil\n```java\npublic static double getDistance(double lat1, double lng1, double lat2,  \n                                 double lng2) {  \n    double radLat1 = rad(lat1);  \n    double radLat2 = rad(lat2);  \n    double a = radLat1 - radLat2;  \n    double b = rad(lng1) - rad(lng2);  \n    double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2)  \n            + Math.cos(radLat1) * Math.cos(radLat2)  \n            * Math.pow(Math.sin(b / 2), 2)));  \n    s = s * EARTH_RADIUS;  \n    s = Math.round(s * 10000d) / 10000d;  \n    s = s * 1000;  \n    return s;  \n}\n```\n\n### 地图微服务接口\n\nLocationController\n```java\n@Operation(summary = \"代驾服务：计算订单实际里程\")  \n@GetMapping(\"/calculateOrderRealDistance/{orderId}\")  \npublic Result<BigDecimal> calculateOrderRealDistance(@PathVariable Long orderId) {  \n    return Result.ok(locationService.calculateOrderRealDistance(orderId));  \n}\n```\n\nservice\n```java\n// 代驾服务：计算订单实际里程  \n@Override  \npublic BigDecimal calculateOrderRealDistance(Long orderId) {  \n    // 根据订单id获取位置信息，按照创建时间排序  \n    List<OrderServiceLocation> list =  \n            orderServiceLocationRepository.findByOrderIdOrderByCreateTimeAsc(orderId);  \n  \n    // 第一步查询返回订单位置信息list集合  \n    // 把list集合遍历，得到每个位置信息，计算两个位置距离，把计算所有距离相加操作  \n    double realDistance = 0;  \n    if(!CollectionUtils.isEmpty(list)) {  \n        for (int i = 0,size = list.size()-1; i < size; i++) {  \n            OrderServiceLocation location1 = list.get(i);  \n            OrderServiceLocation location2 = list.get(i + 1);  \n  \n            //计算位置距离  \n            double distance = LocationUtil.getDistance(location1.getLatitude().doubleValue(),  \n                    location1.getLongitude().doubleValue(),  \n                    location2.getLatitude().doubleValue(),  \n                    location2.getLongitude().doubleValue());  \n  \n            realDistance += distance;  \n        }  \n    }  \n      \n    return new BigDecimal(realDistance);  \n}\n```\n\n### 远程调用\n\nLocationFeignClient\n```java\n/**\n * 代驾服务：计算订单实际里程\n * @param orderId\n * @return\n */\n@GetMapping(\"/map/location/calculateOrderRealDistance/{orderId}\")\nResult<BigDecimal> calculateOrderRealDistance(@PathVariable Long orderId);\n```\n\n\n## 计算系统奖励\n\n### 创建规则文件\n\n```java\n//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问  \npackage  com.atguigu.daijia  \n  \nimport com.atguigu.daijia.model.form.rules.RewardRuleRequest;  \nimport java.math.BigDecimal;  \nimport java.math.RoundingMode;  \n  \nglobal com.atguigu.daijia.model.vo.rules.RewardRuleResponse rewardRuleResponse;  \n  \n/**  \n系统奖励  \n    00:00:00-06:59:59  完成5单后 奖励5元  \n    07:00:00-23:59:59  完成10单后 奖励2元  \n*/  \nrule \"00:00:00-06:59:59  完成5单后 每单奖励5元\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:RewardRuleRequest(startTime >= \"00:00:00\" && startTime <= \"06:59:59\" && orderNum > 5)  \n    then  \n        rewardRuleResponse.setRewardAmount(new BigDecimal(\"5.0\"));  \n        System.out.println(\"00:00:00-06:59:59 奖励：\" + rewardRuleResponse.getRewardAmount() + \"元\");  \nend  \nrule \"07:00:00-23:59:59  完成10单后 每单奖励2元\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:RewardRuleRequest(startTime >= \"07:00:00\" && startTime <= \"23:59:59\" && orderNum > 10)  \n    then  \n        rewardRuleResponse.setRewardAmount(new BigDecimal(\"2.0\"));  \n        System.out.println(\"00:00:00-06:59:59 奖励：\" + rewardRuleResponse.getRewardAmount() + \"元\");  \nend\n```\n\n### 添加规则引擎工具类\n\n在service-rules中utils包下创建\n```java\npublic class DroolsHelper {  \n  \n    private static final String RULES_CUSTOMER_RULES_DRL = \"rules/FeeRule.drl\";  \n  \n    public static KieSession loadForRule(String drlStr) {  \n        KieServices kieServices = KieServices.Factory.get();  \n  \n        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();  \n        kieFileSystem.write(  \n                ResourceFactory.newClassPathResource(drlStr));  \n  \n        KieBuilder kb = kieServices.newKieBuilder(kieFileSystem);  \n        kb.buildAll();  \n  \n        KieModule kieModule = kb.getKieModule();  \n        KieContainer kieContainer = kieServices.newKieContainer(kieModule.getReleaseId());  \n        return kieContainer.newKieSession();  \n    }  \n}\n```\n\n### 规则微服务接口\n\nRewardRuleController\n```java\n@Autowired  \nprivate RewardRuleService rewardRuleService;  \n  \n@Operation(summary = \"计算订单奖励费用\")  \n@PostMapping(\"/calculateOrderRewardFee\")  \npublic Result<RewardRuleResponseVo>  \ncalculateOrderRewardFee(@RequestBody RewardRuleRequestForm rewardRuleRequestForm) {  \n    return Result.ok(rewardRuleService.calculateOrderRewardFee(rewardRuleRequestForm));  \n}\n```\n\nservice\n```java\n// 计算订单奖励费用  \n@Override  \npublic RewardRuleResponseVo calculateOrderRewardFee(RewardRuleRequestForm rewardRuleRequestForm) {  \n    //封装传入参数对象  \n    RewardRuleRequest rewardRuleRequest = new RewardRuleRequest();  \n    rewardRuleRequest.setOrderNum(rewardRuleRequestForm.getOrderNum());  \n  \n    //创建规则引擎对象  \n    KieSession kieSession = DroolsHelper.loadForRule(RULES_CUSTOMER_RULES_DRL);  \n  \n    //封装返回对象  \n    RewardRuleResponse rewardRuleResponse = new RewardRuleResponse();  \n    kieSession.setGlobal(\"rewardRuleResponse\",rewardRuleResponse);  \n  \n    //设置对象，触发规则  \n    kieSession.insert(rewardRuleRequest);  \n    kieSession.fireAllRules();  \n  \n    //终止会话  \n    kieSession.dispose();  \n  \n    //封装RewardRuleResponseVo  \n    RewardRuleResponseVo rewardRuleResponseVo = new RewardRuleResponseVo();  \n    rewardRuleResponseVo.setRewardAmount(rewardRuleResponse.getRewardAmount());  \n    return rewardRuleResponseVo;  \n}\n```\n\n### 远程调用\n\nRewardRuleFeignClient\n```java\n/**\n * 计算订单奖励费用\n * @param rewardRuleRequestForm\n * @return\n */\n@PostMapping(\"/rules/reward/calculateOrderRewardFee\")\nResult<RewardRuleResponseVo> calculateOrderRewardFee(@RequestBody RewardRuleRequestForm rewardRuleRequestForm);\n```\n\n## 根据时间段获取订单数量\n\n### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"根据时间段获取订单数\")  \n@GetMapping(\"/getOrderNumByTime/{startTime}/{endTime}\")  \npublic Result<Long> getOrderNumByTime(@PathVariable String startTime, @PathVariable String endTime) {  \n    return Result.ok(orderInfoService.getOrderNumByTime(startTime, endTime));  \n}\n```\n\nservice\n```java\n// 根据时间段获取订单数  \n@Override  \npublic Long getOrderNumByTime(String startTime, String endTime) {  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.ge(OrderInfo::getStartServiceTime,startTime);  \n    wrapper.lt(OrderInfo::getStartServiceTime,endTime);  \n    Long count = orderInfoMapper.selectCount(wrapper);  \n    return count;  \n}\n```\n\n### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n *  根据时间段获取订单数  \n * @param startTime  \n * @param endTime  \n * @return  \n */  \n@GetMapping(\"/order/info/getOrderNumByTime/{startTime}/{endTime}\")  \nResult<Long> getOrderNumByTime(@PathVariable(\"startTime\") String startTime, @PathVariable(\"endTime\") String endTime);\n```\n\n## 计算分账信息\n\n### 创建规则文件\n```drools\n//package对应的不一定是真正的目录，可以任意写com.abc，同一个包下的drl文件可以相互访问  \npackage  com.atguigu.daijia  \n  \nimport com.atguigu.daijia.model.form.rules.ProfitsharingRuleRequest;  \nimport java.math.BigDecimal;  \nimport java.math.RoundingMode;  \n  \nglobal com.atguigu.daijia.model.vo.rules.ProfitsharingRuleResponse profitsharingRuleResponse;  \n//支付微信平台费率：0.6%  \n//global BigDecimal paymentRate = new BigDecimal(0.006);  \n/**  \n支付微信平台费用  \n    平台费率：0.6%  \n*/  \nrule \"支付微信平台费用 平台费率：0.6%\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:ProfitsharingRuleRequest()  \n    then  \n        profitsharingRuleResponse.setOrderAmount($rule.getOrderAmount());  \n        profitsharingRuleResponse.setPaymentRate(new BigDecimal(\"0.006\"));  \n        BigDecimal paymentFee = profitsharingRuleResponse.getOrderAmount().multiply(profitsharingRuleResponse.getPaymentRate()).setScale(2, RoundingMode.HALF_UP);  \n        profitsharingRuleResponse.setPaymentFee(paymentFee);  \n        System.out.println(\"支付微信平台费用：\" + profitsharingRuleResponse.getPaymentFee() + \"元\");  \nend  \n  \n/**  \n订单金额小于等于100  \n    当天完成订单小于等于10单 平台抽成 20%  \n    当天完成订单大于10单 平台抽成 18%  \n*/  \nrule \"订单金额小于等于100 当天完成订单小于等于10单\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() <= 100.0 && orderNum <= 10)  \n    then  \n        BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());  \n        BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(\"0.2\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);  \n        //代驾司机个税，税率：10%  \n        BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);  \n        profitsharingRuleResponse.setPlatformIncome(platformIncome);  \n        profitsharingRuleResponse.setDriverIncome(driverIncome);  \n        profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(\"0.1\"));  \n        profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);  \n        System.out.println(\"平台分账收入：\" + platformIncome + \"元\" + \"，司机分账收入：\" + driverIncome + \"元\" + \"，司机个税：\" + driverTaxFee + \"元\");  \nend  \nrule \"订单金额小于等于100 天完成订单大于10单\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() <= 100.0 && orderNum > 10)  \n    then  \n        BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());  \n        BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(\"0.18\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);  \n        //代驾司机个税，税率：10%  \n        BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);  \n        profitsharingRuleResponse.setPlatformIncome(platformIncome);  \n        profitsharingRuleResponse.setDriverIncome(driverIncome);  \n        profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(\"0.1\"));  \n        profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);  \n        System.out.println(\"平台分账收入：\" + platformIncome + \"元\" + \"，司机分账收入：\" + driverIncome + \"元\" + \"，司机个税：\" + driverTaxFee + \"元\");  \nend  \n  \n/**  \n订单金额大于100  \n    当天完成订单小于等于10单 平台抽成 18%  \n    当天完成订单大于10单 平台抽成 16%  \n*/  \nrule \"订单金额大于100 当天完成订单小于等于10单\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() > 100.0 && orderNum <= 10)  \n    then  \n        BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());  \n        BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(\"0.18\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);  \n        //代驾司机个税，税率：10%  \n        BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);  \n        profitsharingRuleResponse.setPlatformIncome(platformIncome);  \n        profitsharingRuleResponse.setDriverIncome(driverIncome);  \n        profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(\"0.1\"));  \n        profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);  \n        System.out.println(\"平台分账收入：\" + platformIncome + \"元\" + \"，司机分账收入：\" + driverIncome + \"元\" + \"，司机个税：\" + driverTaxFee + \"元\");  \nend  \nrule \"订单金额大于100 天完成订单大于10单\"  \n    salience 10          //指定优先级，数值越大优先级越高，不指定的情况下由上到下执行  \n    no-loop true         //防止陷入死循环  \n    when  \n        /*规则条件，到工作内存中查找FeeRuleRequest对象  \n        里面出来的结果只能是ture或者false  \n        $rule是绑定变量名，可以任意命名，官方推荐$符号，定义了绑定变量名，可以在then部分操作fact对象*/  \n        $rule:ProfitsharingRuleRequest(orderAmount.doubleValue() > 100.0 && orderNum > 10)  \n    then  \n        BigDecimal totalAmount = profitsharingRuleResponse.getOrderAmount().subtract(profitsharingRuleResponse.getPaymentFee());  \n        BigDecimal platformIncome = totalAmount.multiply(new BigDecimal(\"0.18\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverTotalIncome = totalAmount.subtract(platformIncome);  \n        //代驾司机个税，税率：10%  \n        BigDecimal driverTaxFee = driverTotalIncome.multiply(new BigDecimal(\"0.1\")).setScale(2, RoundingMode.HALF_UP);  \n        BigDecimal driverIncome = driverTotalIncome.subtract(driverTaxFee);  \n        profitsharingRuleResponse.setPlatformIncome(platformIncome);  \n        profitsharingRuleResponse.setDriverIncome(driverIncome);  \n        profitsharingRuleResponse.setDriverTaxRate(new BigDecimal(\"0.1\"));  \n        profitsharingRuleResponse.setDriverTaxFee(driverTaxFee);  \n        System.out.println(\"平台分账收入：\" + platformIncome + \"元\" + \"，司机分账收入：\" + driverIncome + \"元\" + \"，司机个税：\" + driverTaxFee + \"元\");  \nend\n```\n\n### 规则微服务接口\n\nProfitsharingRuleController\n```java\n@Autowired  \nprivate ProfitsharingRuleService profitsharingRuleService;  \n  \n@Operation(summary = \"计算系统分账费用\")  \n@PostMapping(\"/calculateOrderProfitsharingFee\")  \npublic Result<ProfitsharingRuleResponseVo> calculateOrderProfitsharingFee(@RequestBody ProfitsharingRuleRequestForm profitsharingRuleRequestForm) {  \n    return Result.ok(profitsharingRuleService.calculateOrderProfitsharingFee(profitsharingRuleRequestForm));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate ProfitsharingRuleMapper rewardRuleMapper;  \n  \nprivate static final String RULES_CUSTOMER_RULES_DRL = \"rules/ProfitsharingRule.drl\";  \n  \n@Override  \npublic ProfitsharingRuleResponseVo calculateOrderProfitsharingFee(ProfitsharingRuleRequestForm profitsharingRuleRequestForm) {  \n    //传入参数对象封装  \n    ProfitsharingRuleRequest profitsharingRuleRequest = new ProfitsharingRuleRequest();  \n    profitsharingRuleRequest.setOrderAmount(profitsharingRuleRequestForm.getOrderAmount());  \n    profitsharingRuleRequest.setOrderNum(profitsharingRuleRequestForm.getOrderNum());  \n  \n    //创建kieSession  \n    KieSession kieSession = DroolsHelper.loadForRule(RULES_CUSTOMER_RULES_DRL);  \n  \n    //封装返回对象  \n    ProfitsharingRuleResponse profitsharingRuleResponse = new ProfitsharingRuleResponse();  \n    kieSession.setGlobal(\"profitsharingRuleResponse\",profitsharingRuleResponse);  \n  \n    //触发规则，返回vo对象  \n    kieSession.insert(profitsharingRuleRequest);  \n    kieSession.fireAllRules();  \n    kieSession.dispose();  \n  \n    ProfitsharingRuleResponseVo profitsharingRuleResponseVo = new ProfitsharingRuleResponseVo();  \n    BeanUtils.copyProperties(profitsharingRuleResponse,profitsharingRuleResponseVo);  \n  \n    return profitsharingRuleResponseVo;  \n}\n```\n\n### 远程调用\n\nProfitsharingRuleFeignClient\n```java\n/**  \n * 计算订单分账数据  \n * @param profitsharingRuleRequestForm  \n * @return  \n */  \n@PostMapping(\"/rules/profitsharing/calculateOrderProfitsharingFee\")  \nResult<ProfitsharingRuleResponseVo> calculateOrderProfitsharingFee(@RequestBody ProfitsharingRuleRequestForm profitsharingRuleRequestForm);\n```\n\n## 结束服务更新订单\n\n* 更新订单数据：订单状态、订单实际距离、订单实际金额等\n* 添加实际账单信息\n* 添加分账信息\n\n### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"结束代驾服务更新订单账单\")  \n@PostMapping(\"/endDrive\")  \npublic Result<Boolean> endDrive(@RequestBody UpdateOrderBillForm updateOrderBillForm) {  \n    return Result.ok(orderInfoService.endDrive(updateOrderBillForm));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate OrderBillMapper orderBillMapper;\n\n@Autowired  \nprivate OrderProfitsharingMapper orderProfitsharingMapper;\n\n// 结束代驾服务更新订单账单  \n@Override  \npublic Boolean endDrive(UpdateOrderBillForm updateOrderBillForm) {  \n    // 更新订单信息  \n    LambdaQueryWrapper<OrderInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderInfo::getId,updateOrderBillForm.getOrderId());  \n    wrapper.eq(OrderInfo::getDriverId,updateOrderBillForm.getDriverId());  \n  \n    OrderInfo orderInfo = new OrderInfo();  \n    orderInfo.setStatus(OrderStatus.END_SERVICE.getStatus());  \n    orderInfo.setRealAmount(updateOrderBillForm.getTotalAmount());  \n    orderInfo.setFavourFee(updateOrderBillForm.getFavourFee());  \n    orderInfo.setRealDistance(updateOrderBillForm.getRealDistance());  \n    orderInfo.setEndServiceTime(new Date());  \n  \n    int rows = orderInfoMapper.update(orderInfo, wrapper);  \n  \n    if(rows == 1) {  \n        //添加账单数据  \n        OrderBill orderBill = new OrderBill();  \n        BeanUtils.copyProperties(updateOrderBillForm,orderBill);  \n        orderBill.setOrderId(updateOrderBillForm.getOrderId());  \n        orderBill.setPayAmount(updateOrderBillForm.getTotalAmount());  \n        orderBillMapper.insert(orderBill);  \n  \n        //添加分账信息  \n        OrderProfitsharing orderProfitsharing = new OrderProfitsharing();  \n        BeanUtils.copyProperties(updateOrderBillForm, orderProfitsharing);  \n        orderProfitsharing.setOrderId(updateOrderBillForm.getOrderId());  \n        orderProfitsharing.setRuleId(updateOrderBillForm.getProfitsharingRuleId());  \n        orderProfitsharing.setStatus(1);  \n        orderProfitsharingMapper.insert(orderProfitsharing);  \n  \n    } else {  \n        throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);  \n    }  \n    return true;  \n}\n```\n\n### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 结束代驾服务更新订单账单  \n * @param updateOrderBillForm  \n * @return  \n */  \n@PostMapping(\"/order/info/endDrive\")  \nResult<Boolean> endDrive(@RequestBody UpdateOrderBillForm updateOrderBillForm);\n```\n\n## 结束服务\n\nweb-driver中的OrderController\n```java\n@Operation(summary = \"结束代驾服务更新订单账单\")  \n@LoginDetection  \n@PostMapping(\"/endDrive\")  \npublic Result<Boolean> endDrive(@RequestBody OrderFeeForm orderFeeForm) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    orderFeeForm.setDriverId(driverId);  \n    return Result.ok(orderService.endDrive(orderFeeForm));  \n}\n```\n\nservice\n```java\n@Autowired  \nprivate LocationFeignClient locationFeignClient;  \n  \n@Autowired  \nprivate FeeRuleFeignClient feeRuleFeignClient;  \n  \n@Autowired  \nprivate RewardRuleFeignClient rewardRuleFeignClient;  \n  \n@Autowired  \nprivate ProfitsharingRuleFeignClient profitsharingRuleFeignClient;\n\n// 结束代驾服务更新订单账单  \n@Override  \npublic Boolean endDrive(OrderFeeForm orderFeeForm) {  \n    // 根据orderId获取订单信息，判断当前订单是否司机接单  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();  \n    if(orderInfo.getDriverId() != orderFeeForm.getDriverId()) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    // 计算订单实际里程  \n    BigDecimal realDistance =  \n            locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();  \n  \n    // 计算代驾实际费用  \n    //封装FeeRuleRequestForm  \n    FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();  \n    feeRuleRequestForm.setDistance(realDistance);  \n    feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n  \n    //计算司机到达代驾开始位置时间  \n    Integer waitMinute =  \n            Math.abs((int)((orderInfo.getStartServiceTime().getTime()-orderInfo.getArriveTime().getTime())/(1000 * 60)));  \n    feeRuleRequestForm.setWaitMinute(waitMinute);  \n    //远程调用 代驾费用  \n    FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();  \n    //实际费用 = 代驾费用 + 其他费用（停车费）  \n    BigDecimal totalAmount =  \n            feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())  \n                    .add(orderFeeForm.getParkingFee())  \n                    .add(orderFeeForm.getOtherFee())  \n                    .add(orderInfo.getFavourFee());  \n    feeRuleResponseVo.setTotalAmount(totalAmount);  \n  \n    // 计算系统奖励  \n    String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 00:00:00\";  \n    String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 24:00:00\";  \n    Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();  \n  \n    RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();  \n    rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n    rewardRuleRequestForm.setOrderNum(orderNum);  \n  \n    RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();  \n  \n    // 计算分账信息  \n    ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();  \n    profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());  \n    profitsharingRuleRequestForm.setOrderNum(orderNum);  \n  \n    ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();  \n  \n    // 封装实体类，结束代驾更新订单，添加账单和分账信息  \n    UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();  \n    updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());  \n    updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());  \n    //路桥费、停车费、其他费用  \n    updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());  \n    updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());  \n    updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());  \n    //乘客好处费  \n    updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());  \n  \n    //实际里程  \n    updateOrderBillForm.setRealDistance(realDistance);  \n    //订单奖励信息  \n    BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);  \n    //代驾费用信息  \n    BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);  \n    //分账相关信息  \n    BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);  \n    updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());  \n    orderInfoFeignClient.endDrive(updateOrderBillForm);  \n  \n    return true;  \n}\n```\n\n## 添加位置限定\n\n修改之前web-driver中OrderServiceImpl编写的方法，在开始订单做判断\n```java\n//司机到达代驾起始地点  \n@Override  \npublic Boolean driverArriveStartLocation(Long orderId, Long driverId) {  \n    //判断  \n    // orderInfo有代驾开始位置  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();  \n  \n    //司机当前位置  \n    OrderLocationVo orderLocationVo = locationFeignClient.getCacheOrderLocation(orderId).getData();  \n  \n    //司机当前位置 和 代驾开始位置距离  \n    double distance = LocationUtil.getDistance(orderInfo.getStartPointLatitude().doubleValue(),  \n            orderInfo.getStartPointLongitude().doubleValue(),  \n            orderLocationVo.getLatitude().doubleValue(),  \n            orderLocationVo.getLongitude().doubleValue());  \n    if(distance > SystemConstant.DRIVER_START_LOCATION_DISTION) {  \n        throw new GuiguException(ResultCodeEnum.DRIVER_START_LOCATION_DISTION_ERROR);  \n    }  \n  \n    return orderInfoFeignClient.driverArriveStartLocation(orderId,driverId).getData();  \n}\n```\n\n结束订单也是一样\n```java\n// 结束代驾服务更新订单账单  \n@Override  \npublic Boolean endDrive(OrderFeeForm orderFeeForm) {  \n    // 根据orderId获取订单信息，判断当前订单是否司机接单  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();  \n    if(orderInfo.getDriverId() != orderFeeForm.getDriverId()) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    // 判断距离  \n    OrderServiceLastLocationVo orderServiceLastLocationVo = locationFeignClient.getOrderServiceLastLocation(orderFeeForm.getOrderId()).getData();  \n  \n    //司机当前位置 距离 结束代驾位置  \n    double distance = LocationUtil.getDistance(orderInfo.getEndPointLatitude().doubleValue(),  \n            orderInfo.getEndPointLongitude().doubleValue(),  \n            orderServiceLastLocationVo.getLatitude().doubleValue(),  \n            orderServiceLastLocationVo.getLongitude().doubleValue());  \n    if(distance > SystemConstant.DRIVER_END_LOCATION_DISTION) {  \n        throw new GuiguException(ResultCodeEnum.DRIVER_END_LOCATION_DISTION_ERROR);  \n    }  \n  \n    // 计算订单实际里程  \n    BigDecimal realDistance =  \n            locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();  \n  \n    // 计算代驾实际费用  \n    //封装FeeRuleRequestForm  \n    FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();  \n    feeRuleRequestForm.setDistance(realDistance);  \n    feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n  \n    //计算司机到达代驾开始位置时间  \n    Integer waitMinute =  \n            Math.abs((int)((orderInfo.getStartServiceTime().getTime()-orderInfo.getArriveTime().getTime())/(1000 * 60)));  \n    feeRuleRequestForm.setWaitMinute(waitMinute);  \n    //远程调用 代驾费用  \n    FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();  \n    //实际费用 = 代驾费用 + 其他费用（停车费）  \n    BigDecimal totalAmount =  \n            feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())  \n                    .add(orderFeeForm.getParkingFee())  \n                    .add(orderFeeForm.getOtherFee())  \n                    .add(orderInfo.getFavourFee());  \n    feeRuleResponseVo.setTotalAmount(totalAmount);  \n  \n    // 计算系统奖励  \n    String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 00:00:00\";  \n    String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 24:00:00\";  \n    Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();  \n  \n    RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();  \n    rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n    rewardRuleRequestForm.setOrderNum(orderNum);  \n  \n    RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();  \n  \n    // 计算分账信息  \n    ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();  \n    profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());  \n    profitsharingRuleRequestForm.setOrderNum(orderNum);  \n  \n    ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();  \n  \n    // 封装实体类，结束代驾更新订单，添加账单和分账信息  \n    UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();  \n    updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());  \n    updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());  \n    //路桥费、停车费、其他费用  \n    updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());  \n    updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());  \n    updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());  \n    //乘客好处费  \n    updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());  \n  \n    //实际里程  \n    updateOrderBillForm.setRealDistance(realDistance);  \n    //订单奖励信息  \n    BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);  \n    //代驾费用信息  \n    BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);  \n    //分账相关信息  \n    BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);  \n    updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());  \n    orderInfoFeignClient.endDrive(updateOrderBillForm);  \n  \n    return true;  \n}\n```\n\n\n# 我的订单和异步编排\n\n## 我的订单\n\n- 乘客端或司机端，都有我的订单，都可以查看用户所有的订单\n\n### 乘客端我的订单\n\n#### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"获取乘客订单分页列表\")  \n@GetMapping(\"/findCustomerOrderPage/{customerId}/{page}/{limit}\")  \npublic Result<PageVo> findCustomerOrderPage(@PathVariable Long customerId,  \n                                            @PathVariable Long page,  \n                                            @PathVariable Long limit) {  \n    //创建page对象  \n    Page<OrderInfo> pageParam = new Page<>(page,limit);  \n    //调用service方法实现分页条件查询  \n    PageVo pageVo = orderInfoService.findCustomerOrderPage(pageParam,customerId);  \n    pageVo.setPage(page);  \n    pageVo.setLimit(limit);  \n    return Result.ok(pageVo);  \n}\n```\n\nservice\n```java\n//获取乘客订单分页列表  \n@Override  \npublic PageVo findCustomerOrderPage(Page<OrderInfo> pageParam, Long customerId) {  \n    IPage<OrderListVo> pageInfo =  orderInfoMapper.selectCustomerOrderPage(pageParam,customerId);  \n    return new PageVo<>(pageInfo.getRecords(),pageInfo.getPages(),pageInfo.getTotal());  \n}\n```\n\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 获取乘客订单分页列表  \n * @param customerId  \n * @param page  \n * @param limit  \n * @return  \n */  \n@GetMapping(\"/order/info/findCustomerOrderPage/{customerId}/{page}/{limit}\")  \nResult<PageVo> findCustomerOrderPage(@PathVariable(\"customerId\") Long customerId,  \n                                     @PathVariable(\"page\") Long page,  \n                                     @PathVariable(\"limit\") Long limit);\n```\n\n#### 乘客web端调用\n\nOrderController\n```java\n@Operation(summary = \"获取乘客订单分页列表\")  \n@LoginDetection  \n@GetMapping(\"findCustomerOrderPage/{page}/{limit}\")  \npublic Result<PageVo> findCustomerOrderPage(  \n        @Parameter(name = \"page\", description = \"当前页码\", required = true)  \n        @PathVariable Long page,  \n  \n        @Parameter(name = \"limit\", description = \"每页记录数\", required = true)  \n        @PathVariable Long limit) {  \n    Long customerId = AuthContextHolder.getUserId();  \n    PageVo pageVo = orderService.findCustomerOrderPage(customerId, page, limit);  \n    return Result.ok(pageVo);  \n}\n```\n\nservice\n```java\n// 获取乘客订单分页列表  \n@Override  \npublic PageVo findCustomerOrderPage(Long customerId, Long page, Long limit) {  \n    return orderInfoFeignClient.findCustomerOrderPage(customerId,page,limit).getData();  \n}\n```\n\nxml\n```xml\n    <!--查询乘客订单分页-->\n    <select id=\"selectCustomerOrderPage\" resultType=\"com.atguigu.daijia.model.vo.order.OrderListVo\">\n        select\n            info.id,\n            info.order_no,\n            info.start_location,\n            info.end_location,\n\n            if(info.status &lt; 7, info.expect_amount, bill.pay_amount) as amount,\n\n            info.status,\n            info.create_time\n        from order_info info left join order_bill bill on info.id = bill.order_id\n        where info.customer_id = #{customerId}\n          and info.is_deleted =0\n        order by info.create_time desc\n    </select>\n```\n\n### 司机端我的订单\n\n#### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"获取司机订单分页列表\")  \n@GetMapping(\"/findDriverOrderPage/{driverId}/{page}/{limit}\")  \npublic Result<PageVo> findDriverOrderPage(  \n        @Parameter(name = \"driverId\", description = \"司机id\", required = true)  \n        @PathVariable Long driverId,  \n        @Parameter(name = \"page\", description = \"当前页码\", required = true)  \n        @PathVariable Long page,  \n        @Parameter(name = \"limit\", description = \"每页记录数\", required = true)  \n        @PathVariable Long limit) {  \n    Page<OrderInfo> pageParam = new Page<>(page, limit);  \n    PageVo pageVo = orderInfoService.findDriverOrderPage(pageParam, driverId);  \n    pageVo.setPage(page);  \n    pageVo.setLimit(limit);  \n    return Result.ok(pageVo);  \n}\n```\n\nservice\n```java\n// 获取司机订单分页列表  \n@Override  \npublic PageVo findDriverOrderPage(Page<OrderInfo> pageParam, Long driverId) {  \n    IPage<OrderListVo> pageInfo =  orderInfoMapper.selectDriverOrderPage(pageParam,driverId);  \n    return new PageVo<>(pageInfo.getRecords(),pageInfo.getPages(),pageInfo.getTotal());  \n}\n```\n\nxml\n```xml\n<select id=\"selectDriverOrderPage\" resultType=\"com.atguigu.daijia.model.vo.order.OrderListVo\">\n    select\n        info.id,\n        info.order_no,\n        info.start_location,\n        info.end_location,\n        real_amount as pay_amount,\n        if(info.status &lt; 7, info.expect_amount, info.real_amount) as amount,\n\n        info.status,\n        info.create_time\n    from order_info info\n    where info.driver_id = #{driverId}\n    and info.is_deleted =0\n    order by info.create_time desc\n</select>\n```\n\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 获取司机订单分页列表  \n * @param driverId  \n * @param page  \n * @param limit  \n * @return  \n */  \n@GetMapping(\"/order/info/findDriverOrderPage/{driverId}/{page}/{limit}\")  \nResult<PageVo> findDriverOrderPage(@PathVariable(\"driverId\") Long driverId,  \n                                   @PathVariable(\"page\") Long page,  \n                                   @PathVariable(\"limit\") Long limit);\n```\n\n#### 司机端web接口\n\nOrderController\n```java\n@Operation(summary = \"获取司机订单分页列表\")  \n@LoginDetection  \n@GetMapping(\"findDriverOrderPage/{page}/{limit}\")  \npublic Result<PageVo> findDriverOrderPage(  \n        @Parameter(name = \"page\", description = \"当前页码\", required = true)  \n        @PathVariable Long page,  \n        @Parameter(name = \"limit\", description = \"每页记录数\", required = true)  \n        @PathVariable Long limit) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    PageVo pageVo = orderService.findDriverOrderPage(driverId, page, limit);  \n    return Result.ok(pageVo);  \n}\n```\n\nservice\n```java\n// 获取司机订单分页列表  \n@Override  \npublic PageVo findDriverOrderPage(Long driverId, Long page, Long limit) {  \n    return orderInfoFeignClient.findDriverOrderPage(driverId,page,limit).getData();  \n}\n```\n\n## 异步编排\n\n- 问题：司机结束订单后会有大量的远程调用，如果按照流程来会浪费大量时间\n- 解决：使用多线程方式来完成这些操作\n\n### 创建自定义线程池\n\n在config包下创建类ThreadPoolConfig\n```java\n@Configuration  \npublic class ThreadPoolConfig {  \n  \n    @Bean  \n    public ThreadPoolExecutor threadPoolExecutor() {  \n  \n        //动态获取服务器核数  \n        int processors = Runtime.getRuntime().availableProcessors();  \n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(  \n                processors+1, // 核心线程个数 io:2n ,cpu: n+1  n:内核数据  \n                processors+1,  \n                0,  \n                TimeUnit.SECONDS,  \n                new ArrayBlockingQueue<>(3),  \n                Executors.defaultThreadFactory(),  \n                new ThreadPoolExecutor.AbortPolicy()  \n        );  \n        return threadPoolExecutor;  \n    }  \n}\n```\n\n### 修改web-driver之前的代码\n\n修改前面driver-web里OrderServiceImpl的endDrive方法\n```java\n//使用多线程CompletableFuture实现  \n@SneakyThrows  \npublic Boolean endDrive(OrderFeeForm orderFeeForm) {  \n  \n    //1 根据orderId获取订单信息，判断当前订单是否司机接单  \n    CompletableFuture<OrderInfo> orderInfoCompletableFuture = CompletableFuture.supplyAsync(() -> {  \n        OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderFeeForm.getOrderId()).getData();  \n        if (orderInfo.getDriverId() != orderFeeForm.getDriverId()) {  \n            throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n        }  \n        return orderInfo;  \n    });  \n  \n    //防止刷单  \n    CompletableFuture<OrderServiceLastLocationVo> orderServiceLastLocationVoCompletableFuture = CompletableFuture.supplyAsync(() -> {  \n        OrderServiceLastLocationVo orderServiceLastLocationVo = locationFeignClient.getOrderServiceLastLocation(orderFeeForm.getOrderId()).getData();  \n        return orderServiceLastLocationVo;  \n    });  \n  \n    //上面两个合并  \n    CompletableFuture.allOf(orderInfoCompletableFuture,  \n            orderServiceLastLocationVoCompletableFuture).join();  \n  \n    //获取两个线程执行结果  \n    OrderInfo orderInfo = orderInfoCompletableFuture.get();  \n  \n    OrderServiceLastLocationVo orderServiceLastLocationVo = orderServiceLastLocationVoCompletableFuture.get();  \n  \n    //司机当前位置 距离 结束代驾位置  \n    double distance = LocationUtil.getDistance(orderInfo.getEndPointLatitude().doubleValue(),  \n            orderInfo.getEndPointLongitude().doubleValue(),  \n            orderServiceLastLocationVo.getLatitude().doubleValue(),  \n            orderServiceLastLocationVo.getLongitude().doubleValue());  \n    if(distance > SystemConstant.DRIVER_END_LOCATION_DISTION) {  \n        throw new GuiguException(ResultCodeEnum.DRIVER_END_LOCATION_DISTION_ERROR);  \n    }  \n  \n    //2 计算订单实际里程  \n    CompletableFuture<BigDecimal> realDistanceCompletableFuture = CompletableFuture.supplyAsync(() -> {  \n        BigDecimal realDistance =  \n                locationFeignClient.calculateOrderRealDistance(orderFeeForm.getOrderId()).getData();  \n        return realDistance;  \n    });  \n  \n    //3 计算代驾实际费用  \n    CompletableFuture<FeeRuleResponseVo> feeRuleResponseVoCompletableFuture =  \n            realDistanceCompletableFuture.thenApplyAsync((realDistance) -> {  \n                //远程调用，计算代驾费用  \n                //封装FeeRuleRequestForm  \n                FeeRuleRequestForm feeRuleRequestForm = new FeeRuleRequestForm();  \n                feeRuleRequestForm.setDistance(realDistance);  \n                feeRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n  \n                //计算司机到达代驾开始位置时间  \n                //orderInfo.getArriveTime() - orderInfo.getAcceptTime()  \n                // 分钟 = 毫秒 / 1000 * 60                Integer waitMinute =  \n                        Math.abs((int) ((orderInfo.getArriveTime().getTime() - orderInfo.getAcceptTime().getTime()) / (1000 * 60)));  \n                feeRuleRequestForm.setWaitMinute(waitMinute);  \n                //远程调用 代驾费用  \n                FeeRuleResponseVo feeRuleResponseVo = feeRuleFeignClient.calculateOrderFee(feeRuleRequestForm).getData();  \n                //实际费用 = 代驾费用 + 其他费用（停车费）  \n                BigDecimal totalAmount =  \n                        feeRuleResponseVo.getTotalAmount().add(orderFeeForm.getTollFee())  \n                                .add(orderFeeForm.getParkingFee())  \n                                .add(orderFeeForm.getOtherFee())  \n                                .add(orderInfo.getFavourFee());  \n                feeRuleResponseVo.setTotalAmount(totalAmount);  \n                return feeRuleResponseVo;  \n            });  \n  \n    //4 计算系统奖励  \n    CompletableFuture<Long> orderNumCompletableFuture = CompletableFuture.supplyAsync(() -> {  \n        String startTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 00:00:00\";  \n        String endTime = new DateTime(orderInfo.getStartServiceTime()).toString(\"yyyy-MM-dd\") + \" 24:00:00\";  \n        Long orderNum = orderInfoFeignClient.getOrderNumByTime(startTime, endTime).getData();  \n        return orderNum;  \n    });  \n  \n    CompletableFuture<RewardRuleResponseVo> rewardRuleResponseVoCompletableFuture =  \n            orderNumCompletableFuture.thenApplyAsync((orderNum) -> {  \n                //4.2.封装参数  \n                RewardRuleRequestForm rewardRuleRequestForm = new RewardRuleRequestForm();  \n                rewardRuleRequestForm.setStartTime(orderInfo.getStartServiceTime());  \n                rewardRuleRequestForm.setOrderNum(orderNum);  \n                RewardRuleResponseVo rewardRuleResponseVo = rewardRuleFeignClient.calculateOrderRewardFee(rewardRuleRequestForm).getData();  \n  \n                return rewardRuleResponseVo;  \n            });  \n  \n  \n    //5 计算分账信息  \n    CompletableFuture<ProfitsharingRuleResponseVo> profitsharingRuleResponseVoCompletableFuture = feeRuleResponseVoCompletableFuture.thenCombineAsync(orderNumCompletableFuture,  \n            (feeRuleResponseVo, orderNum) -> {  \n                ProfitsharingRuleRequestForm profitsharingRuleRequestForm = new ProfitsharingRuleRequestForm();  \n                profitsharingRuleRequestForm.setOrderAmount(feeRuleResponseVo.getTotalAmount());  \n                profitsharingRuleRequestForm.setOrderNum(orderNum);  \n  \n                ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleFeignClient.calculateOrderProfitsharingFee(profitsharingRuleRequestForm).getData();  \n                return profitsharingRuleResponseVo;  \n            });  \n  \n    //合并  \n    CompletableFuture.allOf(  \n            orderInfoCompletableFuture,  \n            realDistanceCompletableFuture,  \n            feeRuleResponseVoCompletableFuture,  \n            orderNumCompletableFuture,  \n            rewardRuleResponseVoCompletableFuture,  \n            profitsharingRuleResponseVoCompletableFuture  \n    ).join();  \n  \n    //获取执行结果  \n    BigDecimal realDistance = realDistanceCompletableFuture.get();  \n    FeeRuleResponseVo feeRuleResponseVo = feeRuleResponseVoCompletableFuture.get();  \n    RewardRuleResponseVo rewardRuleResponseVo = rewardRuleResponseVoCompletableFuture.get();  \n    ProfitsharingRuleResponseVo profitsharingRuleResponseVo = profitsharingRuleResponseVoCompletableFuture.get();  \n  \n    //6 封装实体类，结束代驾更新订单，添加账单和分账信息  \n    UpdateOrderBillForm updateOrderBillForm = new UpdateOrderBillForm();  \n    updateOrderBillForm.setOrderId(orderFeeForm.getOrderId());  \n    updateOrderBillForm.setDriverId(orderFeeForm.getDriverId());  \n    //路桥费、停车费、其他费用  \n    updateOrderBillForm.setTollFee(orderFeeForm.getTollFee());  \n    updateOrderBillForm.setParkingFee(orderFeeForm.getParkingFee());  \n    updateOrderBillForm.setOtherFee(orderFeeForm.getOtherFee());  \n    //乘客好处费  \n    updateOrderBillForm.setFavourFee(orderInfo.getFavourFee());  \n  \n    //实际里程  \n    updateOrderBillForm.setRealDistance(realDistance);  \n    //订单奖励信息  \n    BeanUtils.copyProperties(rewardRuleResponseVo, updateOrderBillForm);  \n    //代驾费用信息  \n    BeanUtils.copyProperties(feeRuleResponseVo, updateOrderBillForm);  \n    //分账相关信息  \n    BeanUtils.copyProperties(profitsharingRuleResponseVo, updateOrderBillForm);  \n    updateOrderBillForm.setProfitsharingRuleId(profitsharingRuleResponseVo.getProfitsharingRuleId());  \n    orderInfoFeignClient.endDrive(updateOrderBillForm);  \n  \n    return true;  \n}\n```\n\n# 订单支付\n\n## 账单信息\n\n- 司机结束代价后，生成账单（包含账单信息和分账信息）\n\n### 获取账单信息\n\n#### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"根据订单id获取实际账单信息\")  \n@GetMapping(\"/getOrderBillInfo/{orderId}\")  \npublic Result<OrderBillVo> getOrderBillInfo(@PathVariable Long orderId) {  \n    return Result.ok(orderInfoService.getOrderBillInfo(orderId));  \n}\n```\n\nservice\n```java\n// 根据订单id获取实际账单信息  \n@Override  \npublic OrderBillVo getOrderBillInfo(Long orderId) {  \n    LambdaQueryWrapper<OrderBill> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderBill::getOrderId,orderId);  \n    OrderBill orderBill = orderBillMapper.selectOne(wrapper);  \n  \n    OrderBillVo orderBillVo = new OrderBillVo();  \n    BeanUtils.copyProperties(orderBill,orderBillVo);  \n    return orderBillVo;  \n}\n```\n\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 根据订单id获取实际账单信息  \n * @param orderId  \n * @return  \n */  \n@GetMapping(\"/order/info/getOrderBillInfo/{orderId}\")  \nResult<OrderBillVo> getOrderBillInfo(@PathVariable(\"orderId\") Long orderId);\n```\n\n### 获取分账信息\n\n#### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"根据订单id获取实际分账信息\")  \n@GetMapping(\"/getOrderProfitsharing/{orderId}\")  \npublic Result<OrderProfitsharingVo> getOrderProfitsharing(@PathVariable Long orderId) {  \n    return Result.ok(orderInfoService.getOrderProfitsharing(orderId));  \n}\n```\n\nservice\n```java\n// 根据订单id获取实际分账信息  \n@Override  \npublic OrderProfitsharingVo getOrderProfitsharing(Long orderId) {  \n    LambdaQueryWrapper<OrderProfitsharing> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(OrderProfitsharing::getOrderId,orderId);  \n    OrderProfitsharing orderProfitsharing = orderProfitsharingMapper.selectOne(wrapper);  \n  \n    OrderProfitsharingVo orderProfitsharingVo = new OrderProfitsharingVo();  \n    BeanUtils.copyProperties(orderProfitsharing,orderProfitsharingVo);  \n    return orderProfitsharingVo;  \n}\n```\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**\n * 根据订单id获取实际分账信息\n * @param orderId\n * @return\n */\n@GetMapping(\"/order/info/getOrderProfitsharing/{orderId}\")\nResult<OrderProfitsharingVo> getOrderProfitsharing(@PathVariable(\"orderId\") Long orderId);\n```\n\n### 司机端获取账单信息\n\n方法之前有，只需要改service\nOrderController`\n```java\n@Operation(summary = \"获取订单账单详细信息\")  \n@LoginDetection  \n@GetMapping(\"/getOrderInfo/{orderId}\")  \npublic Result<OrderInfoVo> getOrderInfo(@PathVariable Long orderId) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.getOrderInfo(orderId, driverId));  \n}\n```\n\nservice\n```java\n// 获取订单账单详细信息  \n@Override  \npublic OrderInfoVo getOrderInfo(Long orderId, Long driverId) {  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();  \n    if(orderInfo.getDriverId() != driverId) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    //获取账单和分账数据，封装到vo里面  \n    OrderBillVo orderBillVo = null;  \n    OrderProfitsharingVo orderProfitsharingVo = null;  \n    //判断  \n    if(orderInfo.getStatus() >= OrderStatus.END_SERVICE.getStatus()) {  \n        //账单信息  \n        orderBillVo = orderInfoFeignClient.getOrderBillInfo(orderId).getData();  \n  \n        //分账信息  \n        orderProfitsharingVo = orderInfoFeignClient.getOrderProfitsharing(orderId).getData();  \n    }  \n  \n    OrderInfoVo orderInfoVo = new OrderInfoVo();  \n    orderInfoVo.setOrderId(orderId);  \n    BeanUtils.copyProperties(orderInfo,orderInfoVo);  \n    orderInfoVo.setOrderBillVo(orderBillVo);  \n    orderInfoVo.setOrderProfitsharingVo(orderProfitsharingVo);  \n    return orderInfoVo;  \n}\n```\n\n### 司机发送账单\n\n#### 订单微服务接口\n\nOrderInfoController\n```java\n@Operation(summary = \"发送账单信息\")  \n@GetMapping(\"/sendOrderBillInfo/{orderId}/{driverId}\")  \nResult<Boolean> sendOrderBillInfo(@PathVariable Long orderId, @PathVariable Long driverId) {  \n    return Result.ok(orderInfoService.sendOrderBillInfo(orderId, driverId));  \n}\n```\n\nservice\n```java\n// 发送账单信息  \n@Override  \npublic Boolean sendOrderBillInfo(Long orderId, Long driverId) {  \n    //更新订单信息  \n    LambdaQueryWrapper<OrderInfo> queryWrapper = new LambdaQueryWrapper<>();  \n    queryWrapper.eq(OrderInfo::getId, orderId);  \n    queryWrapper.eq(OrderInfo::getDriverId, driverId);  \n    //更新字段  \n    OrderInfo updateOrderInfo = new OrderInfo();  \n    updateOrderInfo.setStatus(OrderStatus.UNPAID.getStatus());  \n    //只能更新自己的订单  \n    int row = orderInfoMapper.update(updateOrderInfo, queryWrapper);  \n    if(row == 1) {  \n        return true;  \n    } else {  \n        throw new GuiguException(ResultCodeEnum.UPDATE_ERROR);  \n    }  \n}\n```\n\n#### 远程调用\n\nOrderInfoFeignClient\n```java\n/**  \n * 司机发送账单信息  \n * @param orderId  \n * @param driverId  \n * @return  \n */  \n@GetMapping(\"/order/info/sendOrderBillInfo/{orderId}/{driverId}\")  \nResult<Boolean> sendOrderBillInfo(@PathVariable(\"orderId\") Long orderId, @PathVariable(\"driverId\") Long driverId);\n```\n\n#### 司机web端调用\n\nOrderController\n```java\n@Operation(summary = \"司机发送账单信息\")  \n@LoginDetection  \n@GetMapping(\"/sendOrderBillInfo/{orderId}\")  \npublic Result<Boolean> sendOrderBillInfo(@PathVariable Long orderId) {  \n    Long driverId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.sendOrderBillInfo(orderId, driverId));  \n}\n```\n\nservice\n```java\n// 司机发送账单信息  \n@Override  \npublic Boolean sendOrderBillInfo(Long orderId, Long driverId) {  \n    return orderInfoFeignClient.sendOrderBillInfo(orderId, driverId).getData();  \n}\n```\n\n### 乘客获取账单\n\n也是修改之前写过的代码，只需要修改service\nOrderController\n```java\n@Operation(summary = \"获取订单信息\")  \n@LoginDetection  \n@GetMapping(\"/getOrderInfo/{orderId}\")  \npublic Result<OrderInfoVo> getOrderInfo(@PathVariable Long orderId) {  \n    Long customerId = AuthContextHolder.getUserId();  \n    return Result.ok(orderService.getOrderInfo(orderId, customerId));  \n}\n```\n\nservice\n```java\n// 获取订单信息  \n@Override  \npublic OrderInfoVo getOrderInfo(Long orderId, Long customerId) {  \n    OrderInfo orderInfo = orderInfoFeignClient.getOrderInfo(orderId).getData();  \n    //判断  \n    if(orderInfo.getCustomerId() != customerId) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    //获取司机信息  \n    DriverInfoVo driverInfoVo = null;  \n    Long driverId = orderInfo.getDriverId();  \n    if(driverId != null) {  \n        driverInfoVo = driverInfoFeignClient.getDriverInfo(driverId).getData();  \n    }  \n  \n    //获取账单信息  \n    OrderBillVo orderBillVo = null;  \n    if(orderInfo.getStatus() >= OrderStatus.UNPAID.getStatus()) {  \n        orderBillVo = orderInfoFeignClient.getOrderBillInfo(orderId).getData();  \n    }  \n  \n    OrderInfoVo orderInfoVo = new OrderInfoVo();  \n    orderInfoVo.setOrderId(orderId);  \n    BeanUtils.copyProperties(orderInfo,orderInfoVo);  \n    orderInfoVo.setOrderBillVo(orderBillVo);  \n    orderInfoVo.setDriverInfoVo(driverInfoVo);  \n    return orderInfoVo;  \n}\n```\n\n## 微信支付\n\n### 准备接口\n\n#### 获取乘客openid\n\nservice-customer中的CustomerInfoController\n```java\n@Operation(summary = \"获取客户OpenId\")  \n@GetMapping(\"/getCustomerOpenId/{customerId}\")  \npublic Result<String> getCustomerOpenId(@PathVariable Long customerId) {  \n    return Result.ok(customerInfoService.getCustomerOpenId(customerId));  \n}\n```\n\nservice\n```java\n// 获取客户OpenId  \n@Override  \npublic String getCustomerOpenId(Long customerId) {  \n    LambdaQueryWrapper<CustomerInfo> wrapper = new LambdaQueryWrapper<>();  \n    wrapper.eq(CustomerInfo::getId,customerId);  \n    CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);  \n    return customerInfo.getWxOpenId();  \n}\n```\n\n远程调用\n\nCustomerInfoFeignClient\n```java\n/**  \n * 获取客户OpenId  \n * @param customerId  \n * @return  \n */  \n@GetMapping(\"/customer/info/getCustomerOpenId/{customerId}\")  \nResult<String> getCustomerOpenId(@PathVariable(\"customerId\") Long customerId);\n```\n\n#### 获取司机openid\n\nservice-driver中DriverInfoController\n```java\n@Operation(summary = \"获取司机OpenId\")  \n@GetMapping(\"/getDriverOpenId/{driverId}\")  \npublic Result<String> getDriverOpenId(@PathVariable Long driverId) {  \n    return Result.ok(driverInfoService.getDriverOpenId(driverId));  \n}\n```\n\nserivce\n```java\n// 获取司机OpenId  \n@Override  \npublic String getDriverOpenId(Long driverId) {  \n    DriverInfo driverInfo = this.getOne(new LambdaQueryWrapper<DriverInfo>().eq(DriverInfo::getId, driverId).select(DriverInfo::getWxOpenId));  \n    return driverInfo.getWxOpenId();  \n}\n```\n\n远程调用\n\nDriverInfoFeignClient\n```java\n/**  \n * 获取司机OpenId  \n * @param driverId  \n * @return  \n */  \n@GetMapping(\"/driver/info/getDriverOpenId/{driverId}\")  \nResult<String> getDriverOpenId(@PathVariable(\"driverId\") Long driverId);\n```\n#### 获取支付信息\n\nservice-order中OrderInfoController\n```java\n@Operation(summary = \"获取订单支付信息\")\n@GetMapping(\"/getOrderPayVo/{orderNo}/{customerId}\")\npublic Result<OrderPayVo> getOrderPayVo(@PathVariable String orderNo, @PathVariable Long customerId) {\n    return Result.ok(orderInfoService.getOrderPayVo(orderNo, customerId));\n}\n```\n\nservice\n```java\n// 获取订单支付信息  \n@Override  \npublic OrderPayVo getOrderPayVo(String orderNo, Long customerId) {  \n    OrderPayVo orderPayVo = orderInfoMapper.selectOrderPayVo(orderNo,customerId);  \n    if(orderPayVo != null) {  \n        String content = orderPayVo.getStartLocation() + \" 到 \"+orderPayVo.getEndLocation();  \n        orderPayVo.setContent(content);  \n    }  \n    return orderPayVo;  \n}\n```\n\n远程调用\n```java\n/**  \n * 获取订单支付信息  \n * @param orderNo  \n * @param customerId  \n * @return  \n */  \n@GetMapping(\"/order/info/getOrderPayVo/{orderNo}/{customerId}\")  \nResult<OrderPayVo> getOrderPayVo(@PathVariable(\"orderNo\") String orderNo, @PathVariable(\"customerId\") Long customerId);\n```\n\n\n### 微信支付接口\n\n在service-payment下\n\n- 导入依赖\n```java\n<dependency>  \n    <groupId>com.github.wechatpay-apiv3</groupId>  \n    <artifactId>wechatpay-java</artifactId>  \n</dependency>\n```\n\n- 创建配置类\n```java\n@Configuration  \n@ConfigurationProperties(prefix=\"wx.v3pay\") //读取节点  \n@Data  \npublic class WxPayV3Properties {  \n  \n    private String appid;  \n    /** 商户号 */  \n    public String merchantId;  \n    /** 商户API私钥路径 */  \n    public String privateKeyPath;  \n    /** 商户证书序列号 */  \n    public String merchantSerialNumber;  \n    /** 商户APIV3密钥 */  \n    public String apiV3key;  \n    /** 回调地址 */  \n    private String notifyUrl;  \n  \n    @Bean  \n    public RSAAutoCertificateConfig getConfig(){  \n        return new RSAAutoCertificateConfig.Builder()  \n                .merchantId(this.getMerchantId())  \n                .privateKeyFromPath(this.getPrivateKeyPath())  \n                .merchantSerialNumber(this.getMerchantSerialNumber())  \n                .apiV3Key(this.getApiV3key())  \n                .build();  \n  \n    }  \n}\n```\n\nWxPayController\n```java\n@Autowired  \nprivate WxPayService wxPayService;  \n  \n@Operation(summary = \"创建微信支付\")  \n@PostMapping(\"/createJsapi\")  \npublic Result<WxPrepayVo> createWxPayment(@RequestBody PaymentInfoForm paymentInfoForm) {  \n    return Result.ok(wxPayService.createWxPayment(paymentInfoForm));  \n}\n```\n\n- 远程调用\n\nWxPayFeignClient\n```java\n/**  \n * 创建微信支付  \n * @param paymentInfoForm  \n * @return  \n */  \n@PostMapping(\"/payment/wxPay/createWxPayment\")  \nResult<WxPrepayVo> createWxPayment(@RequestBody PaymentInfoForm paymentInfoForm);\n```\n\n- 乘客web端调用\n\nOrderController\n```java\n@Operation(summary = \"创建微信支付\")  \n@LoginDetection  \n@PostMapping(\"/createWxPayment\")  \npublic Result<WxPrepayVo> createWxPayment(@RequestBody CreateWxPaymentForm createWxPaymentForm) {  \n    Long customerId = AuthContextHolder.getUserId();  \n    createWxPaymentForm.setCustomerId(customerId);  \n    return Result.ok(orderService.createWxPayment(createWxPaymentForm));  \n}\n```\n\nservice\n```java\n@Override  \npublic WxPrepayVo createWxPayment(CreateWxPaymentForm createWxPaymentForm) {  \n    //获取订单支付信息  \n    OrderPayVo orderPayVo = orderInfoFeignClient.getOrderPayVo(createWxPaymentForm.getOrderNo(),  \n            createWxPaymentForm.getCustomerId()).getData();  \n    //判断  \n    if(orderPayVo.getStatus() != OrderStatus.UNPAID.getStatus()) {  \n        throw new GuiguException(ResultCodeEnum.ILLEGAL_REQUEST);  \n    }  \n  \n    //获取乘客和司机openid  \n    String customerOpenId = customerInfoFeignClient.getCustomerOpenId(orderPayVo.getCustomerId()).getData();  \n  \n    String driverOpenId = driverInfoFeignClient.getDriverOpenId(orderPayVo.getDriverId()).getData();  \n  \n    //封装需要数据到实体类，远程调用发起微信支付  \n    PaymentInfoForm paymentInfoForm = new PaymentInfoForm();  \n    paymentInfoForm.setCustomerOpenId(customerOpenId);  \n    paymentInfoForm.setDriverOpenId(driverOpenId);  \n    paymentInfoForm.setOrderNo(orderPayVo.getOrderNo());  \n    paymentInfoForm.setAmount(orderPayVo.getPayAmount());  \n    paymentInfoForm.setContent(orderPayVo.getContent());  \n    paymentInfoForm.setPayWay(1);  \n  \n    WxPrepayVo wxPrepayVo = wxPayFeignClient.createWxPayment(paymentInfoForm).getData();  \n    return wxPrepayVo;  \n}\n```\n\n### 支付结果查询\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["project"]},{"title":"开源实践入门","url":"/2025/02/21/articles/MarsCode学习笔记/17.开源实践入门/开源实践入门/","content":"\n看完感觉跟没看一样，学习笔记就直接把课件CV一份，好歹也是看了\n\n# 开源软件定义\n\n非盈利组织 Open Source Initiative(OSI)极力倡导，任何开源软件都必须遵循如下标准\n- 可以被免费进行二次分发。\n- 源代码应当公开、可用。\n- 可以与原始软件不同的格式进行修改和分发。\n- 软件本身不应歧视任何个人或团体。\n- 软件本身不应限制其他软件的使用或调用。\n\n开源不仅仅意味着源码开放，同时还需要支持衍生物发行、符合传播规范、满足非歧视原则等要求OSI让开源具有了教育和倡导开放式开发流程的优势。(社会价值)\n开源软件提供了一种与潜在的软件用户和开发人员相互动的宝贵方法。通过一个具有互动参与性的社区大家可以创建新的或改进原有的源代码。(项目价值)\n\n# 自由软件 & 开源软件 & 免费软件\n\n- 所谓“Free Software”中的“free”-词强调的是自由，而不是价格上的免费。\n- 自由软件有比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都能被称为“自由”。\n- 免费软件就是不要钱的软件，但“不要钱”的定义往往是模糊的:是指人们取得该软件时无需付费，还是说人们在使用的过程中都无需付费，亦或是指该软件的发行者不从中获取利益?实际情况往往是复杂而黑暗的。 \n\n\n# 开源软件的意义\n\n从软件分发而言\n- 任何人可以修改源代码，以满足使用需求\n- 打破专有软件垄断，根据许可证要求再分发\n- 降低软件总拥有成本，促进软件行业快速发展\n\n从行为动机而言\n- 礼物文化:付出热情、智慧和努力，得到认可\n- 行动中学习，教与学的过程，例如 Code Review\n\n从技术发展而言\n- 标准化快速落地，打破软件烟囱，技术生态繁荣发展\n- 沟通协作和技术场景复杂，促进代码和架构的模块化\n- 开源引领技术创新，成为新技术的摇篮\n\n从组织管理而言\n- 打造开放式组织，最大化知识工作者的效益\n- Private Collective Model，即成员私有投入，产出公开可见\n- 民主与决策，Communityovercode 下的社区治理实践\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"性能优化及自动内存管理","url":"/2025/02/20/articles/MarsCode学习笔记/16.Go性能优化及自动内存管理/性能优化及自动内存管理/","content":"\n==这里主要讲的是Go语言==，太概念了，这知识根本不入脑\n\n# 性能优化\n\n提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力\n\n## 性能优化的作用\n\n- 用户体验：带来用户体验的提升 - 让刷抖音更丝滑，让双十一购物不再卡顿\n- 资源高效利用：降低成本，提高效率 - 很小的优化乘以海量机器会是显著的性能提升和成本节约\n\n## 性能优化的层面\n\n- 业务层优化\n\t- 针对特定场景，具体问题，具体分析\n\t- 容易获得较大性能收益\n- 语言运行时优化\n\t- 解决更通用的性能问题\n\t- 考虑更多场景\n\t- Tradeoffs\n- 数据驱动\n\t- 自动化性能分析工具 -- pprof\n\t- 依靠数据而非猜测\n\t- 首先优化最大瓶颈\n\n## 软件质量\n\n- 软件质量至关重要\n- 在保证接口稳定的前提下改进具体实现\n- 测试用例:覆盖尽可能多的场景，方便回归\n- 文档：做了什么，没做什么，能达到怎样的效果\n- 隔离：通过选项控制是否开启优化\n- 可观测:必要的日志输出\n\n# 自动内存管理\n\n- 动态内存\n\t- 程序在运行时根据需求动态分配的内存：malloc()\n- 自动内存管理(垃圾回收):由程序语言的运行时系统管理动态内存\n\t- 避免手动内存管理，专注于实现业务逻辑\n\t- 保证内存使用的正确性和安全性: double-free problem, use-after-free problem\n\n\n## 相关概念\n\n- Mutator:业务线程，分配新对象，修改对象指向关系\n- Collector: GC 线程，找到存活对象，回收死亡对象的内存空间\n- Serial Gc: 只有一个 collector\n- Parallel Gc: 支持多个 collectors 同时回收的 GC 算法\n- Concurrent GC: mutator(s)和 collector(s)可以**同时执行**\n\t- Collectors 必须感知对象指向关系的改变\n\n## 追踪垃圾回收\n\n- 对象被回收的条件：指针指向关系不可达的对象\n- 标记根对象\n\t- 静态变量、全局变量、常量、线程栈等\n- 标记：找到可达对象\n\t- 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象\n- 清理：所有不可达对象\n\t- 将存活对象复制到另外的内存空间(Copying GC)\n\t- 将死亡对象的内存标记为“可分配”(Mark-sweep GC)\n\t- 移动并整理存活对象(Mark-compact GC)\n- 根据对象的生命周期，使用不同的标记和清理策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"微服务架构","url":"/2025/02/18/articles/MarsCode学习笔记/15.微服务架构/微服务架构/","content":"# 了解微服务架构\n![](p1.png)\n\n- 优势：\n    \n    1. 开发效率高、2. 业务独立设计、3. 自下而上、4. 故障隔离\n- 劣势：\n    \n    1. 治理、运维难度高、2. 观测挑战、3. 安全性、4. 分布式系统的问题\n\n## 核心要素\n\n- 服务治理\n\t\n\t1. 服务注册、2. 服务发现、3. 负载均衡、4. 扩缩容、5. 流量治理、6. 稳定性治理\n\n- 可观测性\n\t\n\t1. 日志采集、2. 日志分析、3. 监控打点、4. 监控大盘、5. 异常报警、6. 链路追踪\n\n- 安全\n\t\n\t1. 身份验证、2. 认证授权、3. 访问令牌、4. 审计、5. 传输加密、5. 黑产攻击\n\n\n# 微服务架构原理及特征\n\n## 基本概念\n\n- **服务**(service)\n\t\n\t- 一组具有**相同逻辑**的**运行实体**。\n\n- **实例**(instance)\n\t\n\t- 一个服务中，每个运行实体即为一个实例。\n\n- 实例与进程的关系\n\t\n\t- 实例与进程之间没有必然对应关系，可以一个实例可以对应一个或多个进程(反之不常见)\n\n- 集群(cluster)\n\t\n\t- 通常指服务内部的逻辑划分，包含多个实例。\n\n- 常见的实例承载形式\n\t\n\t- 进程、VM、k8s pod\n\n- 有状态/无状态服务\n\t\n\t- 服务的实例是否存储了可持久化的数据(例如磁盘文件)。\n\n### 服务间通信\n\n对于单体服务，不同模块通信只是简单的函数调用。\n对于微服务，服务间通信意味着网络传输。\n\n![](p2.png)\n\n### 服务注册及发现\n\n在代码层面，我们如何去调用一个服务的地址？\n\n答：加一层，新增一个统一的服务注册中心，用于存储服务名到服务实例的映射，类似于 DNS，但DNS问题也很多，例如：本地 DNS 存在缓存，导致延时负载均衡问题，不支持服务实例的探活检查域名无法配置端口等等\n\n下图为服务实例上线与下线过程，讲师在讲这里时非常清晰很生动\n\n![](p3.png)\n\n### 流量特征\n\n- 统一网关入口\n- 内网通信多数采用RPC\n- 网状调用链路\n\n![](p4.png)\n\n# 核心服务治理功能\n\n## 服务发布\n\n服务发布(deployment)，即指让一个服务升级运行新的代码的过程\n\n常见的服务发布难点：\n\t\n\t1. 服务不可用、2. 服务抖动、3. 服务回滚 \n\n讲解中讲了两种方法，都是之前有了解过的：\n- 蓝绿发布：简单、但需要两倍资源（可以根据流量的错峰特性使用蓝绿发布）\n- 金丝雀发布：过度平滑，但是在部署时进度在1%～99%时都有可能出现问题，需要回滚版本，这种维护能力需要平台级的设施提供支持。\n\n![](p5.png)\n\n## 流量治理\n\n在微服务架构下，我们可以基于地区、集群、实例、请求等维度，对端到端流量的路由进行精确控制。\n\n![](p6.png)\n\n## 负载均衡\n\n负载均衡((Load Balance)负责分配请求在每个下游实例上的分布。\n\n常见的LB策略：\n- 1. 绝对公平、2. 随机、3. 一次性哈希\n\n## 稳定性治理\n\n线上服务总是会出问题的，这与程序的正确性无关。\n\n常见的问题：\n- 1. 网络攻击、2. 流量突增、3. 机房断电、4. 光纤被挖、5. 机械故障、6. 网络故障、 7. 机房空调故障\n\n微服务架构中典型的稳定性治理功能：\n- 1. 限流、2. 熔断、3. 过载保护、4. 降级\n\n![](p7.png)\n\n# 重试\n\n本地函数调用可能出现的问题：\n- 1. 参数非法、2. OOM (Out Of Memory)、3. NPE (Null Pointer Exception)、4. 边界 case\n- 5. 系统崩溃、6. 死循环、7. 程序异常退出\n\n远程函数调用可能出现的问题：\n- 1. 网络抖动、2. 下游负载高导致超时、3. 下游机器宕机、4. 本地机器负载高，调度超时、5. 下游熔断、限流\n\n**本地函数重试基本上是没有意义的**，而远程函数重试则有意义，因为其发生请求错误的原因可能不是下游程序编写出错\n\n## 重试的意义\n\n- 降低错误率：单次错误概率为0.01，连续错误两次概率为0.0001\n- 降低长尾延迟：对于偶尔耗时较长的请求，重试请求有机会提前返回\n- 规避暂时性错误：网络抖动\n- 避开下游故障实例：一个服务可能会有少量故障实例（如机器故障），重试可以将请求打到其他机器\n\n## 重试的难点\n\n- 幂等性\n\t\n\t- 幂等性是指多次执行同一操作，结果与执行一次相同，确保了即使请求被多次发送，也不会引发重复操作或数据不一致的问题\n\n- 超时设置\n\t\n\t- 超时设置是重试机制中的关键环节，合理的超时时间可以避免系统资源被无效占用，同时也能减少重试风暴的风险\n\n- 重试风暴\n\t- 重试风暴是指由于重试策略配置不当，导致系统在短时间内收到大量重试请求，从而引发系统过载甚至崩溃的现象\n\n## 重试策略\n\n- 限制重试比例\n\t\n\t- 设定一个重试比例阈值（例如1%），重试此处占所有请求比例不超过该阈值。\n\n- 防止链路重试\n\t\n\t- 链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试，可以返回特殊的 status 表明“请求失败，但别重试”\n\n- 对冲请求（Hedged requests）\n\t\n\t- 对于可能超时(或延时高)的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应,\n\n\n## 重试效果验证\n\n讲解中有举例，字节跳动工作组有做过对应的实验并产出结论\n\n![](p8.png)\n\n\n\n\n\n\n\n\n\n\n","tags":["字节青训营"]},{"title":"定时计划","url":"/2025/02/17/articles/MarsCode学习笔记/14.定时任务/定时计划/","content":"\n# 基本的定时任务\n\n- `Windows`运行批处理文件\n\t\n- `Windows`任务计划程序（右键`我的电脑`）\n\t\n- `Linux`命令—`CronJob`\n\t\n- 应用程序编码层—单机定时任务（`Timer—Java`、`Ticker—Go`、`ScheduledExecutorService`—线程池技术）\n\t\n- 任务调度—`Quartz`（单任务极致控制、没有负载均衡机制）\n\t\n- 分布式定时任务（平台化管理、分布式部署、支持海量数据）\n\n# 分布式定时任务\n\n- 定时任务是指系统为了自动完成特定任务，**实时、延时、周期性**完成任务调度的过程。\n\t\n- 分布式定时任务是把分散的、可靠性差的定时任务纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。\n\n按触发时机分类:\n- 定时任务：特定时间触发，比如今天15:06执行\n- 延时任务：延时触发，比如10s后执行\n- 周期任务：固定周期时间，或固定频率周期调度触发，比如每天12点或者每隔5s执行\n\n### 特点\n\n- 自动化：全自动完成定时任务的认度和执行\n- 平台化：基于平台化的思维管控系列的分布式定时任务\n- 分布式：在分布式系统环境下运行任务调度，突破单机定时任务的性能瓶颈\n- 伸缩性：采用集群方式部署，可随时按需扩缩容\n- 高可用：单点故障不影响最终任结果，可以做到故障转移\n\n### 执行方式\n\n- 单机任务：随机触发一台机器执行任务，适用于计算量小、并发度低的任务\n\t\n- 广播任务：广播到所有机器上执行同一个任务，比如所有机器一起清理日志\n\t\n- Map任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算。适用于计算量单机无法满足要求的任务\n\t\n- MapReduce任务：在Map任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务\n\n### 业内定时任务框架\n\n![](p1.png)\n\n### 比较\n\n分布式定时任务VS单机定时任务\n\t\n- 关系:\n\t- 都可以实现自动化的定时、延时、周期任务调度\n- 差异:\n\t- 分布式定时任务可支撑更大的业务体量\n\t- 分布式定时任务的性能、伸缩性、稳定性更高\n\n\n分布式定时任务VS大数据处理引擎\n\t\n- 关系:\n\t- 都可以对海量数据做处理\n\t- 性能、伸缩性、稳定性都很高\n- 差异:\n\t- 定时并不是大数据处理引擎要解决的核心问题\n\t- 大数据处理引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做这个之外，还可以调用HTTP和RPC服务\n\n\n# 核心架构\n\n分布式定时任务核心要解决**触发、调度、执行**三个关键问题\n\n- 触发器：Trigger，解析任务，生成触发事件\n\t- 这个定时任务在什么时间点被准时准点的触发\n\t\n- 调度器：Scheduler，分配任务，管理任务生命周期\n\t- 这个任务触发了怎么去协调机器来进行任务的调度\n\t\n- 执行器：Executor，获取执行任务单元，执行任务逻辑\n\t- 单台机器怎么去把分配的任务执行好，遇到故障的回复等等\n\n除此之外，还需要提供一个控制台(Admin)，:提供任务管理和干预的功能。\n\n\n![](p2.png)\n\n## 控制台\n\n![](p3.png)\n\n- 任务:Job，任务元数据\n\t- 任务元数据(Job)是用户对任务属性定义（who），包括任务类型调度时机（when）、执行行为（what）、执行方式（how）等\n\t\n- 任务实例:Joblnstance,任务运行的实例\n\t- 任务实例(Joblnstance)是一个确定的 Job 的一次运行实例（Job_id、触发时间、状态&结果、过程消息）\n\t\n- 任务结果:JobResult，任务实例运行的结果\n- 任务历史:JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储\n\n\n## 触发器\n\n**核心职责**\n- 给定一系列任务，解析它们的触发规则，在规定的时间点触发任务的调度\n\n**设计约束**\n- 需支持大量任务\n- 需支持秒级的调度\n- 周期任务需要多次执行\n-  需保证秒级扫描的高性能，并避免资源浪费\n\n### 方案\n\n时间轮 ( Quartz 所用方案)时间轮是一种高效利用线程资源进行批量化调度的一种调度模型。时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表。\n\n![](p4.png)\n\n不同业务之间，任务的调度相互影响怎么办？负责扫描和触发的机器挂了怎么办？\n\n- 存储上：不同国别、业务做资源隔离\n- 运行上：不同国别、业务分开执行\n- 部署时：采用多机房集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只被触发一次\n\n## 调度器\n\n### 资源来源\n\n- 业务系统提供资源（阿里、美团、字节）\n    \n    - 优点：任务执行逻辑与业务系统共用一份资源，利用率高\n    - 缺点：更容易发生定时任务脚本影响在线业务的事故；不能由定时任务平台控制扩缩容\n\t\n- 定时任务平台提供机器资源（字节）\n    \n    - 优点：任务执行逻辑与业务系统提供的在线服务隔离，避免相互影响，可以优化扩缩容\n    - 缺点：消耗更多机器资源；需要额外为定时任务平台申请接口调用权限，而不能直接继承业务系统的权限\n\n### 节点选择\n\n- **随机节点执行**：选择集群中一个可用的执行节点执行调度任务。适用场景：定时对账，\n- **广播执行**：在集群中所有的执行节点分发调度任务并执行。适用场景：批量运维。\n- **分片执行**：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率。适用场景：海量日志统计。\n\n**任务分片**：\n![](p5.png)\n\n### 高级特性\n\n- **任务编排**：使用有向无环图 DAG(Directed Acyclic Graph)进行可视化任务编排\n\t- N个执行器Executor，M个业务数据区段，最好M>=N，且M是N的整数倍\n\t\n- **故障转移**：分片任务基于一致性Hash策略分发任务，当某个执行器异常时，调度器会将任务分发到其他执行器。\n\t- 分片任务基于一致性hash策略分发任务，当某Executor异常时，调度器会将任务分发到其他Executor\n\t\n- **高可用**：调度器可以集群部署，做到完全无状态，靠消息队列的重试机制保障任务一定会被调度。\n\n上半图为故障转移的分发任务，下半图为高可用的消息队列重试机制\n![](p6.png)\n\n## 执行器\n\n![](p7.png)\n基于注册中心，可以做到执行器的弹性扩缩容\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  ","tags":["字节青训营"]},{"title":"后端框架的剖析","url":"/2025/02/14/articles/MarsCode学习笔记/13.后端框架剖析/后端框架的剖析/","content":"\n# 架构\n\n架构，又称软件架构\n\n- 是有关软件整体结构与组件的抽象描述\n- 用于指导软件系统各个方面的设计\n\n# 单机架构\n\n软件系统需要具备对外提供服务，单机，就是把所有功能都实现在一个进程里，并部署在一台机器上\n\n优点:\n- 简单\n\n问题\n- - C10K问题（Concurrent 10,000 Connection）：服务器如何支持10K个并发连接，进行高性能网络编程。解决方式：采用IO复用模型epoll方法，在调用返回时，只给应用提供发生了状态变化的文件句柄，不需要轮询fd（文件描述符）\n- 运维需要停服\n\n## 单体、垂直应用|垂直切分\n\n**单体架构**：分布式部署\n**垂直应用架构**：按应用垂直切分的单体\n优点：\n- 水平扩容\n- 运维不需要停服\n问题：\n- 职责太多，开发效率不高\n- 爆炸半径大\n\n![](p1.png)\n\n## SOA、微服务|水平切分\n\nS0A(Service-0riented Architecture)\n1. 将应用的不同功能单元抽象为服务\n2. 定义服务之间的通信标准\n\n**微服务架构**： S0A 的去中心化演进方向\n\n\n# 云计算\n\n**云计算**：是指通过软件自动化管理，提供计算资源的服务网络，是现代互联网大规模熟悉分析和存储的基石。\n\n基础：\n- 虚拟化技术 \n\t- 整租 vs 合租（“整租”可以对应“独占虚拟机”，“合租”可以对应“共享虚拟机”）\n- 编排方案 \n\t- 业主 vs 租赁平台（“业主”可以类比为“私有云或本地数据中心”，“租赁平台”可以类比为“公有云服务提供商”）\n\n架构：\n- laaS（Infrastructure as a Service）**（基础设施即服务）**\n\t- **定义**：基础设施即服务是一种云计算服务模型，它提供虚拟化的计算资源。用户可以通过Internet租用这些资源，如服务器、存储和网络硬件。\n\t- **控制程度**：IaaS提供了最高的控制程度，用户可以完全控制操作系统安装、应用程序部署和网络配置。\n- PaaS（Platform as a Service）**（平台即服务）**\n\t- **定义**：平台即服务是一种云计算服务模型，它提供了一个平台，允许用户开发、运行和管理应用程序，而无需构建和维护底层硬件和软件基础设施。\n\t- **控制程度**：PaaS提供了一个中间层的控制，用户可以控制应用程序和某些应用程序托管功能，但对底层基础设施的控制有限。\n- SaaS（Software as a Service）**（软件即服务）**\n\t- **定义**：软件即服务是一种云计算服务模型，它通过Internet提供应用程序，用户通常通过订阅模式访问这些应用程序。\n\t- **控制程度**：SaaS提供了最低的控制程度，用户只能使用应用程序的功能，而不能控制应用程序或其运行环境。\n- FaaS（Function as a Service）**（方法即服务）**\n\t- **定义**：函数即服务，也称为无服务器计算，是一种云计算服务模型，它允许用户运行代码而无需管理底层的运行环境或基础设施。\n\t- **控制程度**：FaaS提供了一种事件驱动的计算模型，用户只需上传代码，服务提供商会处理其余的工作，包括自动扩展、负载均衡和状态管理。\n\n# 云原生\n\n云原生技术为组织(公司)在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。\n\n![](p3.png)\n\n\n\n\n## 弹性计算资源类型 \n\n- **服务资源调度**\n\t- **微服务**：微服务架构将复杂的应用程序拆分为一组小型、独立的服务，每个服务专注于完成一个特定的业务功能。它们通常具有快速开发、部署和扩展的能力\n\t- **大服务**：大服务通常指那些功能复杂、使用量高且对性能要求较高的服务。它们可能需要长期运行并处理大量数据。\n- **计算资源调度**\n\t- **在线**\n\t\t- - **特点**：在线计算通常需要实时或近实时响应用户请求，对性能和延迟要求较高。\n\t\t- **应用场景**：例如，电商网站的热销榜单展示。这类应用需要快速响应用户的查询请求，实时更新数据，并根据流量动态调整资源。\n\t- **离线**\n\t\t- **特点**：离线计算通常用于处理非实时的数据分析或批处理任务，对延迟要求不高，但对数据处理的完整性和准确性要求较高。\n\t\t- **应用场景**：例如，热销榜单的更新。这类任务可以在后台运行，定期处理大量数据，生成分析结果，然后更新到在线系统中。\n- **消息队列**\n\t- **在线消息队列**：\n\t    - **特点**：在线消息队列主要用于实时或近实时的消息传递，能够实现系统的解耦和削峰填谷。\n\t    - **应用场景**：\n\t        - **削峰**：在高并发场景下，消息队列可以缓冲用户请求，避免系统过载。\n\t        - **解耦**：将不同的系统或服务通过消息队列连接，降低系统间的耦合度，提高系统的可扩展性和可靠性。\n\t- **离线消息队列**：\n\t\t    - **特点**：离线消息队列主要用于处理非实时的数据处理任务，通常用于大数据分析、日志处理等场景。\n\t\t    - **应用场景**：例如，收集用户行为日志并进行离线分析，生成用户画像或推荐系统数据。这类任务可以在后台运行，不依赖实时响应。\n\n## DevOps\n\nDev0ps 是云原生时代软件交付的利器贯穿整个软件开发周期，是一种将软件开发（Development）和 IT 运维（Operations）相结合的文化、理念和实践方法。它旨在打破开发和运维之间的传统壁垒，通过自动化、协作和沟通，实现软件的快速交付和高质量。DevOps 强调团队赋能、跨团队沟通和协作，以及技术自动化。\n\n结合自动化流程，提高软件开发、交付效率\n\n软件大概的生命周期如下：\n\n![](p4.png)\n\n\n\n# 离在线资源并池\n\n- **核心收益**：\n\n\t- **降低物理资源成本**：通过资源复用，减少闲置资源，提高整体资源利用率。\n\t    \n\t- **提供更多的弹性资源，增加收入**：在离线业务的低峰期释放资源给在线业务使用，反之亦然，从而实现资源的灵活调配。\n\n- **在线业务的特点**：\n\n\t- **IO密集型为主**：在线业务通常对延迟敏感，需要快速响应用户请求。\n\t    \n\t- **潮汐性、实时性**：在线业务通常呈现明显的潮汐效应，例如白天流量高，夜间流量低。\n    \n\n- **离线业务的特点**：\n\n\t- **计算密集型占多数**：离线业务通常需要大量的计算资源，例如数据分析、模型训练等。\n\t    \n\t- **非实时性**：离线业务对实时性要求较低，可以在资源允许的情况下排队执行。\n\n\n\n\n","tags":["字节青训营"]},{"title":"后端开发与迭代","url":"/2025/02/13/articles/MarsCode学习笔记/12.后端的开发于迭代/后端开发与迭代/","content":"# 了解开发流程\n\n![](p2.png)\n\n复杂项目没有流程会有什么问题\n- 需求阶段:每个人都有自己的想法，团队决策需要有一个过程\n- 开发阶段:多人/多端协作开发，每个人有自己的安排，相互配合需要有一个流程\n- 测试阶段:产物怎样交付，测试如何开展，BUG怎么修都需要流程\n- 发布阶段:怎样确保发布过程平稳丝滑，版本和流量如何控制，需要有规范\n- 运维阶段:线上问题如何应急响应，处理用户反馈和线上问题需要有流程\n\n## 瀑布模型\n\n需求、开发、测试、发布、运维，一个阶段完全好了，再到下一个\n\n- 传统的线性开发模型，按顺序依次进行需求分析、系统设计、编码、测试和部署。\n- 每个阶段的结果作为下一个阶段的输入。\n- 瀑布模型的突出缺点是不适宜用户需求的变化\n- 需求一旦确认，较难进行修改。\n- 适用于需求较为稳定、项目较小的情况。\n\n## 敏捷开发\n\n更注重的是个体的互动、工作的软件、客户合作、响应变化\n\n- 以小团队快速迭代\n- 团队成员之间的合作更加紧密\n- 以人为本，和用户沟通\n\n更现代的流程模型\n\n- 迭代、增量的开发方法，强调快速响应需求变化和持续交付价值。\n- 开发过程中注重协作、沟通和自组织团队。\n- 将开发任务分解为小块，每个迭代周期内交付可用的功能。\n- 适用于需求不确定、变化频繁的项目。\n\n## 字节团队的开发流程\n\n![](MarsCode学习笔记/12.后端的开发于迭代/p1.png)\n\n# 开发流程详解\n\n## 需求阶段\n\nMVP (minimum viable product，最小化可行产品)思想\n\n![](p3.png)\n\n站在用户的角度思考\n收集用户反馈，快速迭代\n\n![](p4.png)\n把重要和紧急的事情先做，重要放在前面，紧急放在重要后面。\n\n## 开发阶段\n\n### 云原生下的开发\n\n**传统虚拟机**\n\n- 在物理主机中虚拟出多个虚拟机，每个虚拟机拥有自己的操作系统\n- 运维人员负责维护和交付虚拟机\n- 每个虚拟机中都要安装相应的依赖环境\n\n**容器化**\n\n- 容器是在操作系统中虚拟出来的\n- 通过cgroup，namespace和Union Mount等技术实现了容器之间的相互隔离，同时容器只有很低的开销\n- 应用和其依赖作为一个整体，打包成镜像交付\n\n**单体结构**\n\n- 多个模块共同组成一个服务，服务体量较大\n- 模块之间直接调用，不需要RPC通信\n- 服务整体扩缩容量\n- 多人开发一个代码仓库，需要充分集成测试\n\n**微服务架构**\n\n- 各个功能在不同的服务中\n- 不同模块需要进行RPC通信\n- 不同模块可以独立扩缩容\n- 每个服务的代码仓库仅由少部分人维护\n\n### 代码规范、自测和文档\n\n**代码规范**\n- 养成良好的注释习惯，超过三个月的代码，自己都会忘了当时在想什么\n- 不要有魔法数字，魔法字符串\n- 重复的逻辑抽象成公共的方法，不要copy代码\n- 正确使用IDE的重构功能，防止修改错误\n\n**自测**\n\n- 单元测试\n- 功能环境测试测试\n- 数据构造\n\n**文档**\n\n- 大型改造需要有技术设计文档，方案评审\n- 好的接口文档能更方便的和前端进行沟通\n\n\n## 测试阶段\n\n![](p5.png)\n\n**功能环境**\n\n- 需要一个能模拟线上的环境进行开发和测试\n- 环境和环境之间能够隔离，不影响其他功能的开发和测试\n\n**集成环境**\n\n- 不同人开发的功能合并在一起测试，相互之间的影响可能产生缺陷\n- 迭代发布的所有功能合并在一起测试，确保发布的所有功能之间的影响不产生缺陷\n\n**回归环境**\n\n- 确保新的功能不对老的功能产生影响\n- 回归测试一般会借助自动化测试脚本\n\n\n## 发布阶段\n\n发布之前要查询检查一遍，观察每个服务的发布状态，及时处理异常\n\n发布过程中监视和告警需要特别关注，如果有异常立刻判断是否由变更引起，如果是变引起或用户反馈，及时终止发布。\n\n**发布负责人**\n\n- 负责按照计划执行发布\n- 需要通知各个相关人员发布进展\n- 观察各个服务的发布状态，及时处理异常\n\n**变更服务的相关 RD**\n\n- 按照上线checklist检查服务的日志，监控，响应上线过程中的告警\n- 对于自己负责的改动，在小流量或者是预览环境进行功能验证\n- 执行发布计划中的其他操作(如线上配置，数据处理等)\n\n**值班同学**\n\n- 发布过程中的监控和告警需要特别关注，如果有异常需要立刻判断是否由变更引起\n- 如果有变更引起的告警或者用户反馈，需要及时中止发布\n\n### 简单发布\n\n直接用新版本覆盖老版本\n\n- 优点：简单、成本低\n\n- 缺点：发布过程中服务会中断，出了问题会影响全部用户\n\n适用：\n- 测试环境部署\n- 小公司或非核心业务\n\n### 金丝雀发布\n\n由于金丝雀对瓦斯非常铭感，因此以前开矿下矿洞，先放一只金丝雀进去探是否有毒气体，看到金丝雀能否活下来，金丝雀发布由此得名。先发一台服务看看是否有问题\n\n- 优点：相对简单，能用少量用户验证新版本功能\n\n- 缺点：发布过程中服务也会中断，发现不了随用户增大才会暴露的问题\n\n适用：\n- 测试环境部小公司或非核心业务\n\n### 滚动发布（推荐）\n\n每个实例都通过金丝雀的方式逐步放大流量，对用户影响小，体验平滑\n\n- 优点：发布过程中用户不会中断，可以充分验证服务功能\n\n- 缺点：流程复杂，对发布系统比较高的要求，发布速度慢，新老版本不兼容的情况不能用\n\n适用：\n- 发布系统能力较强，可以平滑切换流量\n- 发布自动化程度高，可以自动滚动\n\n### 蓝绿发布（推荐）\n\n把服务分为蓝绿两组，先把蓝组流量摘除然后升级，只用绿组提供服务，之后切换全部流量，只用蓝组提供服务，然后升级绿组服务，最终全部升级\n\n- 优点：发布速度快，流程相对简单\n\n- 缺点：需要对一般机器承担所有流量的能力，出问题影响全部用户\n\n适用：\n- 服务器资源丰富\n- 新老版本不能兼容的情况，需要一次性升级到新版\n\n半夜流量一般比较低，适合做发布，所有这就是大部分后端开发都工作时间比较晚的原因\n\n### 红黑发布\n\n和蓝绿发布类似，但是发布时会动态扩容出一组新的服务，而不需要常备两组服务\n\n- 优点：发布速度快流程相对简单\n\n- 缺点：需要能扩容一倍对机器数量仍然有要求，出问题会影响全部用户\n\n适用：\n- 服务器资源丰富\n- 新老版本不能兼容的情况，需要一次性升级到新版\n\n\n## 运维阶段（了解就行）\n\n公司在发展过程中，逐渐形成了十分复杂的超大规模微服务体系。为了实现对这些复杂微服务的监控，我们往往会在微服务中添加埋点采\n集 Metrics、Logging、分布式 Trace 等多种数据。\n\n# 优化流程\n\n- 技术的发展会带来质量和效率的同时提高\n- 将质量保障融入到流程，将流程自动化\n- 从需求到上线全流程自动化，同时提高质量和效率\n\n- DevOps：将开发和运维无缝集成的方法论，通过自动化和协作提高软件开发和运维效率和质量。\n- 全流程自动化：通过自动化工具和流程实现代码构建、测试、部署和监控等环节的自动化。\n- 目标是提高团队效率、减少手动操作和人为错误，实现快速交付和持续集成。\n\n\n\n","tags":["字节青训营"]},{"title":"网络接入","url":"/2025/02/12/articles/MarsCode学习笔记/11.网络接入/网络接入/","content":"\n# 域名系统\n\n使用域名系统来代替 hosts 文件\n\n关于域名空间:\n\t- 域名空间被组织成树形结构\n\t- 域名空间通过划分zone的方式进行分层授权管理\n\t- 全球公共域名空间仅对应一棵树\n\t- 根域名服务器:查询起点\n\t- 域名组成格式:[a-zA-Z0-9-]，以点划分label\n\n![](MarsCode学习笔记/11.网络接入/p1.png)\n\n顶级域gTLD（general Top-level Domains）：gov政府.edu教育.com商业.mil军事.org非盈利组织\n\n# DNS服务器\n\n### DNS查询过程\n\n![](p2.png)\n\n比如这里的网络客户端想要访问163.com域名，首先会访问本地的DNS服务器，看看有没有163.com域名的解析记录，第一次访问都不会有解析记录的，如果没有解析记录会依次向根、顶级域进行解析以及保存在本地，以便于下次查询\n\n### DNS记录类型\n\n- A/AAAA:IP指向记录，用于指向IP，前为IPv4记录，后者为IPv6记录\n- CNAME:别名记录，配置值为别名或主名，客户端根据别名继续解析以提取IP地址\n- TXT:文本记录，购买证书时需要\n- MX:邮件交换记录，用于指向邮件交换服务器\n- NS:解析服务器记录，用于指定哪台服务器对于该域名解析\n- SOA 记录:起始授权机构记录，每个zon要权威服务器的记录,有且仅有唯一的一条SOA记录，SOA是描述zone属性以及主\n\n# 接入HTTPS协议\n\n由于HTTP是明文传输，很容易被截取，因此有了HTTPS\n\n### 对称加密和非对称加密\n\n加密是在传输过程中为无规则乱码，即使被第三方获取，在没有密钥的情况下也无法进行解密数据，从而保证了数据的安全性\n\t- 对称加密由于双方密码一致，在发送时需要把密码发送给对方，这样在传输的过程中就有可能被截获\n\t- 非对称加密加密和解密使用两种不同的密钥，公钥和私钥，如果使用公钥加密就需要用私钥解密，反之一致\n\n![](p3.png)\n\n### 证书链\n\n- Server 端发送是带签名的证书链\n\t\n- Client 收到会仍然需要验证\n\t- 是否是可信机构颁布\n\t- 域名是否与实际访问一致\n\t- 检查数字签名是否一致\n\t- 检查证书的有效期\n\t- 检查证书的撤回状态\n\n# 接入全站加速\n\n源站容量问题：增加后机器扩容;静态内容，使用静态加速缓存\n网络传输问题：动态加速DCDN\n全站加速 = 静态加逗+动态加速\n\n\n一般网址常见的问题有许多，例如：\n- 源站容量低，可承载的并发请求数低，容易被打垮\n- 丢包、劫持、mtu问题报文经过的网络设备越多，出问题的概率越大，自主选路网络链路长，时延高\n- 卡顿响应慢\n- 极大的流失了大部分的用户群体\n- NPS 留存率数据不乐观。\n\n### 静态加速\n\nCDN（Content Delivery Network）内容分发网络，将网站内容发布到最接近用户的边缘节点，使网民可就近取得所需内容，有效解决互联网网络拥塞状况，提高网民访问的响应速度和成功率。静态CDN服务以图片、页面、js、css、大文件安装包等静态文件加速为主。主要原理是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度，如同提供了多个分布在各地的加速器，以达到快速、可冗余的为多个网站加速的目的。\n\n- 解决由于地域、带宽、运营商接入等问题带来的跨网访问问题\n- 结合DNS调度系统，将用户的请求分配至最适合他的节点，提升用户的访问速度\n- 中心节点收敛回源，降低回源且提升命中率，减轻源站压力\n- 隐藏源站，提供大带宽接入，降低源站被攻击的风险\n- 提供存储方案，解决业务线文件存放问题\n\n\n# 四层负载均衡\n\n基于IP+端口，利用某种算法将报文转发给某个后端服务器，实现负载均衡地落到后端服务器上。\n\n三个主要功能:\n1. 解耦 vip 和 rs\n2. NAT\n3. 防攻击:syn proxy\n\n![](p4.png)\n\n\n## 常见的算法\n\n- RR轮询:Round Robin，将所有的请求平均分配给每个真实服务器RS\n- 加权RR轮询:给每个后端服务器一个权值比例，将请求按照比例分配\n- 最小连接:把新的连接请求分配到当前连接数最小的服务器\n- 五元组hash:根据sip、sport、proto、dip、dport对静态分配的服务器做散列取模\n\t缺点:当后端某个服务器故障后，所有连接都重新计算，影响整个 hash 环\n- 一致性hash:只影响故障服务器上的连接session，其余服务器上的连接不受影响\n\n\n\n ","tags":["字节青训营"]},{"title":"消息队列","url":"/2025/02/10/articles/MarsCode学习笔记/10.消息队列/消息队列/","content":"# 消息队列\n\n（听不懂，不是人听的，内容的很奇怪，像初见，又像告别，又像是重逢，能看懂并且记下来都是神人了）\n\n消息队列（MQ），指保存消息的一个容器，本质是个队列。要想称之为消息队列，这个队列要支持 **高吞吐**、**高并发** 并且 **高可用**。\n\n## Kafka\n\n### Kafka 的使用\n\n1. 首先需要创建一个 Kafka 集群；\n2. 在这个集群中创建一个 Topic，并且设置好分片数量；\n3. 编写生产者逻辑，引入对应语言的 SDK，配置好集群和 Topic 等参数，初始化一个生产者，调用 Send 方法发送消息；\n4. 编写消费者逻辑，引入对应语言的 SDK，配置好集群和 Topic 等参数，初始化一个消费者，调用 Poll 方法接收消息。\n\n### Kafka的原理\n\n![](MarsCode学习笔记/10.消息队列/p1.png)\n\n- Topic : 逻辑队列，不同Topic 可以建立不同的 Topic\n- Cluster : 物理集群，每个集群中可以建立多个不同的 Topic\n- Producer : 生产者，负责将业务消息发送到Topic 中\n- Consumer : 消费者，负责消费 Topic 中的消息\n- ConsumerGroup : 消费者组，不同组Consumer 消费进度互不干涉\n\n这其中还涉及到 Topic 内的 offset(相对位置)，Replica（副本），以及副本分布相关概念：\n\n- Offset : 消息在 partition 内的相对位置信息，可以理解为唯一D，在 partition 内部严格递增\n- Replica : 每个分片有多个 Replica，Leader Replica 将会从 ISR(In-Sync Replicas) 中选出，一般分为 Leader 和 Follower，Leader 是主片， Follwer 会异步去同步 Leader，以防 Leader 挂了可以立马补上\n\n### Kafka 运行流程\n\n（这里我也没看懂QAQ）\n\n一条消息进入 kafka 处理的流程为： `Producer -> Broker -> Consumer`，在这三个部分可以分别采取一些方案帮助 Kafka 提高吞吐或者稳定性。\n\n- Producer 端逻辑\n\t- 批量发送\n\t\t- 为了应对大消息量的场景，采取批量发送机制，通过一次性发送多个消息从而减少 I/O 次数，加强发送能力\n\t- 消息压缩\n\t\t- 在消息容量太大，带宽较小，导致发送速度慢的场景下，kafka 提供了消息压缩，通过对消息进行压缩处理减小消息的大小\n- Broker 端逻辑\n\t- 写入\n\t\t- 在存储过程中，kafka 会通过副本生成日志，将日志写入磁盘，而这些日志显然是有时效的，因此根据存入的有效时间存入不同的日志段 LogSegment，此外根据磁盘的结构，采用顺序写的方式进行写入，可以提高写入效率\n\t- 读取\n\t\t- Consumer 通过发送 FetchRequest 请求消息数据，Broker 通过索引取出消息，按照时间窗口和信息大小发送给 Consumer\n\t- Broker 有两种文件索引方式\n\t\t- 偏移量索引：通过二分法寻找小于目标 offset 的最大文件\n\t\t- 时间戳索引：通过二分法找到小于目标时间戳最大的索引位置\n\t- 数据拷贝\n\t\t- kafka 拷贝数据的流程不经过用户态空间，而是在读取磁盘后直接将 Read Buffer 中的数据传输到 NIC Buffer，通过 NIC Buffer 直接交付给消费者进程\n- Consumer 端逻辑\n\t- 分配的问题，也就是对于每一个 partition 来讲，该由哪一个 consumer 来消费\n\t\t- 手动分配（low level）：在启动的时候分配任务，哪个 Consumer 负责拉取哪几个 partition，但是万一其中一个 Consumer 宕机，就会导致无法拉取到完全的 partition\n\t\t- 自动分配（high level）：对于每一个消费者组，都会选择一个 Broker 作为一个协调者 Coordinator，这个协调者负责分配各个消费者获取 partition 的任务，这使得可以动态调整各个 Consumer 的任务\n\n### Kafka缺点\n\n- 运维成本高；\n- 负载不均衡，解决方案复杂；\n- 没有自己的缓存，需要依赖外部Cache;\n- 若 Controller 和 Coordinator 与 Broker 在同一个进程中，大量 I/O 会导致性能下降。\n\n\n## BMQ\n\nBMQ （Bytedance Message Queue） 是字节跳动出品的消息队列产品，解决了 Kafka 在实际应用中的诸多问题。\n\n### BMQ 架构模型\n\n兼容 Kafka 协议，存算分离，云原生消息队列\n\n- 新增 Proxy 层作为代理；\n- Coordinator 和 Controller 可以独立部署；\n- 底层新增 HDFS 用于存算分离。\n\nProxy 负责接收所有用户的请求，对于生产请求，Proxy 会将其转发给对应的 Broker；对于消费者相关的请求，例如 commit offset，join group 等，Proxy 会将其转发给对应的 Coordinator；对于读请求 Proxy 会直接处理，并将结果返回给客户端。\n\nBMQ 的 Broker 与 Kafka 的 Broker 略有不同，它主要负责写入请求的处理，其余请求交给了 Proxy 和 Coordinator 处理。\n\nCoordinator 与 Kafka 版本最大的差别在于我们将其从 Broker 中独立，作为单独的进程提供服务。这样的好处是读写流量与消费者协调的资源可以完全隔离，不会互相影响。另外 Coordinator 可以独立扩缩容，以应对不同集群的情况。\n\nController 承担组件心跳管理、负载均衡、故障检测及控制命令接入的工作。因为 BMQ 将数据放在分布式存储系统上，因此无需管理数据副本，相较于 Kafka 省去了 ISR 相关的管理。Controller 可以更加专注地关注集群整体流量均衡及故障检测。\n\n\n![](p2.png)\n\n### BMQ的优点\n\n  - **Kafka痛点**：传统Kafka采用分区（Partition）与Broker强绑定的架构，扩容需数据重平衡，导致运维复杂、资源浪费。\n    \n- **BMQ解决方案**：\n    \n    - **Proxy层解耦**：引入无状态Proxy节点处理客户端请求，与存储层分离，实现**动态扩缩容**无需数据迁移。\n        \n    - **分布式存储层**：数据持久化采用自研分布式存储系统（如HDFS或对象存储），支持**弹性扩展**，降低存储成本。\n        \n    - **自动负载均衡**：Topic分区动态调度至不同存储节点，规避Kafka的\"热点分区\"问题。\n\n- **BMQ关键技术**：\n    \n    - **零拷贝优化**：绕过操作系统内核，直接操作存储设备（如SPDK），减少数据拷贝次数。\n        \n    - **异步流水线**：写路径采用异步化设计，合并小IO为顺序写入，提升吞吐量。\n        \n    - **分层存储**：热数据存内存/SSD，冷数据转至廉价HDD或对象存储，平衡成本与性能。\n\n\n### BMQ的读写流程\n\n- 创建Producer和Consumer：在使用BMQ之前，需要创建Producer和Consumer并连接到消息队列服务器。\n    \n- 创建队列：BMQ支持多个队列，可以为不同的消息类型创建不同的队列。\n    \n- 发送消息：生产者将消息发送到指定的队列中，消息会被存储到消息队列中，等待消费者来获取。\n    \n- 获取消息：消费者从队列中获取消息，并进行处理。\n    \n- 确认消息：消费者在处理完消息后，需要向BMQ服务器发送确认消息，告诉服务器已经消费完成。\n\n## RocketMQ\n\n（没看懂，但是好像很重要，留住，以后再学）\n\nRocketMQ 以低延时出名，适合用在电商或者一些实时的业务上\n\n官方文档：[rocketmq.apache.org/docs/](https://link.juejin.cn/?target=https%3A%2F%2Frocketmq.apache.org%2Fdocs%2F \"https://rocketmq.apache.org/docs/\")\n\n### 基本概念\n![](p3.png)\n\n### 基本架构\n![](p4.png)\n\n\n\n\n\n","tags":["字节青训营"]},{"title":"Go 框架三件套","url":"/2025/02/07/articles/MarsCode学习笔记/9.Go 框架三件套详解(Web RPC ORM)/Gorm 框架/","content":"## Gorm 的基本使用\n\n![](MarsCode学习笔记/9.Go%20框架三件套详解(Web%20RPC%20ORM)/p1.png)\n\n相关文档 https://gorm.io/zh_CN/docs/index.html\n\ngorm目前支持 MySQL、SQLServer、PostgreSQL、SQLite\n\n以 MySQL 为例：\n```go\nimport (\n  \"gorm.io/driver/mysql\"\n  \"gorm.io/gorm\"\n)\n\nfunc main() {\n  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情\n  dsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local\"\n  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})\n}\n```\n\n或者可以更详细的配置：\n```go\ndb, err := gorm.Open(mysql.New(mysql.Config{\n  DSN: \"gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&parseTime=True&loc=Local\", // DSN data source name\n  DefaultStringSize: 256, // string 类型字段的默认长度\n  DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持\n  DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引\n  DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列\n  SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置\n}), &gorm.Config{})\n```\n\n### 创建数据\n\n![](p2.png)\n\n我们可以使用 `clause.OnConflict` 处理数据冲突\n`DoNothing: true` 意思是遇到数据冲突不做任何改变 \n```go\np:=&Product{Code:\"D42\"，ID:1}\ndb.Clauses(clause.OnConflict{DoNothing: true}).Create(&p)\n```\n\n可以使用 `default` 标签为字段定义默认值\n```go\ntype User struct {\n\tID      int64\n\tName    string `gorm:\"default:galeone\"`\n\tAge     int64  `gorm:\"default:18\"`\n}\n```\n\n### 查询数据\n\n![](p3.png)\n\n需要注意的点：\n\n- 使用 First 时，需要注意查询不到数据会返回 ErrRecordNotFound\n\t\n- 使用 Find 查询多条数据，查询不到数据不会返回错误\n\t\n- 当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 0、\"、false 或其他 零值，该字段不会被用于构建查询条件，使用Map 来构建查询条件。\n\n### 更新数据\n\n![](p4.png)\n\n使用 Struct 更新时，只会更新非零值，如果需要更新零值可以使用 Map 更新或使用Select 选择字段。\n\n\n### 删除数据\n\n#### 物理删除\n\n![](p5.png)\n\n#### 软删除\n\nGORM 提供了 gorm.DeletedAt 用于帮助用户实现软删\n\n拥有软删除能力的 Model 调用 Delete 时，记录不会被从数据库中真正删除。但 GORM 会将 DeletedAt 置为当前时间并且你不能再通过正常的查询方法找到该记录。\n\n使用 Unscoped 可以查询到被软删的数据\n\n\n### 事物\n\nGorm 提供了 Begin、Commit、Rollback 方法用于使用事务\n\n![](MarsCode学习笔记/9.Go%20框架三件套详解(Web%20RPC%20ORM)/p6.png)\n\n- 特别注意的点，db.Begin() 后会生成一个变量，我们后续的操作都是通过后面的变量\n\n\nGorm 提供了 Tansaction 方法用于自动提交事务，避免用户漏写 Commit、Rollbcak\n\n![](p7.png)\n\n\n","tags":["字节青训营"]},{"title":"对象存储","url":"/2025/02/06/articles/MarsCode学习笔记/8.对象存储 TOS/对象存储 TOS/","content":"\n我在青训营看完这章对象存储TOS感觉对理论性的知识有了一定了解吧，太理论了，让我复述一遍可能都做不到\n\n我在网上查阅资料后得知\n\n- **T**：**Tencent**，表示这是腾讯云提供的服务。\n    \n- **O**：**Object**，表示对象存储（Object Storage），是一种存储非结构化数据的技术。\n    \n- **S**：**Storage**，表示存储服务。\n\n\n首先开头以抖音短视频为例\n![](MarsCode学习笔记/8.对象存储%20TOS/p1.png)\n\n架构大概分为 片源 -> 转码  -> 审核 -> 播放\n\n但是短视频系统要承载非常多的用户访问量，根据未来的可能的用户数量，做了简单数学计算，结果发现存储量非常之大：\n\n- 每天: 432块4tb磁盘 \n\t\n- 每月：12960块4tb磁盘 \n\t\n- 每年： 157680块4tb盘\n\n对于这么大的访问量，我们需要一个合适的存储去承载数据，这个储存需要满足以下三个条件：\n\n- 海量\n\t\n- 易用\n\t\n- 便宜\n\n然后列举了四个存储系统\n\n- 单机存储——>不支持海量，适合的数据类型（单击文件）——>不行\n\t\n- 单机数据库——> 不支持海量,只支持结构化和半结构化数据——>不行\n\t\n- 分布式数据库——>支持海量，但是单条记录存储的容量太少——>不行\n\t\n- 分布式存储——> 大数据计算中间结果/视频/图片——>行\n\n\n分布式文件系统（HDFS）\n\n- 海量：支持PB——>EB海量存储 \n\t\n- 易用：伪Posix文件接口，开发略微复杂，非云原生，搭建维护麻烦，视频、图片相关生态接入略微复杂 \n\t\n- 便宜：使用普通x86服务器，成本低\n\n\n分布式对象存储TOS\n\n- 海量：支持>eb海量存储\n\t\n- 易用：RestFul HTTP接口，开发极其简单，云原生，按需申请使用\n\t\n- 便宜：使用普通x86服务器，具备冷热数据分级存储能力，成本更低\n\n\nTOS 的接口\n\n```\nMkdirs创建文件夹\nAppend：写\nGET：下载对象\nHEAD：查看对象上传\nPUT：上传对象\nDELETE：删除对象\n```\n\nTOS 中Bucket/Object语义\n```\nBucket：存储对象的桶，可类比一下\nObject：对象，包含以下三个部分\nkey:对象的名字，可类比于Map的key\nData：对象的内容，例如视频、图片内容\nMetaData：对象的一些元信息\n```\n\n\n\n ","tags":["字节青训营"]},{"title":"SpringBoot学习笔记","url":"/2025/01/25/articles/SpringBoot/SpringBoot/","content":"# 体验SpringBoot\n\n## 创建项目\n\n所有的SpringBoot依赖都是以starter的形式命名的，之后我们需要导入其他模块也是导入 `spring boot-starter-xxxx` 这种名称格式的依赖。\n\nSpringBoot为我们提供了包含内置Tomcat服务器的Web模块，我们只需要导入依赖就能直接运行服务器\n把原来的\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter</artifactId>  \n</dependency>\n```\n换成\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-web</artifactId>  \n</dependency>\n```\n![](SpringBoot/p1.png)\n点击启动后可以看到已经启动了内置的 tomcat\n\n在浏览器上打开 `localhost:8080` 可以访问\n![](p2.png)\n可以看到成功响应了404页面，相比之前的大量配置，可以说方便了很多，我们到目前为止仅仅是导入了一个依赖，就可以做到直接启动我们的Web服务器并正常访问\n\nSpringBoot支持自动包妇描，我们不需要编写任何配置，直接在任意路径(但是不能跑到主类所在包外面去了)下创建的组件(如Controller、Service、Component、Configuration等)都可以生效\n\n比如创建一个Controller\n```java\npackage com.example.demo.controller;  \n  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.web.bind.annotation.GetMapping;  \nimport org.springframework.web.bind.annotation.ResponseBody;  \n  \n@Controller  \npublic class TestController {  \n  \n    @ResponseBody  \n    @GetMapping(\"/\")  \n    public String index() {  \n        return \"Hello World!\";  \n    }  \n}\n```\n\n然后我们不需要扫描，直接启动\n![](p3.png)\n\n\n包括一个对象现在也可以直接以JSON形式返回给客户端，无需任何配置，如果启动不成功或者页面没有显示，请检查Lombok是否有正确启动（我用的时候就是没有找到构造方法和getter/setter，推测原因是Lombok）\n```java\n@Controller  \npublic class TestController {  \n  \n    @ResponseBody  \n    @GetMapping(\"/\")  \n    public Student index() {  \n        return new Student(1, \"呵帅\", \"男\");  \n    }  \n}\n```\n\n![](p4.png)\n\n\n## 常用模块整合\n\nspring-boot-starter-web包含了以下依赖\n```xml\n<dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter</artifactId>\n      <version>3.4.2</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-json</artifactId>\n      <version>3.4.2</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <version>3.4.2</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n      <version>6.2.2</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>6.2.2</version>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n```\n\n里面包含了以下内容\n- spring-boot-starter 基础依赖starter\n- spring-boot-starter-json 配置JSON转换的starter\n- spring-boot-starter-tomcat 内置Tomcat服务器\n- spring-web、spring-webmvc 之前mvc的内容\n\n如果需要像之前一样添加WebMvc配置类，方法是一样的，直接创建\n```java\npackage com.example.demo.config;  \n  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.web.servlet.HandlerInterceptor;  \nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;  \nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  \n  \n//只需要添加Configuration用于注册配置类，不需要其他任何注解，已经自动配置好了  \n@Configuration  \npublic class WebConfiguration implements WebMvcConfigurer {  \n    @Override  \n    public void addInterceptors(InterceptorRegistry registry) {  \n        registry.addInterceptor(new HandlerInterceptor() {  \n            @Override  \n            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n                System.out.println(\"请求被拦截\");  \n                return HandlerInterceptor.super.preHandle(request, response, handler);  \n            }  \n        });  \n    }  \n}\n```\n\n同样security也是一样的，首先添加依赖\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-security</artifactId>  \n</dependency>\n```\n\n导入完依赖直接启动\n![](p5.png)\n\n我们没有进行任何配置，而是对应的Starter帮助我们完成了默认的配置，并且在启动时，就已经帮助我们配置了一个随机密码的用户可以直接登录使用（Username是user）\n![](SpringBoot/p6.png)\n\n如果需要额外进行配置，只需要添加配置类即可\n```java\npackage com.example.demo.config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;  \nimport org.springframework.security.web.SecurityFilterChain;  \n  \n@Configuration  \npublic class SecurityConfiguration {  \n  \n    @Bean  \n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {  \n        return http  \n                .authorizeHttpRequests(auth -> {  \n                    auth.anyRequest().authenticated();  \n                })  \n                .formLogin(conf -> {  \n                    conf.loginPage(\"/login\");  \n                    conf.loginProcessingUrl(\"/doLogin\");  \n                    conf.defaultSuccessUrl(\"/\");  \n                    conf.permitAll();  \n                })  \n                .build();  \n    }  \n}\n```\n\n同样的，我们也可以快速整合之前使用的模版引擎，比如Thymeleaf框架，直接上对应的Starter即可\n```xml\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-thymeleaf</artifactId>  \n</dependency>\n```\n\n## 自定义运行器\n\n在项目中，可能会遇到这样一个问题:我们需要在项目启动完成之后，紧接着执行一段代码，我们可以编写自定义的ApplicationRunner，会在项目启动完成后执行\n```java\n@Component  \npublic class TestRunner implements ApplicationRunner {  \n    @Override  \n    public void run(ApplicationArguments args) throws Exception {  \n        System.out.println(\"自定义执行\");  \n    }  \n}\n```\n\n当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行\n\n## 配置文件\n\n虽然SpringBoot快捷开发确实很方便，不过我们发现有些东西还是需要我们自己来编写配置才可以，不然SpringBoot项目无法正常启动。我们可以直接在application.properties 中进行配置编写，它是整个SpringBoot的配置文件，比如要修改服务器的默认端口:\n\n![](p7.png)\n\n这些配置其实都是各种Starter提供的，部分配置在Starter中具有默认值，我们即使不配置也会使用默认值，比如这里的8080就是我们服务器的默认端口，我们也可以手动修改它，来变成我们需要的。\n\n除了配置已经存在的选项，我们也可以添加自定义的配置，来方便我们程序中使用，比如我们这里创建一个测试数据:\n```properties\ntest.hello=8080\n```\n\n```java\n@Controller  \npublic class TestController {  \n  \n    @Value(\"${test.hello}\")  \n    String hello;  \n  \n    @GetMapping(\"/login\")  \n    public String login() {  \n        System.out.println(hello);  \n        return \"login\";  \n    }  \n}\n```\n\n配置文件除了使用 `properties` 格式以外，还有一种叫做 `yaml` 格式，它的语法如下\n```yml\n一级目录:\n\t二级目录:\n\t\t三级目录1:值\n\t\t三级目录2:值\n\t\t三级目录List:\n\t- 元素1\n\t- 元素2\n\t- 元素3\n```\n我们可以看到，每一级目录都是通过缩进(不能使用Tab，只能使用空格)区分，并且键和值之间需要添加冒号+空格来表示\n\n例如:\n```yml\nserver:  \n  port: 8080  \nSpring:  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/test  \n    username: root  \n    password: Abc123  \n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n注意如果你的数据库密码是以0开头或者0x开头会被默认转义为八进制和十六进制,要用引号把密码引起来\n\n### 常见的配置项\n\nSpringSecurity和SpringBootMvc配置\n```yml\nspring:  \n  # Spring Mvc相关配置  \n  mvc:  \n    static-path-pattern: /static/**  # 静态资源访问路径  \n  # Spring Security相关配置  \n  security:  \n    filter:  \n      order: -100  # 过滤优先级，数字越小优先级越高  \n    user:  \n      name: 'admin'  # 登录用户名  \n      password: '123456'  # 登录密码  \n      roles:   # 登录用户角色  \n        - admin  \n        - user\n```\n\n## mybatis\n\n整合Mybatis需要把本身的驱动加上\n```xml\n<dependency>  \n    <groupId>org.mybatis.spring.boot</groupId>  \n    <artifactId>mybatis-spring-boot-starter</artifactId>  \n    <version>3.0.2</version>  \n</dependency>  \n<dependency>  \n    <groupId>com.mysql</groupId>  \n    <artifactId>mysql-connector-j</artifactId>  \n    <scope>runtime</scope>  \n</dependency>\n```\n\n```yml\nserver:  \n  port: 8080  \nSpring:  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/test  \n    username: root  \n    password: Abc123  \n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n这里我们接续来测试一下MyBatis的配置，想要在SpringBoot中使用Mybatis也很简单，不需要进行任何配置，我们直接编写Mapper即可\n直接为需要注册为Mapper的接口添加 @Mapper 注解，来表示这个接口作为Mapper使用\n```java\n@Mapper  \npublic interface UserMapper {  \n    @Select(\"select * from test where id = #{id}\")  \n    User findUserById(int id);  \n}\n```\n\n测试：\n```java\n@Resource  \nUserMapper mapper;\n\n@ResponseBody  \n@GetMapping(\"/test\")  \npublic User test() {  \n    return mapper.findUserById(1);  \n}\n```\n\n注：**如果运行失败，检查是否是maven依赖版本不兼容**\n\n\n## 打包运行\n\n我们可以使用maven工具\n\n![](p8.png)\n\n然后在当前目录下的命令行中输入：`java -jar 包名.jar`\n\n### GraalVM\n\n我们SpringBoot项目除了打包为传统的Jar包基于JVM运行之外，我们也可以将其直接编译为操作系统原生的程序来进行使用(这样会大幅提升程序的运行效率，但是由于编译为操作系统原生程序，这将无法支持跨平台)\n\n具体内容：[十分钟带你了解 Oracle 最新的 JVM 技術——GraalVM - 知乎](https://zhuanlan.zhihu.com/p/106555993)\n\n**还未广泛运用，了解为主**\n\n## 日志系统\n\n我们在之前学习SSM时，如果不配置日志，就会报错，但是到了SpringBoot阶段之后日志打印得也非常统一，不会出现这个问题\n\n### 日志门面和日志实现\n\n日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有lqg4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。\n日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。\n\nSpringBoot为了统一日志框架的使用，做了这些事情\n- 直接将其他依赖以前的日志框架剔除\n- 导入对应日志框架的Slf4i中间包\n- 导入自己官方指定的日志实现，并作为Slf4j的日志实现层\n\n日志级别从低到高分为TRACE<DEBUG<INFO<WARN<ERROR<FATAL， SpringBoot默认只会打印INFO以上级别的信息\n\n如果想要输出日志信息像之前JUL一样就行了\n```java\n@Slf4j  \n@Controller  \npublic class TestController {  \n@PostConstruct  \n    public void init() {  \n        log.info(\"日志信息\");  \n    }  \n}\n```\n\n### 配置 logback日志\n\n和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Profile功能，它的内容类似于这样:`logback-spring.xml`\n\n最外层由 configuration 包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。\n在org/springframework/boot/logging/logback/defaults.xml 中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的appender 即可:\n```xml\n<configuration>  \n    <!--  导入其他配置文件，作为预设  -->  \n    <include resource=\"org/springframework/boot/logging/logback/defaults.xml\" />  \n  \n    <property name=\"CONSOLE_LOG_PATTERN\" value=\"%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd}}){faint} %clr([%X{reqId}]){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}){} %clr(${PID:-}){magenta} %clr(--- %esb(){APPLICATION_NAME}%esb{APPLICATION_GROUP}[%15.15t] ${LOG_CORRELATION_PATTERN:-}){faint}%clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\"/>  \n  \n    <!--  Appender作为日志打印器配置，这里命名随意  -->  \n    <!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  -->  \n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">  \n        <encoder>            <pattern>${CONSOLE_LOG_PATTERN}</pattern>  \n            <charset>${CONSOLE_LOG_CHARSET}</charset>  \n        </encoder>    </appender>  \n    <!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  -->  \n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">  \n        <encoder>            <pattern>${FILE_LOG_PATTERN}</pattern>  \n            <charset>${FILE_LOG_CHARSET}</charset>  \n        </encoder>        <!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  -->  \n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">  \n            <!--  文件保存位置以及文件命名规则，这里用到了%d{yyyy-MM-dd}表示当前日期，%i表示这一天的第N个日志  -->  \n            <FileNamePattern>log/%d{yyyy-MM-dd}-spring-%i.log</FileNamePattern>  \n            <!--  到期自动清理日志文件  -->  \n            <cleanHistoryOnStart>true</cleanHistoryOnStart>  \n            <!--  最大日志保留时间  -->  \n            <maxHistory>7</maxHistory>  \n            <!--  最大单个日志文件大小  -->  \n            <maxFileSize>10MB</maxFileSize>  \n        </rollingPolicy>    </appender>  \n    <!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  -->  \n    <root level=\"INFO\">  \n        <appender-ref ref=\"CONSOLE\"/>  \n        <appender-ref ref=\"FILE\"/>  \n    </root></configuration>\n```\n\n配置完，运行就会生成一个日志文件\n\n比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制“Mapped Diagnostic Context”（映射诊断上下文）：\n```java\n@Slf4j  \n@Controller  \npublic class TestController {  \n  \n    @GetMapping(\"/\")  \n    @ResponseBody  \n    public String hello(HttpSession session) {  \n        MDC.put(\"reqId\", session.getId());  \n        log.info(\"访问了一次测试接口\");  \n        return \"Hello World\";  \n    }  \n}\n```\n\n### 自定义Banner展示\n\n可以直接来配置文件所在目录下创建一个名为`banner.txt`的文本文档，内容随便\n```txt\n${AnsiColor.yellow}  \n//                          _ooOoo_                               //  \n//                         o8888888o                              //  \n//                         88\" . \"88                              //  \n//                         (| ^_^ |)                              //  \n//                         O\\  =  /O                              //  \n//                      ____/`---'\\____                           //  \n//                    .'  \\\\|     |//  `.                         //  \n//                   /  \\\\|||  :  |||//  \\                        //  \n//                  /  _||||| -:- |||||-  \\                       //  \n//                  |   | \\\\\\  -  /// |   |                       //  \n//                  | \\_|  ''\\---/''  |   |                       //  \n//                  \\  .-\\__  `-`  ___/-. /                       //  \n//                ___`. .'  /--.--\\  `. . ___                     //  \n//              .\"\" '<  `.___\\_<|>_/___.'  >'\"\".                  //  \n//            | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |                 //  \n//            \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /                 //  \n//      ========`-.____`-.___\\_____/___.-`____.-'========         //  \n//                           `=---='                              //  \n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //  \n//             佛祖保佑          永无BUG         永不修改             //  \n${AnsiColor.black}\n```\n\n可以使用在线生成网站进行生成自己的个性Banner：[https://www.bootschool.net/ascii](https://www.bootschool.net/ascii)\n\n切换颜色\n```xml\n${AnsiColor.BRIGHT_GREEN} //绿色\n```\n\n常用配置\n```xml\n${AnsiColor.YELLOW} 当前 Spring Boot 版本：${spring-boot.version}\n```\n\n## 多环境配置\n\n在日常开发中，我们项目会有多个环境。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。\n\nSpringBoot给我们提供了一种方式，在 `application.yml`下，我们可以通过配置文件指定\n\n```yml\nspring:\n  profiles:\n    active: dev\n```\n\n我们分别创建两个环境的配置文件，`application-dev.yml`和`application-prod.yml`分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：\n```yml\nserver: port: 8080\n```\n\n```yml\nserver: port: 8888\n```\n\nSpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：\n```xml\n<springProfile name=\"dev\">\n    <root level=\"INFO\">\n        <appender-ref ref=\"CONSOLE\"/>\n        <appender-ref ref=\"FILE\"/>\n    </root>\n</springProfile>\n\n<springProfile name=\"prod\">\n    <root level=\"INFO\">\n        <appender-ref ref=\"FILE\"/>\n    </root>\n</springProfile>\n```\n\n我们希望生产环境中不要打包开发环境下的配置文件呢，打包的问题就只能找Maven解决了，Maven也可以设置多环境：\n在 `pom.xml` 中 project 里任意位置\n```xml\n<!--分别设置开发，生产环境-->\n<profiles>\n    <!-- 开发环境 -->\n    <profile>\n        <id>dev</id>\n        <activation>\n            <activeByDefault>true</activeByDefault>\n        </activation>\n        <properties>\n            <environment>dev</environment>\n        </properties>\n    </profile>\n    <!-- 生产环境 -->\n    <profile>\n        <id>prod</id>\n        <activation>\n            <activeByDefault>false</activeByDefault>\n        </activation>\n        <properties>\n            <environment>prod</environment>\n        </properties>\n    </profile>\n</profiles>\n```\n\n在 `pom.xml` 中的 build 中\n```xml\n<resources>\n<!--排除配置文件-->\n    <resource>\n        <directory>src/main/resources</directory>\n        <!--先排除所有的配置文件-->\n        <excludes>\n            <!--使用通配符，当然可以定义多个exclude标签进行排除-->\n            <exclude>application*.yml</exclude>\n        </excludes>\n    </resource>\n\n    <!--根据激活条件引入打包所需的配置和文件-->\n    <resource>\n        <directory>src/main/resources</directory>\n        <!--引入所需环境的配置文件-->\n        <filtering>true</filtering>\n        <includes>\n            <include>application.yml</include>\n            <!--根据maven选择环境导入配置文件-->\n            <include>application-${environment}.yml</include>\n        </includes>\n    </resource>\n</resources>\n```\n\n接着，我们可以直接将Maven中的`environment`属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：\n```yml\nspring:\n  profiles:\n    active: '@environment@'  #注意YAML配置文件需要加单引号，否则会报错\n```\n\n**注意切换环境之后要重新加载一下Maven项目，不然不会生效！**\n\n## 常用框架\n\n### 邮件发送模块\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n比较常用的协议有两种：\n\n1. SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）\n2. POP3协议（主要用于接收邮件 Post Office Protocol 3）\n\n```yml\nspring:  \n  mail:  \n    host: 去百度搜索该邮箱的smtp\n    username: 邮箱  \n    password: 密码（并非账号的密码）\n```\n\n```java\n@SpringBootTest  \nclass Demo1ApplicationTests {  \n  \n    @Autowired  \n    JavaMailSender sender;  \n  \n    @Test  \n    void contextLoads() {  \n        //SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容  \n        SimpleMailMessage message = new SimpleMailMessage();  \n        //设置邮件标题  \n        message.setSubject(\"【广东白云学院教务处】关于近期学校对您的处分决定\");  \n        //设置邮件内容  \n        message.setText(\"同学您好，完美校园数据显示您在本学期以来在本校食堂消费超过503次，积累消费金额超过3000元，您已被评为“校园大饭桶”，特此通知予以嘉奖。奖品将在3月1日西校区一品堂门口发放，感谢您对学校餐厅工作的支持！\");  \n        //设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱  \n        message.setTo(\"邮箱@qq.com\");  \n        //邮件发送者，这里要与配置文件中的保持一致  \n        message.setFrom(\"发送的邮箱@qq.cn\");  \n          \n        sender.send(message);  \n    }  \n}\n```\n\n如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成\n```java\n@Test\nvoid contextLoads() throws MessagingException {\n      //创建一个MimeMessage\n    MimeMessage message = sender.createMimeMessage();\n      //使用MimeMessageHelper来帮我们修改MimeMessage中的信息\n    MimeMessageHelper helper = new MimeMessageHelper(message, true);\n    helper.setSubject(\"Test\");\n    helper.setText(\"lbwnb\");\n    helper.setTo(\"你的QQ号@qq.com\");\n    helper.setFrom(\"发送的邮箱@163.com\");\n      //发送修改好的MimeMessage\n    sender.send(message);\n}\n```\n\n### 接口规则校验\n\n**所需依赖**\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\n如下面代码所示，我们要将接收到的字符串作切割，但是如果接收的字符串长度不满足切割条件时，或者说用户没有按照我们所设想来传参，那么就会直接报错\n```java\n@ResponseBody\n@PostMapping(\"/submit\")\npublic String submit(String username,\n                     String password){\n    System.out.println(username.substring(3));\n    System.out.println(password.substring(2, 10));\n    return \"请求成功!\";\n}\n```\n\n这是最简单的解决方法是做个判断：\n```java\n@ResponseBody\n@PostMapping(\"/submit\")\npublic String submit(String username,\n                     String password){\n    if(username.length() > 3 && password.length() > 10) {\n        System.out.println(username.substring(3));\n        System.out.println(password.substring(2, 10));\n        return \"请求成功!\";\n    } else {\n        return \"请求失败\";\n    }\n}\n```\n\n虽然这样就能直接解决问题，但是如果我们的每一个接口都需要这样去进行配置就太麻烦了，Springboot 为我们提供了很方便的接口校验框架，我们可以使用注解开发完成全部接口的校验：\n```java\n@Slf4j\n@Validated   //首先在Controller上开启接口校验\n@Controller\npublic class TestController {\n\n    ...\n\n    @ResponseBody\n    @PostMapping(\"/submit\")\n    public String submit(@Length(min = 3) String username,  //使用@Length注解一步到位\n                         @Length(min = 10) String password){\n        System.out.println(username.substring(3));\n        System.out.println(password.substring(2, 10));\n        return \"请求成功!\";\n    }\n}\n```\n\n不过这样依然会抛出一个异常，我们可以稍微处理一下，这里我们可以直接使用之前在SSM阶段中学习的异常处理Controller来自行处理这类异常：\n```java\n@ControllerAdvice\npublic class ValidationController {\n\n    @ResponseBody\n    @ExceptionHandler(ConstraintViolationException.class)\n    public String error(ValidationException e){\n        return e.getMessage();   //出现异常直接返回消息\n    }\n}\n```\n\n| 验证注解         | 验证的数据类型                                                                     | 说明                              |\n|--------------|-----------------------------------------------------------------------------|---------------------------------|\n| @AssertFalse | Boolean,boolean                                                             | 值必须是false                       |\n| @AssertTrue  | Boolean,boolean                                                             | 值必须是true                        |\n| @NotNull     | 任意类型                                                                        | 值不能是null                        |\n| @Null        | 任意类型                                                                        | 值必须是null                        |\n| @Min         | BigDecimal、BigInteger、byte、short、int、long、double 以及任何Number或CharSequence子类型 | 大于等于@Min指定的值                    |\n| @Max         | 同上                                                                          | 小于等于@Max指定的值                    |\n| @DecimalMin  | 同上                                                                          | 大于等于@DecimalMin指定的值（超高精度）       |\n| @DecimalMax  | 同上                                                                          | 小于等于@DecimalMax指定的值（超高精度）       |\n| @Digits      | 同上                                                                          | 限制整数位数和小数位数上限                   |\n| @Size        | 字符串、Collection、Map、数组等                                                      | 长度在指定区间之内，如字符串长度、集合大小等          |\n| @Past        | 如 java.util.Date, java.util.Calendar 等日期类型                                  | 值必须比当前时间早                       |\n| @Future      | 同上                                                                          | 值必须比当前时间晚                       |\n| @NotBlank    | CharSequence及其子类                                                            | 值不为空，在比较时会去除字符串的首位空格            |\n| @Length      | CharSequence及其子类                                                            | 字符串长度在指定区间内                     |\n| @NotEmpty    | CharSequence及其子类、Collection、Map、数组                                          | 值不为null且长度不为空（字符串长度不为0，集合大小不为0） |\n| @Range       | BigDecimal、BigInteger、CharSequence、byte、short、int、long 以及原子类型和包装类型          | 值在指定区间内                         |\n| @Email       | CharSequence及其子类                                                            | 值必须是邮件格式                        |\n| @Pattern     | CharSequence及其子类                                                            | 值需要与指定的正则表达式匹配                  |\n| @Valid       | 任何非原子类型                                                                     | 用于验证对象属性                        |\n\n此时接口是以对象形式接收前端发送的表单数据的，这个时候就没办法向上面一样编写对应的校验规则了\n```java\n@Data\npublic class Account {\n    @Length(min = 3)   //只需要在对应的字段上添加校验的注解即可\n    String username;\n    @Length(min = 10)\n    String password;\n}\n```\n\n```java\n@ResponseBody\n@PostMapping(\"/submit\")  //在参数上添加@Valid注解表示需要验证\npublic String submit(@Valid Account account){\n    System.out.println(account.getUsername().substring(3));\n    System.out.println(account.getPassword().substring(2, 10));\n    return \"请求成功!\";\n}\n```\n\n然后修改之前的错误处理，对于实体类接收参数的验证，会抛出`MethodArgumentNotValidException `异常也加进去\n```java\n@ResponseBody\n@ExceptionHandler({ConstraintViolationException.class, MethodArgumentNotValidException.class})\npublic String error(Exception e){\n    if(e instanceof ConstraintViolationException exception) {\n        return exception.getMessage();\n    } else if(e instanceof MethodArgumentNotValidException exception){\n        if (exception.getFieldError() == null) return \"未知错误\";\n        return exception.getFieldError().getDefaultMessage();\n    }\n    return \"未知错误\";\n}\n```\n\n### 接口文档生成（肥肠豪用）\n\n**所需依赖**\n```xml\n<dependency>\n    <groupId>org.springdoc</groupId>\n    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n    <version>2.1.0</version>\n</dependency>\n```\n\nSwagger的主要功能如下：\n\n- 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。\n- 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。\n\n结合Spring框架（Spring-doc，官网：`https://springdoc.org/`\nSwagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。\n\n项目启动之后，我们可以直接访问：`http://localhost:8080/swagger-ui/index.html` 就可以看到开发文档了\n\n修改Swagger的UI界面\n```java\n@Configuration\npublic class SwaggerConfiguration {\n    @Bean\n    public OpenAPI springDocOpenAPI() {\n        return new OpenAPI().info(new Info()\n                .title(\"图书管理系统 - 在线API接口文档\")   //设置API文档网站标题\n                .description(\"这是一个图书管理系统的后端API文档，欢迎前端人员查阅！\") //网站介绍\n                .version(\"2.0\")   //当前API版本\n                .license(new License().name(\"我的B站个人主页\")  //遵循的协议，这里拿来写其他的也行\n                        .url(\"https://space.bilibili.com/288205652\")));\n    }\n}\n```\n\n为Controller编写API描述信息\n```java\n//使用@Tag注解来添加Controller描述信息\n@Tag(name = \"账户验证相关\", description = \"包括用户登录、注册、验证码请求等操作。\")\npublic class TestController {\n\t...\n}\n```\n\n我们可以直接在类名称上面添加`@Tag`注解，并填写相关信息，来为当前的Controller设置描述信息。接着我们可以为所有的请求映射配置描述信息：\n```java\n@ApiResponses({\n       @ApiResponse(responseCode = \"200\", description = \"测试成功\"),\n       @ApiResponse(responseCode = \"500\", description = \"测试失败\")   //不同返回状态码描述\n})\n@Operation(summary = \"请求用户数据测试接口\")   //接口功能描述\n@ResponseBody\n@GetMapping(\"/hello\")\n//请求参数描述和样例\npublic String hello(@Parameter(description = \"测试文本数据\", example = \"KFCvivo50\") @RequestParam String text) {\n    return \"Hello World\";\n}\n```\n\n对于那些不需要展示在文档中的接口，我们也可以将其忽略掉：\n```java\n@Hidden\n@ResponseBody\n@GetMapping(\"/hello\")\npublic String hello() {\n    return \"Hello World\";\n}\n```\n\n对于实体类，我们也可以编写对应的API接口文档：\n```java\n@Data\n@Schema(description = \"用户信息实体类\")\npublic class User {\n    @Schema(description = \"用户编号\")\n    int id;\n    @Schema(description = \"用户名称\")\n    String name;\n    @Schema(description = \"用户邮箱\")\n    String email;\n    @Schema(description = \"用户密码\")\n    String password;\n}\n```\n\n不过，这种文档只适合在开发环境下生成，如果是生产环境，我们需要关闭文档：\n```java\nspringdoc:\n  api-docs:\n    enabled: false\n```\n\n\n# 数据交互\n\n## JDBC交互框架\n\n所需依赖\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n</dependency>\n```\n\n```yml\nspring:  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/test  \n    username: root  \n    password: Abc123  \n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\nspring-jdbc 把所有的增删改查都加入到一个模板类里，并且已经注册好了\n```java\n@Resource  \nJdbcTemplate template;\n```\n\n通过 template 调用已经封装好的方法，现在我们可以只写 SQL 语句了，相当于省略掉了 mapper\n```java\n@Test\nvoid contextLoads() {\n\tint id = 1;\n    Map<String, Object> map = template.queryForMap(\"select * from user where id = ?\", id);\n    System.out.println(map);\n}\n```\n\n也可以自定义\n```java\n@Data\n@AllArgsConstructor\npublic class User {\n    int id;\n    String name;\n    String email;\n    String password;\n}\n```\n\n```java\n@Test\nvoid contextLoads() {\n    User user = template.queryForObject(\"select * from user where id = ?\",\n        (r, i) -> new User(r.getInt(1), r.getString(2), r.getString(3), r.getString(4)), 1);\n    System.out.println(user);\n}\n```\n\n### 简单封装\n\n对于一些插入操作，Spring JDBC为我们提供了更方便的SimpleJdbcInsert工具，比如我们的表是采用自增的ID，那么它支持插入后返回自动生成的ID\n```java\n@Configuration\npublic class WebConfiguration {\n\n    @Resource\n    DataSource source;\n\n    @Test\n    void contextLoads() {\n      \t//这个类需要自己创建对象\n        SimpleJdbcInsert simple = new SimpleJdbcInsert(source)\n                .withTableName(\"user\")   //设置要操作的表名称\n                .usingGeneratedKeyColumns(\"id\");    //设置自增主键列\n        Map<String, Object> user = new HashMap<>(2);  //插入操作需要传入一个Map作为数据\n        user.put(\"name\", \"bob\");\n        user.put(\"email\", \"112233@qq.com\");\n        user.put(\"password\", \"123456\");\n        Number number = simple.executeAndReturnKey(user);   //最后得到的Numver就是得到的自增主键\n        System.out.println(number);\n    }\n}\n```\n\n\n## JPA框架\n\n官网：[https://spring.io/projects/spring-data-jpa](https://spring.io/projects/spring-data-jpa)\n\n而实现JPA规范的框架一般最常用的就是`Hibernate`\n\n所需依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n```xml\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n</dependency>\n```\n\n### 使用JPA快速上手\n\n我们通过注解形式，在属性上添加数据库映射关系\n```java\n@Data\n@Entity   //表示这个类是一个实体类\n@Table(name = \"account\")    //对应的数据库中表名称\npublic class Account {\n\n    @GeneratedValue(strategy = GenerationType.IDENTITY)   //生成策略，这里配置为自增\n    @Column(name = \"id\")    //对应表中id这一列\n    @Id     //此属性为主键\n    int id;\n\n    @Column(name = \"username\")   //对应表中username这一列\n    String username;\n\n    @Column(name = \"password\")   //对应表中password这一列\n    String password;\n}\n```\n\n修改配置文件，把日志打印打开\n```yml\nspring:\n  jpa:\n    #开启SQL语句执行日志信息\n    show-sql: true\n    hibernate:\n      #配置为检查数据库表结构，没有时会自动创建\n      ddl-auto: update\n```\n\n`ddl-auto`属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有以下几种：\n\n- `none`: 不执行任何操作，数据库表结构需要手动创建。\n- `create`: 框架在每次运行时都会删除所有表，并重新创建。\n- `create-drop`: 框架在每次运行时都会删除所有表，然后再创建，但在程序结束时会再次删除所有表。\n- `update`: 框架会检查数据库表结构，如果与实体类定义不匹配，则会做相应的修改，以保持它们的一致性。\n- `validate`: 框架会检查数据库表结构与实体类定义是否匹配，如果不匹配，则会抛出异常。\n\n创建一个Repository接口来继承 `JpaRepository` 泛型，第一个参数是实体类，第二个是主键的类型 \n```java\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Integer> {\n}\n```\n\n直接调用方法即可\n```java\n@Resource\nAccountRepository repository;\n\n@Test\nvoid contextLoads() {\n    Account account = new Account();\n    account.setUsername(\"小红\");\n    account.setPassword(\"1234567\");\n    System.out.println(repository.save(account).getId());   //使用save来快速插入数据，并且会返回插入的对象，如果存在自增ID，对象的自增id属性会自动被赋值，这就很方便了\n}\n```\n\n\n### 方法名称拼接自定义SQL\n\n超级帅，只需要在我们创建 `AccountRepository` 上通过方法名称的拼接来实现条件判断\n\n| 关键字               | 方法名称示例                                                    | 执行的语句                                                          |\n| ----------------- | --------------------------------------------------------- | -------------------------------------------------------------- |\n| Distinct          | findDistinctByLastnameAndFirstname                        | `select distinct … where x.lastname = ?1 and x.firstname = ?2` |\n| And               | findByLastnameAndFirstname                                | `… where x.lastname = ?1 and x.firstname = ?2`                 |\n| Or                | findByLastnameOrFirstname                                 | `… where x.lastname = ?1 or x.firstname = ?2`                  |\n| Is，Equals         | findByFirstname, findByFirstnameIs, findByFirstnameEquals | `… where x.firstname = ?1`                                     |\n| Between           | findByStartDateBetween                                    | `… where x.startDate between ?1 and ?2`                        |\n| LessThan          | findByAgeLessThan                                         | `… where x.age < ?1`                                           |\n| LessThanEqual     | findByAgeLessThanEqual                                    | `… where x.age <= ?1`                                          |\n| GreaterThan       | findByAgeGreaterThan                                      | `… where x.age > ?1`                                           |\n| GreaterThanEqual  | findByAgeGreaterThanEqual                                 | `… where x.age >= ?1`                                          |\n| After             | findByStartDateAfter                                      | `… where x.startDate > ?1`                                     |\n| Before            | findByStartDateBefore                                     | `… where x.startDate < ?1`                                     |\n| IsNull，Null       | findByAge(Is)Null                                         | `… where x.age is null`                                        |\n| IsNotNull，NotNull | findByAge(Is)NotNull                                      | `… where x.age not null`                                       |\n| Like              | findByFirstnameLike                                       | `… where x.firstname like ?1`                                  |\n| NotLike           | findByFirstnameNotLike                                    | `… where x.firstname not like ?1`                              |\n| StartingWith      | findByFirstnameStartingWith                               | `… where x.firstname like ?1（参数与附加%绑定）`                        |\n| EndingWith        | findByFirstnameEndingWith                                 | `… where x.firstname like ?1（参数与前缀%绑定）`                        |\n| Containing        | findByFirstnameContaining                                 | `… where x.firstname like ?1（参数绑定以%包装）`                        |\n| OrderBy           | findByAgeOrderByLastnameDesc                              | `… where x.age = ?1 order by x.lastname desc`                  |\n| Not               | findByLastnameNot                                         | `… where x.lastname <> ?1`                                     |\n| In                | findByAgeIn(Collection<Age> ages)                         | `… where x.age in ?1`                                          |\n| NotIn             | findByAgeNotIn(Collection<Age> ages)                      | `… where x.age not in ?1`                                      |\n| True              | findByActiveTrue                                          | `… where x.active = true`                                      |\n| False             | findByActiveFalse                                         | `… where x.active = false`                                     |\n| IgnoreCase        | findByFirstnameIgnoreCase                                 | `… where UPPER(x.firstname) = UPPER(?1)`                       |\n\n比如我们想要实现根据用户名模糊匹配查找用户、根据大于这个ID并且降序查询、通过用户名和ID查询、判断数据库中是否存在某个ID的用户：\n```java\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Integer> {\n    Account findAccountByUsernameLike(String str);\n\n    List<Account> findAccountsByIdGreaterThanOrderByIdDesc(int id);\n\n    Account findAccountByUsernameAndId(String username, int id);\n\n    boolean existsAccountById(int id);\n}\n```\n\n```java\n@SpringBootTest\nclass Demo2ApplicationTests {\n\n    @Resource\n    AccountRepository repository;\n\n    @Test\n    void contextLoads() {\n        System.out.println(repository.findAccountByUsernameLike(\"%es%\"));\n        System.out.println(\"======================================\");\n        System.out.println(repository.findAccountsByIdGreaterThanOrderByIdDesc(0));\n        System.out.println(\"======================================\");\n        System.out.println(repository.findAccountByUsernameAndId(\"test\", 1));\n        System.out.println(\"======================================\");\n        System.out.println(repository.existsAccountById(1));\n        System.out.println(repository.existsAccountById(10));\n        System.out.println(\"======================================\");\n    }\n}\n```\n\n注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：\n```sh\nCaused by: org.springframework.data.repository.query.QueryCreationException: Could not create query for public abstract  ...\n```\n\n### 关联查询\n\n#### 一对一\n\n```java\n@Data\n@Entity\n@Table(name = \"users_detail\")\npublic class AccountDetail {\n\n    @Column(name = \"id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Id\n    int id;\n\n    @Column(name = \"address\")\n    String address;\n\n    @Column(name = \"email\")\n    String email;\n\n    @Column(name = \"phone\")\n    String phone;\n\n    @Column(name = \"real_name\")\n    String realName;\n}\n```\n\n```java\n@Data\n@Entity\n@Table(name = \"users\")\npublic class Account {\n\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    @Id\n    int id;\n\n    @Column(name = \"username\")\n    String username;\n\n    @Column(name = \"password\")\n    String password;\n\n    @JoinColumn(name = \"detail_id\")   //指定存储外键的字段名称\n    @OneToOne    //声明为一对一关系\n    AccountDetail detail;\n}\n```\n\n\n添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据\n```java\n@JoinColumn(name = \"detail_id\")\n@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL) //设置关联操作为ALL\nAccountDetail detail;\n```\n\n- ALL：所有操作都进行关联操作\n- PERSIST：插入操作时才进行关联操作\n- REMOVE：删除操作时才进行关联操作\n- MERGE：修改操作时才进行关联操作\n\n```java\n@Test\nvoid addAccount(){\n    Account account = new Account();\n    account.setUsername(\"Nike\");\n    account.setPassword(\"123456\");\n    AccountDetail detail = new AccountDetail();\n    detail.setAddress(\"翻斗大街\");\n    detail.setPhone(\"1234567890\");\n    detail.setEmail(\"123456@qq.com\");\n    detail.setRealName(\"张三\");\n  \taccount.setDetail(detail);\n    account = repository.save(account);\n    System.out.println(\"插入时，自动生成的主键ID为：\"+account.getId()+\"，外键ID为：\"+account.getDetail().getId());\n}\n```\n\n#### 一对多\n\n```java\n@Data\n@Entity\n@Table(name = \"users_score\")   //成绩表，注意只存成绩，不存学科信息，学科信息id做外键\npublic class Score {\n\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    @Id\n    int id;\n\n    @OneToOne   //一对一对应到学科上\n    @JoinColumn(name = \"cid\")\n    Subject subject;\n\n    @Column(name = \"socre\")\n    double score;\n\n    @Column(name = \"uid\")\n    int uid;\n}\n```\n\n```java\n@Data\n@Entity\n@Table(name = \"subjects\")   //学科信息表\npublic class Subject {\n\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"cid\")\n    @Id\n    int cid;\n\n    @Column(name = \"name\")\n    String name;\n\n    @Column(name = \"teacher\")\n    String teacher;\n\n    @Column(name = \"time\")\n    int time;\n}\n```\n\n```java\n@Data\n@Entity\n@Table(name = \"account\")\npublic class Account {\n    @Id\n    @Column(name = \"id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    Integer id;\n\n    @Column(name = \"username\")\n    String username;\n\n    @Column(name = \"password\")\n    String password;\n\n    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n    @JoinColumn(name = \"detail_id\")\n    AccountDetail detail;\n\n    @JoinColumn(name = \"uid\")  //注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键\n    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)   //在移除Account时，一并移除所有的成绩信息，依然使用懒加载\n    List<Score> scoreList;\n}\n```\n\n#### 多对多\n\n```java\n@ManyToMany(fetch = FetchType.LAZY)   //多对多场景\n@JoinTable(name = \"teach_relation\",     //多对多中间关联表\n        joinColumns = @JoinColumn(name = \"cid\"),    //当前实体主键在关联表中的字段名称\n        inverseJoinColumns = @JoinColumn(name = \"tid\")   //教师实体主键在关联表中的字段名称\n)\nList<Teacher> teacher;\n```\n\n### JPQL自定义SQL语句\n\n```java\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Integer> {\n\n    @Transactional    //DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下\n    @Modifying     //表示这是一个DML操作\n    @Query(\"update Account set password = ?2 where id = ?1\") //这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数\n    int updatePasswordById(int id, String newPassword);\n}\n```\n\n或者\n\n```java\n@Transactional\n@Modifying\n@Query(value = \"update users set password = :pwd where username = :name\", nativeQuery = true) //使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。\nint updatePasswordByUsername(@Param(\"name\") String username,   //我们可以使用@Param指定名称\n                             @Param(\"pwd\") String newPassword);\n```\n\n## MybatisPlus框架\n\n所需依赖\n```xml\n<dependency>  \n    <groupId>com.baomidou</groupId>  \n    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>  \n    <version>3.5.10.1</version>  \n</dependency>  \n<dependency>  \n    <groupId>com.mysql</groupId>  \n    <artifactId>mysql-connector-j</artifactId>  \n    <version>9.1.0</version>  \n</dependency>\n<dependency>  \n    <groupId>com.baomidou</groupId>  \n    <artifactId>mybatis-plus-extension</artifactId>  \n    <version>3.5.5</version>  \n</dependency>\n```\n\n数据源\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/test\n    username: root\n    password: Abc123\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n开启日志打印\n```yml\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n### 快速上手\n\n实体类，可以直接映射到数据库中的表\n```java\n@Data\n@TableName(\"user\")  //对应的表名\npublic class User {\n    @TableId(type = IdType.AUTO)   //对应的主键\n    int id;\n    @TableField(\"name\")   //对应的字段\n    String name;\n    @TableField(\"email\")\n    String email;\n    @TableField(\"password\")\n    String password;\n}\n```\n\n跟 mybatis 一样，需要一个 mapper\n```java\n@Mapper\npublic interface UserMapper extends BaseMapper<User> {\n  \t//使用方式与JPA极其相似，同样是继承一个基础的模版Mapper\n  \t//这个模版里面提供了预设的大量方法直接使用，跟JPA如出一辙\n}\n```\n\n```java\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Resource\n    UserMapper mapper;\n\n    @Test\n    void contextLoads() {\n        System.out.println(mapper.selectById(1));  //同样可以直接selectById，非常快速方便\n    }\n}\n```\n\n\n### 条件构造器\n\n```java\n@Test\nvoid contextLoads() {\n    QueryWrapper<User> wrapper = new QueryWrapper<>();    //复杂查询可以使用QueryWrapper来完成\n  \twrapper\n            .select(\"id\", \"name\", \"email\", \"password\")    //可以自定义选择哪些字段\n            .ge(\"id\", 2)     \t\t\t//选择判断id大于等于1的所有数据\n            .orderByDesc(\"id\");   //根据id字段进行降序排序\n    System.out.println(mapper.selectList(wrapper));   //Mapper同样支持使用QueryWrapper进行查询\n}\n```\n等同于\n```mysql\nselect id,name,email,password from user where id >= 2 order by id desc\n```\n\n\n支持批处理操作，我们可以一次性删除多个指定ID的用户：\n```java\n    @Test\n    void contextLoads() {\n        mapper.deleteByIds(List.of(1, 3));\n    }\n```\n\n更新：\n```java\n@Test\nvoid contextLoads() {\n    UpdateWrapper<User> wrapper = new UpdateWrapper<>();\n    wrapper\n            .set(\"name\", \"lbw\")\n            .eq(\"id\", 1);\n    System.out.println(mapper.update(null, wrapper));\n}\n```\n#### 分页查询\n\n先配置\n```java\n@Configuration\npublic class MybatisConfiguration {\n    @Bean\n    public MybatisPlusInterceptor paginationInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n      \t//添加分页拦截器到MybatisPlusInterceptor中\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n}\n```\n\n使用\n```java\n@Test\nvoid contextLoads() {\n    //这里我们将用户表分2页，并获取第一页的数据\n    Page<User> page = mapper.selectPage(Page.of(1, 2), Wrappers.emptyWrapper());\n    System.out.println(page.getRecords());   //获取分页之后的数据\n}\n```\n\n#### Lambda表达式\n\n```java\n@Test\nvoid contextLoads() {\n        LambdaQueryWrapper<User> wrapper = Wrappers\n                .<User>lambdaQuery()\n                .eq(User::getId, 2)   //比如我们需要选择id为2的用户，前面传入方法引用，后面比的值\n                .select(User::getName, User::getId);   //比如我们只需要选择name和id，那就传入对应的get方法引用\n        System.out.println(mapper.selectOne(wrapper));\n}\n```\n\n### 代码生成器\n\n依赖\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-generator</artifactId>\n    <version>3.5.3.1</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.velocity</groupId>\n    <artifactId>velocity-engine-core</artifactId>\n    <version>2.3</version>\n</dependency>\n<dependency>  \n    <groupId>org.springframework.boot</groupId>  \n    <artifactId>spring-boot-starter-web</artifactId>  \n</dependency>\n```\n\n```java\npackage com.example;\n\nimport com.baomidou.mybatisplus.generator.FastAutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\nimport jakarta.annotation.Resource;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.sql.DataSource;\n\n@SpringBootTest\nclass Demo4ApplicationTests {\n\n    @Resource\n    DataSource DataSource;\n\n    @Test\n    void contextLoads() {\n        FastAutoGenerator\n                .create(new DataSourceConfig.Builder(DataSource))\n                .globalConfig(builder -> {\n                    builder.author(\"hs\");\n                    builder.commentDate(\"2024-01-01\");\n                    builder.outputDir(\"src/main/java\");\n                })\n                .packageConfig(builder -> builder.parent(\"com.example\"))\n                .strategyConfig(builder -> {\n                    builder\n                            .mapperBuilder()\n                            .mapperAnnotation(Mapper.class)\n                            .build();\n                })\n                .execute();\n    }\n}\n\n```\n\n# 前后端分离\n\n## 基于 session 的分离\n\n前后端分离，需要前端与后端各占一个服务器\n\n### 环境搭建\n\n- **创建前端文件**\n\n勾选上spring web\n![](p9.png)\n\n在resources里创建一个web目录，把所有web相关的文件塞进去，然后修改配置文件\n```yml\nspring:\n  web:\n    resources:\n      static-locations: classpath:/web\n```\n\n- **创建后端文件**\n\n把右下角看到的依赖都勾选上\n![](p10.png)\n\n后端文件的resources中只需要保留一个配置文件即可，因为前端已经占用了8080端口，我们这里需要改成其他端口\n\n```yml\nserver:  \n  port: 8081  \nspring:  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/test  \n    username: root  \n    password: Abc123  \n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n### 实现登录授权和跨域处理\n\n还是跟之前security一样\n```java\n@Configuration\npublic class SecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n                .authorizeHttpRequests(conf -> {\n                    conf.anyRequest().authenticated();\n                })\n                .formLogin(conf -> {\n                  \t//一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口\n                    conf.loginProcessingUrl(\"/api/auth/login\");\n                    conf.permitAll();\n                })\n                .csrf(AbstractHttpConfigurer::disable)\n                .build();\n    }\n}\n```\n\n手动设置SuccessHandler和FailureHandler来实现让SpringSecurity在登录成功之后返回一个JSON数据给前端而不是默认的重定向：\n```java\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\treturn http\n\t\t\t...\n\t\t\t.formLogin(conf -> {\n\t\t\t\tconf.loginProcessingUrl(\"/api/auth/login\");\n\t\t\t\t//使用自定义的成功失败处理器\n\t\t\t\tconf.failureHandler(this::onAuthenticationFailure);\n\t\t\t\tconf.successHandler(this::onAuthenticationSuccess);\n\t\t\t\tconf.permitAll();\n\t\t\t})\n\t\t\t...\n}\n\n\t//自定义成功失败处理器\nvoid onAuthenticationFailure(HttpServletRequest request,\n\t\t\t\t\t\t\t HttpServletResponse response,\n\t\t\t\t\t\t\t AuthenticationException exception) {\n\n}\n\nvoid onAuthenticationSuccess(HttpServletRequest request, \n\t\t\t\t\t\t\t HttpServletResponse response, \n\t\t\t\t\t\t\t Authentication authentication) {\n\t\n}\n```\n\nREST应答一般使用的格式为JSON，这里我们创建一个实体类来装载响应数据，两种写法：\n- 1、基本写法：\n```java\n@Data\npublic class RestBean<T> {\n    int code;\n    T data;\n    String message;\n\n    private RestBean(int code, T data, String message) {\n        this.code = code;\n        this.data = data;\n        this.message = message;\n    }\n\n    public static <T> RestBean<T> success(T data) {\n        return new RestBean<>(200, data, \"success\");\n    }\n\n    public static <T> RestBean<T> failure(int code, String message) {\n        return new RestBean<>(code, null, message);\n    }\n\n    public String asJsonString() {\n        return JSONObject\n                .from(this, JSONWriter.Feature.WriteNulls)\n                .toString();\n    }\n}\n```\n或者\n- 2、JDK的新特性：\n```java\npublic record RestBean<T> (int code, T data, String message) {\n\t\t//写几个工具方法，用于快速创建RestBean对象\n    public static <T> RestBean<T> success(T data){\n        return new RestBean<>(200, data, \"请求成功\");\n    }\n\n    public static <T> RestBean<T> failure(int code, String message){\n        return new RestBean<>(code, null, message);\n    }\n\n    public static <T> RestBean<T> failure(int code){\n        return failure(code, \"请求失败\");\n    }\n\t\t//将当前对象转换为JSON格式的字符串用于返回\n    public String asJsonString() {\n        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);\n    }\n}\n```\n\n把handler补充完\n```java\nvoid onAuthenticationFailure(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 AuthenticationException exception) throws IOException {\n        response.setContentType(\"application/json;charset=utf-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());\n    }\n\n    void onAuthenticationSuccess(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 Authentication authentication) throws IOException {\n        response.setContentType(\"application/json;charset=utf-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(RestBean.success(authentication.getName()).asJsonString());\n    }\n```\n\n我们在发起登录请求时，前端得到了一个跨域请求错误，这是因为我们前端的站点和后端站点不一致导致的，我们只需要告诉浏览器那些站点发出的请求是安全的即可\n```java\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n                ...\n                .cors(conf -> {\n                    CorsConfiguration cors = new CorsConfiguration();\n                  \t//添加前端站点地址，这样就可以告诉浏览器信任了\n                  \tcors.addAllowedOrigin(\"http://localhost:8080\");\n                    //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(\"*\");\n                  \t//但是这样并不安全，我们应该只许可给我们信任的站点\n                    cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie\n                    cors.addAllowedHeader(\"*\");   //其他的也可以配置，为了方便这里就 * 了\n                    cors.addAllowedMethod(\"*\");\n                    cors.addExposedHeader(\"*\");\n                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n                    source.registerCorsConfiguration(\"/**\", cors);  //直接针对于所有地址生效\n                    conf.configurationSource(source);\n                })\n                ...\n                .build();\n    }\n```\n\n`SecurityConfiguration` 最终代码\n```java\npackage com.example.config;\n\nimport com.example.entity.RestBean;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@Configuration\npublic class SecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n                .authorizeHttpRequests(conf -> {\n                    conf.anyRequest().authenticated();\n                })\n                .formLogin(conf -> {\n                    //一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口\n                    conf.loginProcessingUrl(\"/api/auth/login\");\n                    conf.successHandler(this::onAuthenticationSuccess);\n                    conf.failureHandler(this::onAuthenticationFailure);\n                    conf.permitAll();\n                })\n                .csrf(AbstractHttpConfigurer::disable)\n                .cors(conf -> {\n                    CorsConfiguration cors = new CorsConfiguration();\n                    //添加前端站点地址，这样就可以告诉浏览器信任了\n                    cors.addAllowedOrigin(\"http://localhost:8080\");\n                    //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(\"*\");\n                    //但是这样并不安全，我们应该只许可给我们信任的站点\n                    cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie\n                    cors.addAllowedHeader(\"*\");   //其他的也可以配置，为了方便这里就 * 了\n                    cors.addAllowedMethod(\"*\");\n                    cors.addExposedHeader(\"*\");\n                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n                    source.registerCorsConfiguration(\"/**\", cors);  //直接针对于所有地址生效\n                    conf.configurationSource(source);\n                })\n                .build();\n    }\n    //自定义成功失败处理器\n    void onAuthenticationFailure(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 AuthenticationException exception) throws IOException {\n        response.setContentType(\"application/json;charset=utf-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());\n    }\n\n    void onAuthenticationSuccess(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 Authentication authentication) throws IOException {\n        response.setContentType(\"application/json;charset=utf-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(RestBean.success(authentication.getName()).asJsonString());\n    }\n}\n```\n\n实体类最终代码\n```java\npackage com.example.entity;\n\nimport com.alibaba.fastjson2.JSONObject;\nimport com.alibaba.fastjson2.JSONWriter;\n\npublic record RestBean<T> (int code, T data, String message) {\n    //写几个工具方法，用于快速创建RestBean对象\n    public static <T> RestBean<T> success(T data){\n        return new RestBean<>(200, data, \"请求成功\");\n    }\n\n    public static <T> RestBean<T> failure(int code, String message){\n        return new RestBean<>(code, null, message);\n    }\n\n    public static <T> RestBean<T> failure(int code){\n        return failure(code, \"请求失败\");\n    }\n    //将当前对象转换为JSON格式的字符串用于返回\n    public String asJsonString() {\n        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);\n    }\n}\n```\n\n\n## JWT\n\n一个JWT令牌由3部分组成:标头(Header)、有效载荷(Payload)和签名(Signature)。\n\n依赖：\n```xml\n<dependency>\n     <groupId>com.auth0</groupId>\n     <artifactId>java-jwt</artifactId>\n     <version>4.3.0</version>\n</dependency>\n```\n\n### 快速体验\n\n生成一个JWT令牌\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String jwtKey = \"abcdefghijklmn\";                 //使用一个JWT秘钥进行加密\n        Algorithm algorithm = Algorithm.HMAC256(jwtKey);  //创建HMAC256加密算法对象\n        String jwtToken = JWT.create()\n                .withClaim(\"id\", 1)   //向令牌中塞入自定义的数据\n                .withClaim(\"name\", \"lbw\")\n                .withClaim(\"role\", \"nb\")\n                .withExpiresAt(new Date(2024, Calendar.FEBRUARY, 1))  //JWT令牌的失效时间\n                .withIssuedAt(new Date())   //JWT令牌的签发时间\n                .sign(algorithm);    //使用上面的加密算法进行加密，完成签名\n        System.out.println(jwtToken);   //得到最终的JWT令牌\n    }\n}\n```\n\n得到的令牌为：\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTc0MDA2OTA0N30.1IJCxw3HUmOy2qbEw--6Qnz5fub6dbnIv-u2GmZQam0\n```\n\n还原代码：\n```java\npublic static void main(String[] args) {\n        String jwtToken = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s\";\n        String[] split = jwtToken.split(\"\\\\.\");\n        for (int i = 0; i < split.length - 1; i++) {\n            String s = split[i];\n            byte[] decode = Base64.getDecoder().decode(s);\n            System.out.println(new String(decode));\n        }\n}\n```\n\n解码后：\n```\n{\"typ\":\"JWT\",\"alg\":\"HS256\"}\n{\"role\":\"nb\",\"name\":\"lbw\",\"id\":1,\"exp\":61664860800,\"iat\":1740069366}\n```\n\n### SpringSecurity 实现 JWT 校验\n\n首先先创建处理JWT令牌的工具类\n```java\npublic class JwtUtils {\n  \t//Jwt秘钥\n    private static final String key = \"abcdefghijklmn\";\n\n  \t//根据用户信息创建Jwt令牌\n    public static String createJwt(UserDetails user){\n        Algorithm algorithm = Algorithm.HMAC256(key);\n        Calendar calendar = Calendar.getInstance();\n        Date now = calendar.getTime();\n        calendar.add(Calendar.SECOND, 3600 * 24 * 7);\n        return JWT.create()\n                .withClaim(\"name\", user.getUsername())  //配置JWT自定义信息\n                .withClaim(\"authorities\", user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())\n                .withExpiresAt(calendar.getTime())  //设置过期时间\n                .withIssuedAt(now)    //设置创建创建时间\n                .sign(algorithm);   //最终签名\n    }\n\n  \t//根据Jwt验证并解析用户信息\n    public static UserDetails resolveJwt(String token){\n        Algorithm algorithm = Algorithm.HMAC256(key);\n        JWTVerifier jwtVerifier = JWT.require(algorithm).build();\n        try {\n            DecodedJWT verify = jwtVerifier.verify(token);  //对JWT令牌进行验证，看看是否被修改\n            Map<String, Claim> claims = verify.getClaims();  //获取令牌中内容\n            if(new Date().after(claims.get(\"exp\").asDate())) //如果是过期令牌则返回null\n                return null;\n            else\n              \t//重新组装为UserDetails对象，包括用户名、授权信息等\n                return User\n                        .withUsername(claims.get(\"name\").asString())\n                        .password(\"\")\n                        .authorities(claims.get(\"authorities\").asArray(String.class))\n                        .build();\n        } catch (JWTVerificationException e) {\n            return null;\n        }\n    }\n}\n```\n\n然后再编写 JwtAuthenticationFilter\n```java\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {  \n//继承OncePerRequestFilter表示每次请求过滤一次，用于快速编写JWT校验规则\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n      \t//首先从Header中取出JWT\n        String authorization = request.getHeader(\"Authorization\");\n      \t//判断是否包含JWT且格式正确\n        if (authorization != null && authorization.startsWith(\"Bearer \")) {\n            String token = authorization.substring(7);\t\n          \t//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题\n            UserDetails user = JwtUtils.resolveJwt(token);\n            if(user != null) {\n              \t//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致\n              \t//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去\n                UsernamePasswordAuthenticationToken authentication =\n                        new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());\n                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n              \t//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证\n                SecurityContextHolder.getContext().setAuthentication(authentication);\n            }\n        }\n      \t//最后放行，继续下一个过滤器\n      \t//可能各位小伙伴会好奇，要是没验证成功不是应该拦截吗？这个其实没有关系的\n      \t//因为如果没有验证失败上面是不会给SecurityContext设置Authentication的，后面直接就被拦截掉了\n      \t//而且有可能用户发起的是用户名密码登录请求，这种情况也要放行的，不然怎么登录，所以说直接放行就好\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n最后再修改 `SecurityConfiguration`\n```java\npackage com.example.config;  \n  \nimport com.example.entity.RestBean;  \nimport com.example.filter.JwtAuthenticationFilter;  \nimport com.example.util.JwtUtils;  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.access.AccessDeniedException;  \nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;  \nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;  \nimport org.springframework.security.config.http.SessionCreationPolicy;  \nimport org.springframework.security.core.Authentication;  \nimport org.springframework.security.core.AuthenticationException;  \nimport org.springframework.security.core.userdetails.User;  \nimport org.springframework.security.web.SecurityFilterChain;  \nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  \nimport org.springframework.web.cors.CorsConfiguration;  \nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;  \n  \nimport java.io.IOException;  \nimport java.io.PrintWriter;  \n  \n@Configuration  \npublic class SecurityConfiguration {  \n  \n    @Bean  \n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {  \n        return http  \n                .authorizeHttpRequests(conf -> {  \n                    conf.anyRequest().authenticated();  \n                })  \n                .formLogin(conf -> {  \n                    //一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口  \n                    conf.loginProcessingUrl(\"/api/auth/login\");  \n                    conf.successHandler(this::handleProcess);  \n                    conf.failureHandler(this::handleProcess);  \n                    conf.permitAll();  \n                })  \n                .csrf(AbstractHttpConfigurer::disable)  \n                .cors(conf -> {  \n                    CorsConfiguration cors = new CorsConfiguration();  \n                    //添加前端站点地址，这样就可以告诉浏览器信任了  \n                    cors.addAllowedOrigin(\"http://localhost:8080\");  \n                    //虽然也可以像这样允许所有 cors.addAllowedOriginPattern(\"*\");                    //但是这样并不安全，我们应该只许可给我们信任的站点  \n                    cors.setAllowCredentials(true);  //允许跨域请求中携带Cookie  \n                    cors.addAllowedHeader(\"*\");   //其他的也可以配置，为了方便这里就 * 了  \n                    cors.addAllowedMethod(\"*\");  \n                    cors.addExposedHeader(\"*\");  \n                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();  \n                    source.registerCorsConfiguration(\"/**\", cors);  //直接针对于所有地址生效  \n                    conf.configurationSource(source);  \n                })  \n                .exceptionHandling(conf -> {  \n                    //配置授权相关异常处理器  \n                    conf.accessDeniedHandler(this::handleProcess);  \n                    //配置验证相关异常的处理器  \n                    conf.authenticationEntryPoint(this::onAuthenticationFailure);  \n                })  \n                .sessionManagement(conf -> conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS))  \n                .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)  \n                .build();  \n    }  \n    //自定义成功失败处理器  \n    void onAuthenticationFailure(HttpServletRequest request,  \n                                 HttpServletResponse response,  \n                                 AuthenticationException exception) throws IOException {  \n        response.setContentType(\"application/json;charset=utf-8\");  \n        PrintWriter writer = response.getWriter();  \n        writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());  \n    }  \n  \n    void onAuthenticationSuccess(HttpServletRequest request,  \n                                 HttpServletResponse response,  \n                                 Authentication authentication) throws IOException {  \n        response.setContentType(\"application/json;charset=utf-8\");  \n        PrintWriter writer = response.getWriter();  \n        writer.write(RestBean.success(authentication.getName()).asJsonString());  \n    }  \n  \n    private void handleProcess(HttpServletRequest request,  \n                               HttpServletResponse response,  \n                               Object exceptionOrAuthentication) throws IOException {  \n        response.setContentType(\"application/json;charset=utf-8\");  \n        PrintWriter writer = response.getWriter();  \n        if(exceptionOrAuthentication instanceof AccessDeniedException exception) {  \n            writer.write(RestBean.failure(403, exception.getMessage()).asJsonString());  \n        } else if(exceptionOrAuthentication instanceof Exception exception) {  \n            writer.write(RestBean.failure(401, exception.getMessage()).asJsonString());  \n        }else if(exceptionOrAuthentication instanceof Authentication authentication){  \n            //不过这里需要注意，在登录成功的时候需要返回我们生成的JWT令牌，这样客户端下次访问就可以携带这个令牌了，令牌过期之后就需要重新登录才可以  \n            writer.write(RestBean.success(JwtUtils.createJwt((User) authentication.getPrincipal())).asJsonString());  \n        }  \n    }  \n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"数据结构与算法","url":"/2025/01/24/articles/MarsCode学习笔记/7.数据结构与算法/数据结构与算法/","content":"# 排序\n\n## Insertion Sort 插入排序\n\n![](MarsCode学习笔记/7.数据结构与算法/p1.png)\n\n将元素不断插入已经排序好的 array 中\n- 起始只有一个元素5，其本身是一个有序序列\n- 后续元素插入有序序列中，即不断交换，直到找到第一个比其小的元素\n\n| Best | Avg    | Worst  |\n| ---- | ------ | ------ |\n| O(n) | O(n^2) | O(n^2) |\n\n缺点\n- 平均和最坏情况的时间复杂度高达 O(n^2)\n\n优点\n- 最好情况时间复杂度为O(n)\n\n\n总结：插入排序平均和最坏情况时间复杂度都是 O(n^2)\n\n## Quick Sort 快速排序\n\n![](p2.gif)\n\n分治思想，不断分割序列直到序列整体有序\n- 选定一个 pivot (轴点)\n- 使用 pivot 分割序列，分成元素比 pivot 大 和元素比 pivot 小两个序列\n\n| Best        | Avg         | Worst  |\n| ----------- | ----------- | ------ |\n| O(n * logn) | O(n * logn) | O(n^2) |\n\n缺点\n- 平均和最坏情况的时间复杂度高达 O(n * logn)\n\n优点\n- 最好情况时间复杂度为O(n^2)\n\n总结：快速排序整体性能处于中间层次\n\n## Heap Sort 堆排序\n\n![](p3.gif)\n\n大顶堆和小顶堆\n- 小顶堆是根节点比子节点小\n- 大顶堆是根节点比子节点大\n\n| Best        | Avg         | Worst       |\n| ----------- | ----------- | ----------- |\n| O(n * logn) | O(n * logn) | O(n * logn) |\n总结：众生平等堆排序性能稳定\n\n## 实际场景 benchmark\n\n根据序列元素排列情况划分\n- 完全随机的情况(random)\n- 有序/逆序的情况 (sorted/reverse)\n- 元素重复度较高的情况(mod8)\n在此基础上，还需要根据序列长度的划分(16/128/1024)\n\n### random\n![](p4.png)\n\n- 插入排序在短序列中速度最快\n- 快速排序在其他情况中速度最快\n- 堆排序速度于最快算法差距不大\n\n### sorted\n![](p5.png)\n\n- 插入排序在序列已经有序的情况下最快\n\n总结：\n- 所有短序列和元素有序情况下，插入排序性能最好\n- 在大部分的情况下，快速排序有较好的综合性能\n- 几乎在任何情况下，堆排序的表现都比较稳定\n\n\n# pdqsort (pattern-defeating-quicksort)\n\n是一种不稳定的混合排序算法，它的不同版本被应用在 C++ BOOST、Rust 以及 Go 1.19 中。它对常见的序列类型做了特殊的优化，使得在不同条件下都拥有不错的性能\n\n结合三种排序方法的优点\n- 对于短序列(小于一定长度)，我们使用插入排序\n- 其他情况，使用快速排序来保认整体性能\n- 当快速排序表现不佳时，使用堆排序来保证最坏情况下时间复杂度仍然为 O(n*logn)\n\n当最终 pivot 的位置离序列两端很接近时(距离小于 length/8)判定其表现不佳，当这种情况的次数达到 limit(即 bits.Len(length)时，切换到堆排序\n\n### pivot的选择\n\n- 使用第一个元素作为pivot（最简单的方案）\n实现简单，但是往往效果不好，如果在sorted情况下性能会很差\n- 遍历数组，寻找真正的中位数\n遍历比对代价很高，性能不好\n\n优化-Pivot 的选择\n- 短序列(<=8)，选择固定元素\n- 中序列(<=50)，采样三个元素，median of three\n- 长序列(>50)，:采样九个元素，median of medians\n\n同时Pivot 的采样方式使得我们有探知序列当前状态的能力\n- 如果采样的元素都是逆序排序，那我们可能推出序列已经逆序，我们只需要翻转整个序列\n- 如果采样的元素都是顺序排序，那我们可能推出序列已经顺序，在前面我们已经探究出插入排序对有序序列效率更高，在这里就使用插入排序\n\n注：**插入排序实际使用 partiallnsertionSort，即有限制次数的插入排序**，因为插入排序在一般序列性能表现是比较差的，我们只是认为可能有顺序的可能，不是真正的有序，用partiallnsertionSort可以限制插入的次数\n\n如果两次 partition 生成的 pivot 相同，即 partition 进行了无效分割,此时认为 pivot 的值为重复元素\n\n优化-重复元素较多的情况(partitonEqual)\n当检测到此时的 pivot 和上次相同时(发生在 leftSubArray)，使用partitionEqual 将重复元素排列在一起，减少重复元素对于 pivot 选择的干扰\n\n| Best | Avg         | Worst       |\n| ---- | ----------- | ----------- |\n| O(n) | O(n * logn) | O(n * logn) |\n\n![](p7.png)\n","tags":["字节青训营"]},{"title":"代码优化","url":"/2025/01/23/articles/MarsCode学习笔记/6.优化代码/代码优化/","content":"\n\n# 高质量编程\n\n编写的代码能够达到正确可靠、简洁清晰的目标可称为高质量代码\n- 各种边界条件是否考虑完备\n- 异常情况处理，稳定性保证\n- 易读易维护\n\n## 编程原则\n\n简单性\n- 消除“多余的复杂性”，以简单清晰的逻辑编写代码 \n- 不理解的代码无法修复改进\n可读性\n- 代码是写给人看的，而不是机器\n- 编写可维护代码的第一步是确保代码可读\n生产力\n- 团队整体工作效率非常重要\n\n## 编写规范\n\n### 注释\n\n公共符号始终要注释\n- 包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释\n- 任何既不明显也不简短的公共功能必须予以注释\n- 无论长度或复杂程度如何对库中的任何函数都必须进行注释\n\n注释应该做的：\n- 注释应该解释代码作用\n- 注释应该解释代码如何做的\n- 注释应该解释代码实现的原因\n- 注释应该解释代码什么情况会出错\n\n### 命名规范\n\n#### 变量名\n\n- 简洁胜于冗长\n- 缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写\n\t- 例如使用 ServeHTTP 而不是 ServeHttp\n\t- 使用 XMLHTTPRequest 或者 xmlHTTPRequest\n- 变量距离其被使用的地方越远，则需要携带越多的上下文信息\n\t- 全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义\n\n例如：\n```go\n// Bad\nfor index := 0; index < len(s); index++{\n\t//do something...\n}\n\n// Good\nfor i := 0; i < len(s); i++{\n\t//do something...\n}\n```\ni 和 index 的作用域范围仅限于 for 循环内部时，index 的额外冗长几乎没有增加对程序的理解\n\n```go\n// Good\nfunc (c *Client) send(req *Request, deadline time.Time)\n\n// Bad\nfunc (c *Client) send(req *Request, t time.Time)\n```\n将 deadline 替换成t 降低了变量名的信息量，t 常代指任意时间\ndeadline 指截止时间，有特定的含义\n\n#### 函数名\n\n- 函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的\n- 函数名尽量简短\n- 当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义\n- 当名为 foo 的包某个函数返回类型 T时(T 并不是 Foo)，可以在函数名中加入类型信息\n\n例如：\n在 http 包中创建服务器的函数\n```go\n// Good\nfunc Server(I net.Listener, handler Handler) error\n\n// Bad\nfunc ServerHTTP(I net.Listener, handler Handler) error\n```\n因为我们是在 http 包下创建的函数，如果其他包中调用这个函数那么是 http.函数名，http就没必要出现在函数名中了\n\n#### package\n\n- 只由小写字母组成。不包含大写字母和下划线等字符\n- 简短并包含一定的上下文信息。例如 schema、task 等\n- 不要与标准库同名。例如不要使用 sync 或者 strings\n\n以下规则尽量满足，以标准库包名为例\n- 不使用常用变量名作为包名。例如使用 bufio 而不是 buf\n- 使用单数而不是复数。例如使用 encoding 而不是 encodings\n- 谨慎地使用缩写。例如使用 fmt 在不破坏上下文的情况下比 format 更加简短\n\n### 控制流程\n\n避免嵌套，保持正常流程清晰\n\n```go\n// Bad\nif foo {\n\treturn x\n}else {\n\treturn nil\n}\n\n// Good\nif foo {\n\treturn x\n}\nreturn nil\n```\n如果两个分支中都包含return语句，则可以去除冗余的else\n\n尽量保持正常代码路径为最小缩进\n- 优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套\n\n```go\n// Bad\nfunc OneFunc() err {\n\terr := doSomething()\n\tif err == nil {\n\t\terr := doSomething()\n\t\tif err == nil{\n\t\t\treturn nil // normal case\n\t\t}\n\t\treturn err\n\t}\n\treturn err\n}\n\n// Good\nfunc OneFunc() err {\n\tif err := doSomething(); err != nil {\n\t\treturn err\n\t}\n\tif err := doSomething(); err != nil {\n\t\treturn err\n\t}\n\treturn nil // normal case\n}\n```\n- 最常见的正常流程的路径被嵌套在两个 if 条件内\n- 成功的退出条件是 return nil，必须仔细匹配大括号来发现函数最后一行返回一个错误，需要追溯到匹配的左括号，才能了解何时会触发错误\n- 如果后续正常流程需要增加一步操作，调用新的函数，则又会增加一层嵌套\n\n### 错误和异常处理\n\n#### 简单错误\n\n- 简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误\n- 优先使用 errors.New 来创建匿名变量来直接表示简单错误\n- 如果有格式化的需求，使用 fmt.Errorf\n\n#### 错误的 Wrap 和 Unwrap\n\n错误的 Wrap 实际上是提供了一个 error 嵌套另一个error 的能力，从而生成一个 error 的跟踪链\n在 fmt.Errorf 中使用: %w 关键字来将一个错误关联至错误链中\n\n#### 判断错误\n\n判定一个错误是否为特定错误，使用 errors.ls\n- 不同于使用 `==`，使用该方法可以判定错误链上的所有错误是否含有特定的错误\n\n在错误链上获取特定种类的错误，使用errors.As\n\n#### panic\n\n注意在Go语言中，recover只在defer调用的函数中有效，并且defer要在panic之前先注册，否则不能捕获异常\npanic相当于直接 throw 一个异常来终止程序运行，**当panic被捕获到后，被注册的函数将获得程序控制权**\n\n- 不建议在业务代码中使用 panic\n- 调用函数不包含 recover 会造成程序崩溃\n- 若问题可以被屏蔽或解决，建议使用error 代替 panic\n- 当程序启动阶段发生不可逆转的错误时可以在 init 或 main 函数中使用 panic\n\n#### recover\n\n- recover 只能在被 defer 的函数中使用\n- 嵌套无法生效\n- 只在当前 goroutine 生效\n- defer 的语句是后进先出\n\n如果需要更多的上下文信息，可以recover 后在 log 中记录当前的调用栈\n\n## 优化性能\n\n- 性能优化的前提是满足正确可靠、简洁清晰等质量因素\n- 性能优化是综合评估，有时候时间效率和空间效率可能对立\n- 针对 Go 语言特性，介绍 Go 相关的性能优化建议\n\n### Benchmark\n\nGo 语言提供了支持基准性能测试的 benchmark 工具\n\n`go test -bench=. -benchmem`\n\n![](MarsCode学习笔记/6.优化代码/p1.png)\n\n\n### Slice 预分配内存\n\n```go\n// Bad\nfunc NoPreAlloc(size int) {\n\tdata := make([]int, 0)\n\tfor k := 0; k < size; k++ {\n\t\tdata = append(data, k)\n\t}\n}\n\n// Good\nfunc NoPreAlloc(size int) {\n\tdata := make([]int, 0, size)\n\tfor k := 0; k < size; k++ {\n\t\tdata = append(data, k)\n\t}\n}\n```\n\n- 切片本质是一个数组片段的描述\n\t- 包括数组指针\n\t- 片段的长度\n\t- 片段的容量(不改变内存分配情况下的最大长度)\n- 切片操作并不复制切片指向的元素\n- 创建一个新的切片会复用原来切片的底层数组 \n\n![](p2.png)\n\n- 在已有切片基础上创建切片，不会创建新的底层数组场景\n\t- 原切片较大，代码在原切片基础上新建小切片\n\t- 原底层数组在内存中有引用，得不到释放\n- 可使用 copy 替代 re-slice\n- map 也是一样，不断向 map 中添加元素的操作会触发 map 的扩容，提前分配好空间可以减少内存拷贝和 Rehash 的消耗\n\n### 字符串处理\n\n常见的字符串拼接方法：strings.Builder\n\n```go\n// Bad\nfunc Plus(n int, str string) string {\n\ts := \"\"\n\tfor i := 0; i < n; i++ {\n\t\ts += str\n\t}\n\treturn s\n}\n\n// Good\nfunc Plus(n int, str string) string {\n\tvar builder strings.Builder\n\tfor i := 0; i < n; i++ {\n\t\tbuilder.WriteString(str)\n\t}\n\treturn builder.String()\n}\n```\n\n使用 strings.Builder\n- 使用+拼接性能最差，strings.Builder，bytes.Buffer 相近，strings.Buffer 更快\n\n分析\n- 字符串在 Go 语言中是不可变类型，占用内存大小是固定的\n- 使用 +每次都会重新分配内存\n- strings.Builder，bytes.Buffer 底层都是 []byte 数组\n- 内存扩容策略,不需要每次拼接重新分配内存","tags":["字节青训营"]},{"title":"Go语言","url":"/2025/01/21/articles/MarsCode学习笔记/5.Go/Go语言/","content":"# 基础语法\n\n- 变量\n\t- var 变量名 = 值\n\t- int（数据类型） 变量名 = 值\n\t- 变量名 := 值\n- 常量\n\t- const 变量名 = 值\n\t- const 变量名 数据类型 = 值\n\n## 判断 IF\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    if 7%2 == 0 {  \n       fmt.Println(\"7 is even\")  \n    } else {  \n       fmt.Println(\"7 is odd\")  \n    }  \n  \n    if 8%4 == 0 {  \n       fmt.Println(\"8 is divisible by 4\")  \n    }  \n  \n    if num := 9; num < 0 {  \n       fmt.Println(num, \"is negative\")  \n    } else if num < 10 {  \n       fmt.Println(num, \"has l digit\")  \n    } else {  \n       fmt.Println(num, \"has multiple digits\")  \n    }  \n}\n```\n\n## 循环 For\n\n在 Go 中没有 while 和 do while，只有 for 循环\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    i := 1  \n    for {  \n       fmt.Println(\"loop\")  \n       break  \n    }  \n  \n    for j := 7; j < 9; j++ {  \n       fmt.Println(j)  \n    }  \n  \n    for n := 0; n < 5; n++ {  \n       if n%2 == 0 {  \n          continue  \n       }  \n       fmt.Println(n)  \n    }  \n  \n    for i <= 3 {  \n       fmt.Println(i)  \n       i++  \n    }  \n}\n```\n\n## 选择 Switch\n\n相较于C++、Java，Go中的 switch 不需要在每个 case 后都加 break\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"time\")  \n  \nfunc main() {  \n    a := 2  \n    switch a {  \n    case 1:  \n       fmt.Println(\"one\")  \n    case 2:  \n       {  \n          fmt.Println(\"two\")  \n       }  \n    case 3:  \n       fmt.Println(\"three\")  \n    case 4, 5:  \n       fmt.Println(\"four or five\")  \n    default:  \n       fmt.Println(\"other\")  \n    }  \n  \n    t := time.Now()  \n    switch {  \n    case t.Hour() < 12:  \n       fmt.Println(\"It's before noon\")  \n    default:  \n       fmt.Println(\"It's after noon\")  \n    }  \n}\n```\n\n如上 a = 2，进入 switch 后 进入 case 2，跑完 case 2 的事件后就到 t := time.Now() \n\n而且，Go 的 switch 可以用任意的变量类型，比如字符串，结构体等\n\n## 数组\n\n一样，数组长度是固定的\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    var a [5]int  \n    a[4] = 100  \n    fmt.Println(a[4], len(a))  \n  \n    b := [5]int{1, 2, 3, 4, 5}  \n    fmt.Println(b)  \n  \n    var twoD [2][3]int  \n    for i := 0; i < 2; i++ {  \n       for j := 0; j < 3; j++ {  \n          twoD[i][j] = i + j  \n       }  \n    }  \n    fmt.Println(twoD)  \n}\n```\n\n## 切片\n\n个人感觉就是链表\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    s := make([]string, 3)  \n    s[0] = \"a\"  \n    s[1] = \"b\"  \n    s[2] = \"c\"  \n    fmt.Println(s[2])  \n    fmt.Println(len(s))  \n  \n    s = append(s, \"d\")  \n    s = append(s, \"e\", \"f\")  \n    fmt.Println(s)  \n  \n    c := make([]string, len(s))  \n    copy(c, s)  \n    fmt.Println(c)  \n  \n    fmt.Println(s[2:5]) // [c d e]  \n    fmt.Println(s[:5])  // [a b c d e]  \n    fmt.Println(s[2:])  // [c d e f]  \n  \n    good := []string{\"g\", \"o\", \"o\", \"d\"}  \n    fmt.Println(good)  \n}\n```\n\n## map\n\n`变量名 := make(map[键]值)`\n\n`接收值1, 接收值2 := map变量名[\"键\"]`  第二个接收值可以查看map中是否有这个键，有返回true，反之false\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    m := make(map[string]int)  \n    m[\"one\"] = 1  \n    m[\"two\"] = 2  \n    fmt.Println(m)            // Output: map[one:1 two:2]  \n    fmt.Println(len(m))       // Output: 2  \n    fmt.Println(m[\"one\"])     // Output: 1  \n    fmt.Println(m[\"unknown\"]) // Output: 0  \n  \n    r, ok := m[\"unknown\"]  \n    fmt.Println(r, ok) // Output: 0 false  \n  \n    delete(m, \"one\")  \n  \n    m2 := map[string]int{\"three\": 3, \"four\": 4}  \n    var m3 = map[string]int{\"three\": 3, \"four\": 4}  \n    fmt.Println(m2, m3) // Output: map[three:3 four:4] map[three:3 four:4]  \n}\n```\n\n## range\n\n`for 变量1, 变量2 := range 数组（容器） {}`  变量1是索引 index， 变量2是索引对照的值val\n\n如果不需要索引就用下划线 `_` 代替\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() {  \n    nums := []int{1, 2, 3, 4, 5}  \n    sum := 0  \n    for i, num := range nums {  \n       sum += num  \n       if num == 2 {  \n          fmt.Println(\"index: \", i, \"nums: \", num)  \n       }  \n    }  \n    fmt.Println(\"sum: \", sum)  \n  \n    m := map[string]string{\"a\": \"A\", \"b\": \"B\", \"c\": \"C\"}  \n    for k, v := range m {  \n       fmt.Println(k, v) // prints \"a A\", \"b B\", \"c C\"  \n    }  \n    for k := range m {  \n       fmt.Println(\"key \", k) // prints \"a\", \"b\", \"c\"  \n    }  \n}\n```\n\n## 函数\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc add(a int, b int) int {  \n    return a + b  \n}  \n  \nfunc add2(a, b int) int {  \n    return a + b  \n}  \n  \nfunc exists(m map[string]string, key string) (v string, ok bool) {  \n    v, ok = m[key]  \n    return v, ok  \n}  \n  \nfunc main() {  \n    res := add(1, 2)  \n    fmt.Println(res)  \n  \n    v, ok := exists(map[string]string{\"a\": \"A\"}, \"a\")  \n    fmt.Println(v, ok)  \n}\n```\n\n## 指针\n\n相较于 C/C++，这里的指针操作有限，主要用途是对传入的参数进行修改\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \nfunc add2(n int) {  \n    n += 2  \n}  \n  \nfunc add2ptr(n *int) {  \n    *n += 2  \n}  \n  \nfunc main() {  \n    n := 5  \n    add2(n)  \n    fmt.Println(n) // Output: 5  \n    add2ptr(&n)  \n    fmt.Println(n) // Output: 7  \n}\n```\n\n## 结构体\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \ntype user struct {  \n    name     string  \n    password string  \n}  \n  \nfunc main() {  \n    a := user{name: \"John\", password: \"12345\"}  \n    b := user{\"Mary\", \"67890\"}  \n    c := user{name: \"Mike\"}  \n    c.password = \"98765\"  \n    var d user  \n    d.name = \"Peter\"  \n    d.password = \"4321\"  \n  \n    fmt.Println(a, b, c, d) // Output: {John 12345} {Mary 67890} {Mike 98765} {Peter 4321}  \n    fmt.Println(checkPassword(a, \"1234\")) // Output: false  \n    fmt.Println(checkPassword2(&a, \"12345\")) // Output: true  \n}  \n  \nfunc checkPassword(u user, password string) bool {  \n    return u.password == password  \n}  \n  \nfunc checkPassword2(u *user, password string) bool {  \n    return u.password == password  \n}\n```\n\n## 结构体方法\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \ntype user struct {  \n    name     string  \n    password string  \n}  \n  \nfunc (u user) checkPassword(password string) bool {  \n    return u.password == password  \n}  \n  \nfunc (u *user) resetPassword(password string) {  \n    u.password = password  \n}  \n  \nfunc main() {  \n    a := user{name: \"John\", password: \"12345\"}  \n    b := user{\"Mary\", \"67890\"}  \n    c := user{name: \"Mike\"}  \n    c.password = \"98765\"  \n    var d user  \n    d.name = \"Peter\"  \n    d.password = \"4321\"  \n\n    fmt.Println(a.checkPassword(\"12345\"))  \n}\n```\n\n## 错误处理\n\n一般在做错误处理时需返回 error，如果有错误就返回 `errors.New(\"错误介绍\")`，否则返回 `nil`\n\n```go\npackage main  \n  \nimport (  \n    \"errors\"  \n    \"fmt\")  \n  \ntype user struct {  \n    name     string  \n    password string  \n}  \n  \nfunc findUser(users []user, name string) (v *user, err error) {  \n    for _, u := range users {  \n       if u.name == name {  \n          return &u, nil  \n       }  \n    }  \n    return nil, errors.New(\"not found\")  \n}  \n  \nfunc main() {  \n    u, err := findUser([]user{{\"Alice\", \"123456\"}}, \"Alice\")  \n    if err != nil {  \n       fmt.Println(err)  \n       return  \n    }  \n    fmt.Println(u.name)  \n  \n    if u, err = findUser([]user{{\"wang\", \"123\"}}, \"li\"); err != nil {  \n       fmt.Println(err)  \n       return  \n    } else {  \n       fmt.Println(u.name)  \n    }  \n}\n```\n\n## 字符串操作\n\nHasPrefix函数用于判断第二个参数代表的字符串/字节切片是不是第一个参数的前缀\nHasSuffix函数则用于判断第二个参数是不是第一个参数的后缀\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"strings\")  \n  \nfunc main() {  \n    a := \"hello\"  \n    fmt.Println(strings.Contains(a, \"ll\"))                // true  \n    fmt.Println(strings.Count(a, \"l\"))                    // 2  \n    fmt.Println(strings.HasPrefix(a, \"he\"))               // true  \n    fmt.Println(strings.HasSuffix(a, \"llo\"))              // true  \n    fmt.Println(strings.Index(a, \"ll\"))                   // 2  \n    fmt.Println(strings.Join([]string{\"he\", \"llo\"}, \"-\")) // \"he-llo\"  \n    fmt.Println(strings.Repeat(a, 2))                     // \"hellohello\"  \n    fmt.Println(strings.Replace(a, \"e\", \"E\", -1))         // \"hEllo\"  \n    fmt.Println(strings.Split(\"a-b-c\", \"-\"))              // [\"a\", \"b\", \"c\"]  \n    fmt.Println(strings.ToLower(a))                       // \"hello\"  \n    fmt.Println(strings.ToUpper(a))                       // \"HELLO\"  \n    fmt.Println(len(a))                                   // 5  \n  \n    b := \"你好\"  \n    fmt.Println(len(b)) //6  \n}\n```\n\n## 字符串格式化\n\n```go\npackage main  \n  \nimport \"fmt\"  \n  \ntype point struct {  \n    x, y int  \n}  \n  \nfunc main() {  \n    s := \"hello\"  \n    n := 123  \n    p := point{1, 2}  \n    fmt.Println(s, n, p) // Output: hello 123 {1 2}  \n  \n    fmt.Printf(\"s=%v\\n\", s) // Output: s=hello  \n    fmt.Printf(\"n=%v\\n\", n) // Output: n=123  \n    fmt.Printf(\"p=%v\\n\", p) // Output: p={1 2}  \n    fmt.Printf(\"p=%+v\\n\", p) // Output: p=point{x:1, y:2}  \n    fmt.Printf(\"p=%#v\\n\", p) // Output: p=main.point{x:1, y:2}  \n  \n    f := 3.1415926  \n    fmt.Println(f) // Output: 3.1415926  \n    fmt.Printf(\"%.2f\\n\", f) // Output: 3.14  \n}\n```\n\n## JSON处理\n\n```go\npackage main  \n  \nimport (  \n    \"encoding/json\"  \n    \"fmt\")  \n  \ntype userInfo struct {  \n    Name  string  \n    Age   int `json:\"age\"`  \n    Hobby []string  \n}  \n  \nfunc main() {  \n    a := userInfo{Name: \"John\", Age: 25, Hobby: []string{\"Golang\", \"typeScript\"}}  \n    buf, err := json.Marshal(a) // 序列化  \n    if err != nil {  \n       panic(err)  \n    }  \n    fmt.Println(buf) // 输出序列化后的json字符串 [123 34 78 97 109...]    fmt.Println(string(buf)) // 输出序列化后的json字符串 {\"Name\":\"John\",\"age\":25,\"Hobby\":[\"Golang\",\"typeScript\"]}  \n    buf, err = json.MarshalIndent(a, \"\", \"\\t\")  \n    if err != nil {  \n       panic(err)  \n    }  \n    fmt.Println(string(buf))  \n    /*  \n    {       \"Name\": \"John\",       \"age\": 25,       \"Hobby\": [          \"Golang\",          \"typeScript\"       ]    }    */  \n    var b userInfo  \n    err = json.Unmarshal(buf, &b)  \n    if err != nil {  \n       panic(err)  \n    }  \n    fmt.Println(b) // 输出反序列化后的结构体 {John 25 [Golang typeScript]}}\n```\n\n## 时间处理\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"time\")  \n  \nfunc main() {  \n    now := time.Now()  \n    fmt.Println(now) // 2025-01-23 15:36:01.0802031 +0800 CST m=+0.000000001  \n    t := time.Date(2021, 10, 1, 12, 30, 0, 0, time.UTC)  \n    t2 := time.Date(2021, 9, 1, 12, 30, 0, 0, time.UTC)  \n    fmt.Println(t)                                                              // 2021-10-01 12:30:00 +0000 UTC  \n    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second()) // 2021 10 1 12 30 0  \n    fmt.Println(t.Format(\"2006-01-02 15:04:05\"))                                // 2021-10-01 12:30:00  \n  \n    diff := t2.Sub(t)  \n    fmt.Println(diff)                           // -720h0m0s  \n    fmt.Println(diff.Minutes(), diff.Seconds()) // -43200 -2.592e+06  \n    t3, err := time.Parse(\"2006-01-02 15:04:05\", \"2021-10-01 12:30:00\")  \n    if err != nil {  \n       fmt.Println(err)  \n    }  \n    fmt.Println(t3 == t)   // true  \n    fmt.Println(t3.Unix()) // 1633091400  \n}\n```\n\n## 数字解析\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"strconv\")  \n  \nfunc main() {  \n    f, _ := strconv.ParseFloat(\"3.14\", 64)  \n    fmt.Println(f) // Output: 3.14  \n  \n    n, _ := strconv.ParseInt(\"111\", 10, 64)  // 10是指十进制，传0的表示自动识别，64表示精度为64\n    fmt.Println(n) // Output: 111  \n  \n    n, _ = strconv.ParseInt(\"0x1234\", 0, 64)  \n    fmt.Println(n) // Output: 4660  \n  \n    n2, _ := strconv.Atoi(\"123\")  \n    fmt.Println(n2) // Output: 123  \n  \n    n2, err := strconv.Atoi(\"abc\")  \n    fmt.Println(n2, err) // Output: 0 strconv.ParseInt: parsing \"abc\": invalid syntax  \n}\n```\n\n## 进程信息\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"os\"    \"os/exec\")  \n  \nfunc main() {  \n    fmt.Println(os.Args)  \n  \n    fmt.Println(os.Getenv(\"PATH\"))  \n    fmt.Println(os.Setenv(\"AA\", \"BB\"))  \n  \n    buf, err := exec.Command(\"grep\", \"127.0.0.1\", \"/etc/hosts\").CombinedOutput()  \n    if err != nil {  \n       fmt.Println(err)  \n    }  \n    fmt.Println(string(buf))  \n}\n```\n\n# 综合练习\n\n## 猜数字\n\n```go\npackage main  \n  \nimport (  \n    \"bufio\"  \n    \"fmt\"    \"math/rand\"    \"os\"    \"strconv\"    \"strings\"    \"time\")  \n  \nfunc main() {  \n    maxNum := 100  \n    rand.Seed(time.Now().UnixNano())  \n    secretNumber := rand.Intn(maxNum)  \n  \n    for {  \n       fmt.Println(\"Please input your guess\")  \n       reader := bufio.NewReader(os.Stdin)  \n       input, err := reader.ReadString('\\n')  \n       if err != nil {  \n          fmt.Println(\"An error occurred while reading input, please try again\", err)  \n          continue  \n       }  \n       input = strings.TrimSuffix(input, \"\\n\")  \n       guess, err := strconv.Atoi(input)  \n       if err != nil {  \n          fmt.Println(\"Invalid input, please try again\", err)  \n          continue  \n       }  \n       if guess > secretNumber {  \n          fmt.Println(\"Too high, try again\")  \n       } else if guess < secretNumber {  \n          fmt.Println(\"Too low, try again\")  \n       } else {  \n          fmt.Println(\"Congratulations, you guessed the number\", secretNumber)  \n          break  \n       }  \n    }  \n}\n```\n\n## 在线词典\n\n**第一步**\n首先打开[彩云小译官网 - 高效准确的翻译工具 | 文字翻译 | 文档翻译 | 网页翻译 | 浏览器插件 | 双语对照 | 术语库](https://fanyi.caiyunapp.com/)\n\n按键盘上的 F12 或者右键页面打开检查，随后点击网络\n\n![](MarsCode学习笔记/5.Go/p1.png)\n\n从下往上找第一个dict，右键复制-->复制cURL(bash)\n\n然后打开[curl to Go](https://curlconverter.com/go/)，把复制的代码放在里面，生成 Go\n\n```go\npackage main  \n  \nimport (  \n    \"fmt\"  \n    \"io\"    \"log\"    \"net/http\"    \"strings\")  \n  \nfunc main() {  \n    client := &http.Client{}  \n    var data = strings.NewReader(`{\"trans_type\":\"zh2en\",\"source\":\"帅\"}`)  \n    req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data)  \n    if err != nil {  \n       log.Fatal(err)  \n    }  \n    req.Header.Set(\"accept\", \"application/json, text/plain, */*\")  \n    req.Header.Set(\"accept-language\", \"zh\")  \n    req.Header.Set(\"app-name\", \"xiaoyi\")  \n    req.Header.Set(\"authorization\", \"Bearer\")  \n    req.Header.Set(\"content-type\", \"application/json;charset=UTF-8\")  \n    req.Header.Set(\"device-id\", \"\")  \n    req.Header.Set(\"origin\", \"https://fanyi.caiyunapp.com\")  \n    req.Header.Set(\"os-type\", \"web\")  \n    req.Header.Set(\"os-version\", \"\")  \n    req.Header.Set(\"priority\", \"u=1, i\")  \n    req.Header.Set(\"referer\", \"https://fanyi.caiyunapp.com/\")  \n    req.Header.Set(\"sec-ch-ua\", `\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\", \"Microsoft Edge\";v=\"132\"`)  \n    req.Header.Set(\"sec-ch-ua-mobile\", \"?0\")  \n    req.Header.Set(\"sec-ch-ua-platform\", `\"Windows\"`)  \n    req.Header.Set(\"sec-fetch-dest\", \"empty\")  \n    req.Header.Set(\"sec-fetch-mode\", \"cors\")  \n    req.Header.Set(\"sec-fetch-site\", \"cross-site\")  \n    req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0\")  \n    req.Header.Set(\"x-authorization\", \"token:qgemv4jr1y38jyq6vhvi\")  \n    resp, err := client.Do(req)  \n    if err != nil {  \n       log.Fatal(err)  \n    }  \n    defer resp.Body.Close()  \n    bodyText, err := io.ReadAll(resp.Body)  \n    if err != nil {  \n       log.Fatal(err)  \n    }  \n    fmt.Printf(\"%s\\n\", bodyText)  \n}\n```\n\n**第二步**\n\n我们需要把所需的文本转成 json\n\n```go\npackage main  \n  \nimport (  \n    \"bytes\"  \n    \"encoding/json\"    \"log\"    \"net/http\")  \n  \ntype DictRequest struct {  \n    TranType string `json:\"tran_type\"`  \n    Source   string `json:\"source\"`  \n    UserID   string `json:\"user_id\"`  \n}  \n  \nfunc main() {  \n    client := &http.Client{}  \n    request := DictRequest{TranType: \"EN-ZH\", Source: \"good\"}  \n    buf, err := json.Marshal(request)  \n    if err != nil {  \n       log.Fatal(err)  \n    }  \n    var data = bytes.NewReader(buf)  \n    req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data)  \n    if err != nil {  \n       log.Fatal(err)  \n    }  \n}\n```\n\n后因工具因素暂未完成（工具网址暂停运用了），大概工作是对照所需要的 json 来生成 struct，最后全部拼接到一起","tags":["字节青训营"]},{"title":"RDBMS","url":"/2025/01/20/articles/MarsCode学习笔记/4.RDBMS/RDBMS/","content":"# ACID\n\n**ACID**：\n- 原子性( tomicity):事务是一个不可再分割的工作单元,事务中的操作要么都发生，要么都不发生。\n- 一致性( onsistency):数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性，每个操作都必须是合法的。\n- 隔离性( solation):多个事务并发访问时,事务之间是隔离的,一个事务不应该影响其它事务运行效果，类似于串行操作。\n- 持久性(Curability):在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n# 模型\n\n1960s，传统的文件系统已经不能满足人们的需要，数据库管理系统(DBMS)应运而生DBMS:按照某种数据模型来组织、存储和管理数据的仓库。所以通常按照数据模型的特点将传统数据库系统分成网状数据库、层次数据库和关系数据库三类。\n\n## 网状模型\n\n![](MarsCode学习笔记/4.RDBMS/p1.png)\n\n把每个数据作为一个节点，构成一个网状的结构，每个父节点可以有多个子节点，一个子节点也可以有多个父节点，多对多\n\n## 层次模型\n\n![](p2.png)\n\n层次模型是一个树形模型，层次模型和网状模型特别相像，最大的不同是每个父节点可以有多个子节点，但每个子节点只能有一个父节点，一对多\n\n## 关系模型\n\n![](p3.png)\n\n把所有的关系都存放在一个或多个二维表里，就是我们现在所使用的数据库模型\n\n## 优势与劣势\n\n| 模型类型 | 优势                                                       | 劣势                                                         |\n| ---- | -------------------------------------------------------- | ---------------------------------------------------------- |\n| 网状模型 | - 能直接描述现实世界<br>- 存取效率较高                                  | - 结构复杂<br>- 用户不易使用<br>- 访问程序设计复杂                           |\n| 层次模型 | - 结构简单<br>- 查询效率高<br>- 可以提供较好的完整性支持                      | - 无法表示M:N的关系<br>- 插入、删除限制多<br>- 遍历子节点必须经过父节点<br>- 访问程序设计复杂 |\n| 关系模型 | - 实体及实体间的联系都通过二维表结构表示<br>- 可以方便的表示M:N关系<br>- 数据访问路径对用户透明 | - 关联查询效率不够高<br>- 关系必须规范化                                   |\n# SQL\n\n- 语法风格接近自然语言;\n- 高度非过程化;\n- 面向集合的操作方式;\n- 语言简洁，易学易用。\n\n一条SQL语句的执行：\n![](p4.png)\n\n- Parser：语法解析器\n- AST：语法树\n- Optimizer：优化器\n- Plan：生成一个树状结构PlanTree\n- Executor：执行器\n==其中Parsser、Optimizer、Executor都是SQL引擎，DataFile、LogFile都是存储引擎，事物引擎没有显示的表现在图上==\n\n## Parser\n\n解析器(Parser)一般分为词法分析(Lexical analysis)、语法分析(Syntax analysis)、语义分析(Semantic analyzer)等步骤。\n\n![](p5.png)\n\n## Optimizer\n\n作用是在多种可能中选取最优的那种\n\n### 基于规则的优化（**RBO**  Rule  Base Optimizer）\n\n- 条件优化\n\t- a > b & a > 5  -->  a > 5 & b > 5\n\t- a > 5 & a < b & b = 1 -->  false\n\n- 表连接优化\n\t- 总是小表先进行连接\n\n- Scan优化\n\t- 唯一索引\n\t- 普通索引\n\t- 全表扫描\n\n\n### 基于代价的优化（**CBO**  Cost Base Optimizer）\n\n一个查询有多种执行方案，CBO会选择其中代价最低的方案去真正的执行\n\n例如：时间，IO，CPU，NET，内存\n\n\n## 存储引擎\n\n### InnoDB\n\n- 支持行锁，采用MVCC来支持高并发，有可能死锁\n- 支持事务\n- 支持外键\n- 支持崩溃后的安全恢复\n- 不支持全文索引\n\n### B+Tree\n\n![](MarsCode学习笔记/4.RDBMS/p6.png)\n页面内页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。\n从根到叶，中间节点存储\n\n## 事物日志\n\n- **Atomicity & Undo log**\n\t - Undo Log是**逻辑日志**，记录的是数据的增量变化。利用Undo Log可以进行事务回滚，从而保证事务的原子性。同时也实现了多版本并发控制(MVCC)解决读写冲突和一致性读的问题\n\n- **Isolation & MVCC**\n\t- MVCC的意义:\n\t\t- 读写互不阻塞;\n\t\t- 降低死锁概率;\n\t\t- 实现一致性读。\n\n- **Durability & Redo Log**\n\t- redo log是**物理日志**，记录的是页面的变化，它的作用是保证事务持久化。如果数据写入磁盘前发生故障，重启MySQL后会根据redo loq重做。\n\n\n# 大流量\n\n以下为缩写，有需要对照去查资料\n\n## Sharding\n\n问题背景\n- 单节点写容易成为瓶颈单机数据容量上限\n\n解决方案\n- 业务数据进行水平拆分代理层进行分片路由\n\n实施效果\n- 数据库写入性能线性扩展数据库容量线性扩展\n\n## 扩容\n\n问题背景\n- 活动流量上涨集群性能不满足要求\n\n解决方案\n- 扩容DB物理节点数量利用影子表进行压测\n\n实施效果\n- 数据库集群提供更高的吞吐保证集群可以承担预期流量\n\n## 代理连接池\n\n问题背景\n- 突增流量导致大量建联大量建联导致负载变大，延时上升\n\n解决方案\n- 业务侧预热连接池\n- 代理侧预热连接池\n- 代理侧支持连接队列\n\n实施效果\n- 避免 DB 被突增流量打死避免代理和 DB 被大量建联打死","tags":["字节青训营"]},{"title":"数据库","url":"/2025/01/17/articles/MarsCode学习笔记/3.DataBase/数据库/","content":"# ARID磁盘阵列\n\nQ : 单机存储系统怎么做到高性能/高性价比/高可靠性\n\nA : <font color=red>R</font>(edundant) <font color=red>A</font>(array) <font color=red>I</font>(nexpensive) <font color=red>D</font>(isks)\n\n## ARID的使用背景\n\n- 单块大容量磁盘的**价格** > 多块小容量磁盘\n- 单块磁盘的写入**性能** < 多块磁盘的并发写入功能\n- 单块磁盘的**容错能力**有限，不够安全\n\n## 常见ARID方案\n\n- RAID 0\n\t- 多块磁盘简单组合\n\t- 数据条带化存储，提高磁盘带宽\n\t- 没有额外的容错设计\n\t例如一条1G的数据1被拆成两条512M数据，分别写道磁盘1和磁盘2上，然后磁盘1和磁盘2的第一个512M共同组成数据1\n- RAID 1\n\t- 一块磁盘对应着一块额外的磁盘\n\t- 真实空间利用率仅50%\n\t- 容错能力强\n\tRAID 1和RAID 0是两个极端，把一条数据copy一份放在两个磁盘上\n- RAID 0 + 1\n\t- 结合了 RAID 0 和 RAID 1\n\t- 真实空间利用率只有50%\n\t- 容错能力强，写入宽带好\n\t例如说，现在有四块磁盘，可以把它两两组成一个 RAID 0，然后再把组成的单元用 RAID 1 组成起来或者组成 RAID 1，然后再用 RAID 0 组成起来，虽然空间利用率还是只有50%，但是还用上了 RAID 1 的条带化写入，并发存储，写入带宽能翻几倍。\n\n# 数据库\n\n关系 = 集合 = 任意元素组成的若干有序偶对反应了事物间的关系\n\n关系代数 = 对关系作运算的抽象查询语言(交、并、笛卡尔积......)\n\nSQL = 一种DSL(领域特定语言)\n\n## 单机数据库\n\n单机数据库 = 单个计算机节点上的数据库系统\n\n事物在单机内执行，也可能通过网络交互实现分布式事物\n\n![](p4.png)\n\n![](p5.png)\n\n## 关系型数据库\n\n<font color=red>关系型数据库是存储系统</font>，但是在存储之外，有发展出其他功能\n\n- 结构化数据友好\n- 支持事务(ACID(原子性，一致性、隔离性，持久性))\n- 支持复杂查询语言\n\n![](MarsCode学习笔记/3.DataBase/p1.png)\n\n## 非关系型数据库\n\n非关系型数据库也是存储系统，但是<font color=red>一般不要求严格的结构化</font>\n\n关系型数据库一般直接使用 SQL 交互，而非关系型数据库交互方式各不相同\n\n非关系型数据库的数据结构千奇吧百怪，没有关系约束后，schema相对灵活\n\n# 单机存储系统\n\n单机存储系统 = 单个计算机节点上的存储软件系统，一般不涉及网络交互\n\n## 本地文件系统\n\nLinux经典哲学：一切皆文件\n\n- 文件系统管理单元：文件\n- 文件系统接口：如Ext2/3/4，sysfs，rootfs等，但都遵循VFS的统一抽象接口\n- Liunx文件系统的两大数据结构：Index Node & Directory Entry\n\n![](p2.png)\n\n## Key-value存储\n\n- 常见使用方式：put(k, v) & get(k)\n- 常见数据结构：LSM-Tree，某种程度上牺牲读性能，追求写性能\n\n## 分布式存储系统\n\n分布式存储系统 = 在单机存储基础上实现了分布式协议，涉及大量网络交互\n\n可以解决容量、弹性、性价比问题：\n\n单机数据库通过本地文件系统提供的文件接口，在底层的存储介质读/写文件，这有个很明显的问题，就是存储是有限的，所以我们现在普遍使用的是池化的技术，把存储能力做成了一个存储池，存储池由物理或者虚拟机组成，存储池与数据库是用网络进行交互，这样，数据库就不需要看本身的存储能力够不够，只要存储池在达到预值后自动添加存储节点，把数据的写入分配到新加入的存储节点即可\n\n### 解决弹性问题\n\n\n### HDFS\n\n堪称大数据时代的基石\n\n核心特点：\n- 支持海量数据存储\n- 高容错性\n- 弱POSIX语义\n- 使用普通x86服务器，性价比高\n![](p3.png)\n\n### Ceph\n\n开源分布式存储系统里的==万金油\n\n核心特点：\n- 一套系统支持对象接口、块接口、文件接口，但是<font color=red>一切皆对象\n</font>\n- 数据写入采用<font color=red>主备复制模型</font>\n- 数据分布模型采用CURSH算法\n\n\n\n\n\n","tags":["字节青训营"]},{"title":"Git","url":"/2025/01/15/articles/MarsCode学习笔记/1.Git/Git/","content":"## 项目初始化\n\n在study文件下创建一个git，名字叫blog\n```\nmkdir study\ncd study\ngit init blog\n```\n\n其他参数\n```\n--initial-branch  初始化的分支\n--bare  创建一个裸仓库(纯 Git 目录，没有工作目录)\n--template  可以通过模板来创建预先构建好的自定义 git 目录\n```\n\n## Git Config\n\n不同级别的 Git 配置\n- **--global   \n- **--system\n- **--local\n\n每个级别的配置可能会重复，但是低级别的配置会覆盖高级别的配置\n\nsystem > global > local\n\n## 常见 Git 配置\n\n### 用户名配置\n\n```git\ngit config --global user.name \"用户名\"\ngit config --global user.email \"用户邮箱地址\"\n```\n\n### Instead of 配置\n\n配置命令可以用于将 Git 命令中的 URL 映射到另一个 URL\n比如下面把 `git@github.com` 映射成 `https://github.com/` ：\n```\ngit config --global url.git@github.com:.insteadOf https://github.com/\n```\n\n### Git 命令别名配置\n\n可以用来简化命令\n比如下面把 `commit --amend --no-edit` 改成 `cin` ：\n```\ngit config --global alias.cin \"commit --amend --no-edit\"\n```\n\n## Git Remote\n\n列出当前仓库中已配置的远程仓库，并显示它们的 URL\n```\ngit remote -v\n```\n\n添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中 \n`git remote add <remote_name> <remote_url>`\n例如：\n```\ngit remote add origin_ssh git@github.com:git/git.git\ngit remote add origin_http https://github.com/git/git.git\n```\n\n其他关于 Remote 命令可以通过 `git remote -h` 来查看\n\n## Git Add\n\n目执行 `git status` 查看 git 状态，可以看到一个新的管理的项目目前没有任何提交，然后我们在这个目录下创建一个 ==readme.md== 文件，使用 `touch readme.md` ，然后再通过 `git status` 查看状态\n\n在git中，文件的状态只有三种(已修改、已暂存、已提交)\n- **已修改**\n    - 在工作目录修改Git文件\n- **已暂存**\n    - 对已修改的文件执行Git暂存操作(git add)，将文件存入暂存区\n- **已提交**\n    - 将已暂存的文件执行Git提交操作(git commit)，将文件存入版本库\n\n我们对文件的各种操作新建、编辑(写代码)都是在`工作区`完成的，但是工作区的文件还是不被Git所管理的，Git会告诉你 read.me 是未被追踪的文件，需要执行`git add 文件名`把 readme.md 提交到`暂存区`以便纳入到Git版本管理中来\n\n我们来执行git add 操作，然后再查看状态,可以看到index.php已经被暂存，如果我们想把现在的暂存撤销，可以使用`git rm --cached readme.md` 命令来撤销，如果想提交到版本库，就再执行git commit操作就可以了\n\n在暂存区的文件使用`git commit readme.md -m\"备注\"`提交到版本库中\n\n如果修改了文件并且上传，想要返回上次上次的快照，可以通过查看git status可以看到文件状态被改变了。可以把工作区修改的文件git add提交到暂存区，也可以使用 `git checkout —- readme.md` 把工作区的修改撤销，这样，文件就会回退到上一次提交时的状态。\n\n### Objects 对象\n\nGit对象一共有三种：数据对象、树对象以及提交对象，这些对象都被保存在了.git/objects目录下\n\n- **Blob**\n\t- 存储文件的内容\n- **Tree**\n\t- 存储文件的目录信息\n- **Commit**\n\t- 存储提交信息，一个 Commit 可以对应唯一的版本的代码\n\n\n通过 Commit 寻找到 Tree 信息，每个 Commit 都会存储对应的 Tree ID\n使用 `tree .git` 查看 objects 中的所有信息，找到ID，然后使用 `git cat-file -p CommitID`，就能看到Tree ID 和 作者\n\n通过 Tree 存储信息可以获取到对应的目录树信息，也是用 `git cat-file -p TreeID`\n\n从 Tree 中获取 Blob 的 ID， `git cat-file -p BlobID` 获取到对应的文件内容\n![](MarsCode学习笔记/1.Git/p1.png)\n\n## Refs分支\n### 新建、切换分支\n\n```\n切换分支：git checkout 分支名 \n新建分支：git checkout -b 分支名\n```\n\n### Tag\n\n标签一般表示一个稳定的版本，指向一个 Commit 一般不会变更\n```\ngit tag -a 版本号 -m \"备注\"\n```\n\n\n### 修改历史版本\n\n```\ngit commit --amend\n```\n\n## Git Clone & Pull & Fetch\n\n- **Clone**\n\t- 拉取完整的仓库到本地目录，可以指定分支，深度\n- **Fetch**\n\t- 将远端某些分支最新代码拉取到本地，不会执行 merger 操作，会修改 refs/remote 内的分支信息，如果需要和本地代码合并需要手动操作\n- **Pull**\n\t- 拉取远端某些分支，并和本地代码进行合并，操作等同于 git fetch + git merger，也可以通过 git pull --rebase 完成 git fetch + git rebase 操作，**可能存在冲突，需要手动解决冲突**\n\n**关于 Fetch ，Fetch 会把代码拉取到本地的远端分支，但是并不会合并到当前分支，所以当前分支历史没有变化**\n\n## Git Push\n\n将本地代码同步到远端的方式\n\n一般使用 `git push origin 分支名`\n\n**冲突问题**\n- 如果本地的 commit 记录和远端的 commit 历史不一致，则会发生冲突，比如 git commit --amend or git rebase 都有可能导致这个问题\n- 如果该分支就自己一个人使用，或者团队内确认可以修改历史则可以通过 `git push origin 分支名 -f` 来完成强制推送，一般不建议主干分支进行该操作，正常都应该解决冲突后再进行推送\n\n","tags":["字节青训营"]},{"url":"/2025/01/12/articles/遇到报错解决不了/","content":"\n# 遇到报错，实在解决不了，就降低版本"},{"url":"/2024/12/24/articles/md的使用/","content":"插入图片\n![](JDBC/p1.png)\n\n- 小点\n\n**加粗\n\n==标记==\n\n#标签\n\n\tTab \n\n<font color=red>红色的字</font>\n\n| 表头  | 表头  |\n| --- | --- |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n"},{"title":"SpringMVC学习笔记","url":"/2024/12/24/articles/SpringMVC/SpringMVC/","content":" ## 所需依赖\n\n```xml\n<properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.target>11</maven.compiler.target>\n        <maven.compiler.source>11</maven.compiler.source>\n        <junit.version>5.9.2</junit.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>jakarta.servlet</groupId>\n            <artifactId>jakarta.servlet-api</artifactId>\n            <version>5.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-api</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-engine</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>6.2.1</version>\n        </dependency>\n    </dependencies>\n```\n\n# HelloMVC\n\n![](p-1.png)\n\n- web.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\"\n         version=\"5.0\">\n\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc-servlet.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n- 自动扫描包，让指定包下的注解生效，有IOC容器统一管理\n\nspringmvc-servlet.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xmlns:context=\"http://www.springframework.org/schema/context\"  \n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">  \n  \n    <context:component-scan base-package=\"com.example.controller\"/>  \n  \n    <mvc:default-servlet-handler/>  \n    <mvc:annotation-driven/>  \n  \n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\">  \n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>  \n        <property name=\"suffix\" value=\".jsp\"/>  \n    </bean>  \n</beans>\n```\n\nhello.jsp\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>  \n<html>  \n<head>  \n    <title>Title</title>  \n</head>  \n<body>  \n${msg}  \n</body>  \n</html>\n```\n\nControllerTest.class\n```java\npackage com.example.controller;  \n  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \n  \n@Controller  \n@RequestMapping(\"/c\")  \npublic class ControllerTest {  \n    @RequestMapping(\"/h1\")  \n    public String test1(Model model) {  \n  \n        model.addAttribute(\"msg\", \"Controller Test\");  \n  \n        return \"hello\";  //会被视图解析器处理，找到WEB-INF/jsp/hello.jsp\n    }  \n}\n```\n\n# RestFul 风格\n\n**RestFul风格会允许我们将参数通过URL拼接传送到服务端\n\n比如这里我们的URL可以填\n``http://localhost:8080/add/13/18``\n\n```java\n@Controller  \npublic class RestFulController {  \n    @GetMapping(\"/add/{a}/{b}\")  \n    public String test1(@PathVariable int a, @PathVariable int b, Model model){  \n        int result = a + b;  \n  \n        model.addAttribute(\"msg\", \"result is \" + result);  \n  \n        return \"hello\";  \n    }  \n}\n```\n\n**当然，我们也可以通过RestFul风格来传对象，例如：\n\n```java\npackage com.example.controller;  \n  \nimport com.example.pojo.User;  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.GetMapping;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RequestParam;  \n  \n@Controller  \n@RequestMapping(\"/user\")  \npublic class UserController {  \n  \n    @GetMapping(\"/t1\")  \n    public String test1(@RequestParam(\"name\") String name, Model model) {  \n        // 接受前端参数  \n        System.out.println(\"前端接收的参数为\" + name);  \n        // 将返回的结果赋给前端  \n        model.addAttribute(\"msg\", name);  \n        // 视图跳转  \n        return \"hello\";  \n    }  \n  \n    @GetMapping(\"/t2\")  \n    public String test2(User user, Model model) {  \n        model.addAttribute(\"msg\", user);  \n        return \"hello\";  \n    }  \n}\n```\n\n我们输入``http://localhost:8080/mvc/user/t2?id=1&name=\"呵帅\"&age=18)``也可以成功传值\n\n\n这里有一篇博客讲的很清楚\n[RESTful 风格（详细介绍 + 案例实现）_resultful风格开发-CSDN博客](https://blog.csdn.net/zzvar/article/details/118164133)\n\n\n# JSON\n\n```html\n<!DOCTYPE html>  \n<html lang=\"en\">  \n<head>  \n    <meta charset=\"UTF-8\">  \n    <title>Title</title>  \n  \n    <script type=\"javascript\">  \n        let user = {  \n            name: \"hs\",  \n            age: 18,  \n            sex: \"男\"  \n        };  \n  \n        let jsonStr = JSON.stringify(user);  \n  \n        console.log(jsonStr);  \n  \n        let obj = JSON.parse(jsonStr);  \n        console.log(obj);  \n  \n    </script>  \n  \n</head>  \n<body>  \n  \n</body>  \n</html>\n```\n\nutils\n用json对象表示法来返回一个时间给页面\n```java\npackage com.example.utils;  \n  \nimport com.fasterxml.jackson.core.JsonProcessingException;  \nimport com.fasterxml.jackson.databind.ObjectMapper;  \nimport com.fasterxml.jackson.databind.SerializationFeature;  \n  \nimport java.text.SimpleDateFormat;  \nimport java.util.Date;  \n  \npublic class JsonUtils {  \n    public static String getJson(Object o) {  \n        return getJson(o, \"yyyy-MM-dd HH:mm:ss\");  \n    }  \n    public static String getJson(Object o, String dateFormat) {  \n        ObjectMapper mapper = new ObjectMapper();  \n  \n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);  \n  \n        SimpleDateFormat sdf =  new SimpleDateFormat(dateFormat);  \n        mapper.setDateFormat(sdf);  \n  \n        try {  \n            return mapper.writeValueAsString(o);  \n        } catch (JsonProcessingException e) {  \n            throw new RuntimeException(e);  \n        }  \n    }  \n  \n}\n```\n\nUserController\n```java\npackage com.example.controller;  \n  \nimport com.example.pojo.User;  \nimport com.example.utils.JsonUtils;  \nimport com.fasterxml.jackson.core.JsonGenerator;  \nimport com.fasterxml.jackson.core.JsonProcessingException;  \nimport com.fasterxml.jackson.databind.ObjectMapper;  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.web.bind.annotation.GetMapping;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.ResponseBody;  \nimport org.springframework.web.bind.annotation.RestController;  \n  \nimport java.text.SimpleDateFormat;  \nimport java.util.ArrayList;  \nimport java.util.Date;  \n  \n@Controller  \npublic class UserController {  \n  \n    @GetMapping(\"/j1\")  \n    @ResponseBody // 不会走视图解析器，直接返回一个字符串  \n    public String test1() throws JsonProcessingException {  \n  \n        User user = new User(\"hs\", 18, \"男\");  \n  \n        return JsonUtils.getJson(user);  \n    }  \n  \n    @GetMapping(\"/j2\")  \n    @ResponseBody // 不会走视图解析器，直接返回一个字符串  \n    public String test2() throws JsonProcessingException {  \n  \n        ArrayList<User> arr = new ArrayList<>();  \n  \n        User user = new User(\"呵帅1\", 18, \"男\");  \n        User user2 = new User(\"呵帅2\", 18, \"男\");  \n        User user3 = new User(\"呵帅3\", 18, \"男\");  \n        User user4 = new User(\"呵帅4\", 18, \"男\");  \n        User user5 = new User(\"呵帅5\", 18, \"男\");  \n  \n        arr.add(user);  \n        arr.add(user2);  \n        arr.add(user3);  \n        arr.add(user4);  \n        arr.add(user5);  \n  \n        return JsonUtils.getJson(arr);  \n    }  \n  \n    @GetMapping(\"/j3\")  \n    @ResponseBody // 不会走视图解析器，直接返回一个字符串  \n    public String test3() throws JsonProcessingException {  \n  \n        Date date = new Date();  \n  \n        return JsonUtils.getJson(date);  \n  \n    }  \n}\n```\n\n# ModelAndView\n\n## 固定模板\n\n两个config\n\n```java\npackage com.example.config;  \n  \nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;  \n  \npublic class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {  \n  \n    @Override  \n    protected Class<?>[] getRootConfigClasses() {  \n        return new Class[]{WebConfiguration.class};   //基本的Spring配置类，一般用于业务层配置  \n    }  \n  \n    @Override  \n    protected Class<?>[] getServletConfigClasses() {  \n        return new Class[0];  //配置DispatcherServlet的配置类、主要用于Controller等配置，这里为了教学简单，就不分这么详细了，只使用上面的基本配置类  \n    }  \n  \n    @Override  \n    protected String[] getServletMappings() {  \n        return new String[]{\"/\"};    //匹配路径，与上面一致  \n    }  \n}\n```\n\n```java\npackage com.example.config;  \n  \nimport com.example.interceptor.MainInterceptor;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;  \nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;  \nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  \nimport org.thymeleaf.spring6.SpringTemplateEngine;  \nimport org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver;  \nimport org.thymeleaf.spring6.view.ThymeleafViewResolver;  \nimport org.thymeleaf.templateresolver.ITemplateResolver;  \n  \n@Configuration  \n@EnableWebMvc   //快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置  \n@ComponentScan(\"com.example.controller\")  \npublic class WebConfiguration {  \n    //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面  \n    @Bean  \n    public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine){  \n        ThymeleafViewResolver resolver = new ThymeleafViewResolver();  \n        resolver.setOrder(1);   //可以存在多个视图解析器，并且可以为他们设定解析顺序  \n        resolver.setCharacterEncoding(\"UTF-8\");   //编码格式是重中之重  \n        resolver.setTemplateEngine(springTemplateEngine);   //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎  \n        return resolver;  \n    }  \n  \n    //配置模板解析器  \n    @Bean  \n    public SpringResourceTemplateResolver templateResolver(){  \n        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();  \n        resolver.setSuffix(\".html\");   //需要解析的后缀名称  \n        resolver.setPrefix(\"classpath:\");   //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀  \n        return resolver;  \n    }  \n  \n    //配置模板引擎Bean  \n    @Bean  \n    public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver){  \n        SpringTemplateEngine engine = new SpringTemplateEngine();  \n        engine.setTemplateResolver(resolver);   //模板解析器，默认即可  \n        return engine;  \n    }  \n  \n}\n```\n\n## 返回错误信息给页面\n\n```java\npackage com.example.controller;  \n  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.ControllerAdvice;  \nimport org.springframework.web.bind.annotation.ExceptionHandler;  \n  \n@ControllerAdvice  \npublic class ErrorController {  \n  \n    @ExceptionHandler(Exception.class)  \n    public String error(Exception e, Model model) {  \n        e.printStackTrace();  \n        model.addAttribute(\"e\", e);  \n        return \"error\";  \n    }  \n}\n```\n\n## 获取cookie的方法\n\n```java\n@RequestMapping(\"/test2\")  \npublic String index2(@CookieValue(\"JSESSIONID\") String id) {  \n    System.out.println(id);  \n    return \"index\";  \n}\n```\n\n# 拦截器\n\n```java\npackage com.example.interceptor;  \n  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \nimport org.springframework.web.servlet.HandlerInterceptor;  \nimport org.springframework.web.servlet.ModelAndView;  \n  \npublic class MainInterceptor implements HandlerInterceptor {  \n    @Override  \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n        System.out.println(\"处理前\");  \n        return true;  \n    }  \n  \n    @Override  \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  \n        System.out.println(\"处理后\");  \n    }  \n  \n    @Override  \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  \n        System.out.println(\"完成后\");  \n    }  \n  \n}\n```\n\n  \n这段代码是一个Spring框架中的拦截器（Interceptor）实现示例。拦截器是Spring MVC中处理请求的组件之一，它可以在请求的多个不同阶段执行自定义逻辑。这个`MainInterceptor`类实现了`HandlerInterceptor`接口，并重写了其中的三个方法，分别对应请求处理的不同阶段：\n\n1. `preHandle`：在请求处理之前调用（Controller方法调用之前）。\n2. `postHandle`：在请求处理之后调用，但在视图被渲染之前（Controller方法调用之后）。\n3. `afterCompletion`：在请求处理之后调用，当所有的请求处理工作完成之后，也就是在DispatcherServlet渲染了对应的视图之后调用。\n4. \n具体到这个`MainInterceptor`类：\n\n- `preHandle`方法中，打印了\"处理前\"，并返回`true`，表示请求可以继续向下执行。\n- `postHandle`方法中，打印了\"处理后\"，这个方法可以修改ModelAndView对象，但在这个示例中并没有进行任何操作。\n- `afterCompletion`方法中，打印了\"完成后\"，这个方法用于进行资源清理工作。\n\n这个拦截器可以被注册到Spring MVC的配置中，以便在请求处理过程中自动调用。注册拦截器通常在Spring的配置类中通过`WebMvcConfigurer`接口的`addInterceptors`方法完成。\n\n# SpringSecurity\n## 配置环境\n\n**导入 maven 依赖\n\n```xml\n<dependency>  \n    <groupId>org.springframework.security</groupId>  \n    <artifactId>spring-security-web</artifactId>  \n    <version>6.3.4</version>  \n</dependency>  \n<dependency>  \n    <groupId>org.springframework.security</groupId>  \n    <artifactId>spring-security-config</artifactId>  \n    <version>6.1.4</version>  \n</dependency>\n```\n\n配置 SecurityInitializer ，与MVC一样，需要一个初始化器\n\n```java\npackage com.example.init;  \n  \nimport org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;  \n  \npublic class SecurityInitializer extends AbstractSecurityWebApplicationInitializer {  \n      // 这里会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的\n}\n```\n\n然后我们创建一个配置类用于配置SpringSecurity\n\n```java\npackage com.example.config;  \n  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  \n  \n@Configuration  \n@EnableWebSecurity // 开启 WebSecurity 相关功能  \npublic class SecurityConfiguration {  \n}\n```\n\n创建完 SecurityConfiguration 配置类后需要修改 MainInitializer 中的 getRootConfigClasses\n\n```java\n@Override  \nprotected Class<?>[] getRootConfigClasses() {  \n    return new Class[]{WebConfiguration.class, SecurityConfiguration.class};\n}\n```\n\n\n## 认证\n\n在Spring Security中，认证（Authentication）是确定用户身份的过程。它是Spring Security提供的安全功能的核心部分，用于验证用户是否为他们声称的那个人。\n\n```java\npackage com.example.config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  \nimport org.springframework.security.core.userdetails.User;  \nimport org.springframework.security.core.userdetails.UserDetails;  \nimport org.springframework.security.core.userdetails.UserDetailsService;  \nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;  \n  \n@Configuration  \n@EnableWebSecurity // 开启 WebSecurity 相关功能  \npublic class SecurityConfiguration {  \n  \n    @Bean  \n    public UserDetailsService userDetailsService() {  \n        UserDetails user = User  \n                .withDefaultPasswordEncoder()  \n                .username(\"hs\")  \n                .password(\"123456\")  \n                .build();  \n        UserDetails admin = User  \n                .withDefaultPasswordEncoder()  \n                .username(\"admin\")  \n                .password(\"123456\")  \n                .build();  \n        return new InMemoryUserDetailsManager(user, admin);  \n    }  \n}\n```\n\n### BCrypt加密工具\n\n在我们上面配置用户信息的时候发现 withDefaultPasswordEncoder 是已经被弃用的，因为用这种方式来存储密码并不安全。\n\n这是因为SpringSecurity的密码校验建议使用加密算法将密码进行加密（或者说使用Hash处理）后将用户提供的密码与加密后的密码进行比较，而不是使用原文来进行匹配。\n\n因此，我们在配置用户信息的时候，可以使用官方提供的BCrypt加密工具：\n```java\npackage com.example.config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  \nimport org.springframework.security.core.userdetails.User;  \nimport org.springframework.security.core.userdetails.UserDetails;  \nimport org.springframework.security.core.userdetails.UserDetailsService;  \nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  \nimport org.springframework.security.crypto.password.PasswordEncoder;  \nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;  \n  \n@Configuration  \n@EnableWebSecurity // 开启 WebSecurity 相关功能  \npublic class SecurityConfiguration {  \n  \n    //这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择  \n    @Bean  \n    public PasswordEncoder passwordEncoder() {  \n        return new BCryptPasswordEncoder();  \n    }  \n  \n    @Bean  \n    public UserDetailsService userDetailsService(PasswordEncoder encoder) {  \n        UserDetails user = User  \n                .withUsername(\"hs\")  \n                .password(encoder.encode(\"123456\"))  \n                .build();  \n        System.out.println(encoder.encode(\"123456\"));  \n        UserDetails admin = User  \n                .withUsername(\"admin\")  \n                .password(encoder.encode(\"123456\"))  \n                .build();  \n        return new InMemoryUserDetailsManager(user, admin);  \n    }  \n}\n```\n\n替换后，首先最直观的体验是没有黄线警告了，然后我们正常在登录页面输入账号密码，我们在程序中可以插入print看看加密后的密码是怎么样的：\n![](p-2-1.png)\n\n第一次登录：$2a$10$PWLZcJqEFGmDWdz6OxQaLuTP/nwi2KEZ1TwVNN3GqcuVJkcELalAG\n第二次登录：$2a$10$BZpxArIf6yP.xfYVE7MywuPLH46m6UsmTWeOkd6RGDE0BoTnhSmE6\n\n我们会发现两次登录加密后的密码都不一样，这加密强在自己都不知道加密后是怎么样的\n\n### 登录\n\n从现在开始，我们的网站不需要再自己编写登录模块了，这里我们可以直接去掉，只留下主页面：\n```java\npackage com.example.controller;  \n  \nimport com.alibaba.fastjson2.JSONObject;  \nimport jakarta.servlet.http.HttpSession;  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.*;  \n  \n@Controller  \npublic class HelloController {  \n  \n    @ResponseBody  \n    @PostMapping(\"/pay\")  \n    public JSONObject pay(@RequestParam String account, HttpSession session) {  \n        JSONObject jsonObject = new JSONObject();  \n        if(session.getAttribute(\"login\") != null){  \n            System.out.println(\"转账给\" + account + \"成功，交易已完成\");  \n            jsonObject.put(\"success\", true);  \n        } else {  \n            System.out.println(\"转账给\" + account + \"未成功，用户未登录\");  \n            jsonObject.put(\"success\", false);  \n        }  \n        return jsonObject;  \n    }  \n  \n    //处理首页或是登录界面跳转  \n    @GetMapping(\"/\")  \n    public String index(){  \n        return \"index\";  \n    }  \n}\n```\n\n配置完成后即可通过上面配置的账号密码进行登录\n![](p-2.png)\n\n### 403\n\n但是在页面中会发现，我们所有的Post请求都被403了\n![](p-3.png)\n\n这是因为SpringSecurity自带了csrf防护，需求我们在POST请求中携带页面中的csrfToken才可以，否则一律进行拦截操作，这里我们可以将其嵌入到页面中，随便找一个地方添加以下内容：\n```html\n<input type=\"text\" th:id=\"${_csrf.getParameterName()}\" th:value=\"${_csrf.token}\" hidden>\n```\n\n目前完整index.html：\n```html\n<!DOCTYPE html>  \n<html lang=\"en\">  \n<head>  \n    <meta charset=\"UTF-8\">  \n    <title>白马银行 - 首页</title>  \n    <script src=\"https://unpkg.com/axios@1.1.2/dist/axios.min.js\"></script>  \n</head>  \n<body>  \n<div>  \n    <label>        转账账号：  \n        <input type=\"text\" id=\"account\"/>  \n    </label>    <input type=\"text\" th:id=\"${_csrf.getParameterName()}\" th:value=\"${_csrf.token}\" hidden>  \n    <button onclick=\"pay()\">立即转账</button>  \n</div>  \n</body>  \n</html>  \n  \n<script>  \n    function pay() {  \n        const account = document.getElementById(\"account\").value  \n        const _csrf = document.getElementById(\"_csrf\").value  \n        axios.post('/mvc/pay', { account: account, _csrf: _csrf }, {  \n            headers: {  \n                'Content-Type': 'application/x-www-form-urlencoded'  \n            }  \n        }).then(({data}) => {  \n            if(data.success)  \n                alert(\"转账成功\")  \n            else  \n                alert(\"转账失败\")  \n        })  \n    }  \n</script>\n```\n\n\n![](p-4.png)\n\n## 校验\n\n前面我们实现了登录用户功能，但我们会想到，一般来说，用户信息都是存在数据库里的，不可能一个个写在后configuration里面，所有我们需要使用到数据库\n\n### 搭建环境\n\n我们使用官方默认提供的可以直接使用的用户和权限表设计，根本不需要我们来建表，直接在DataGrip 中执行以下查询：\n```mysql\ncreate table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null);\ncreate table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username));\ncreate unique index ix_auth_username on authorities (username,authority);\n```\n\n然后我们需要导入所需的依赖\n```java\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.13</version>\n</dependency>\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>3.0.2</version>\n</dependency>\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <version>8.0.31</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>6.0.10</version>\n</dependency>\n```\n### 基于数据库校验\n\n```java\npackage com.example.config;  \n  \nimport org.apache.ibatis.datasource.pooled.PooledDataSource;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  \nimport org.springframework.security.core.userdetails.User;  \nimport org.springframework.security.core.userdetails.UserDetailsService;  \nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  \nimport org.springframework.security.crypto.password.PasswordEncoder;  \nimport org.springframework.security.provisioning.JdbcUserDetailsManager;  \n  \nimport javax.sql.DataSource;  \n  \n@Configuration  \n@EnableWebSecurity // 开启 WebSecurity 相关功能  \npublic class SecurityConfiguration {  \n  \n    //这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择  \n    @Bean  \n    public PasswordEncoder passwordEncoder() {  \n        return new BCryptPasswordEncoder();  \n    }  \n  \n    // 数据源  \n    @Bean  \n    public DataSource dataSource() {  \n        return new PooledDataSource(\"com.mysql.cj.jdbc.Driver\",  \n                \"jdbc:mysql://localhost:3306/springsecurity_study\",  \n                \"root\",  \n                \"Abc123\");  \n    }  \n  \n    @Bean  \n    public UserDetailsService userDetailsService(PasswordEncoder encoder, DataSource dataSource) {  \n        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);  \n        manager.createUser(User.withUsername(\"hs\")  \n                .password(encoder.encode(\"123456\"))  \n                .roles(\"USER\")  \n                .build());  \n        return manager;  \n    }  \n}\n```\n这里使用的是JDBC的JdbcUserDetailsManager，自由度不高，挺死板的\n重启tomcat可以看到两张表中已经自动添加好对应的数据了：\n![](p-5.png)\n![](p-5-2.png)\n\n### 修改密码\n\n通过使用UserDetailsManager对象，我们就能快速执行用户相关的管理操作，比如我们可以直接在网站上添加一个快速重置密码的接口，首先需要配置一下JdbcUserDetailsManager，为其添加一个AuthenticationManager用于原密码的校验：\n```java\n@Configuration  \n@EnableWebSecurity // 开启 WebSecurity 相关功能  \npublic class SecurityConfiguration {  \n  \n    ......\n  \n    //手动创建一个AuthenticationManager用于处理密码校验  \n    private AuthenticationManager authenticationManager(UserDetailsManager manager,  \n                                                        PasswordEncoder encoder){  \n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();  \n        provider.setUserDetailsService(manager);  \n        provider.setPasswordEncoder(encoder);  \n        return new ProviderManager(provider);  \n    }  \n  \n    @Bean  \n    public UserDetailsManager userDetailsService(DataSource dataSource,  \n                                                 PasswordEncoder encoder) throws Exception {  \n        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);  \n        //为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验  \n        manager.setAuthenticationManager(authenticationManager(manager, encoder));  \n        return manager;  \n    }  \n  \n}\n```\n\n编写接口\n```java\n@Controller  \npublic class HelloController {  \n  \n    @Resource  \n    UserDetailsManager manager;  \n  \n    @Resource  \n    PasswordEncoder encoder;  \n  \n    @ResponseBody  \n    @PostMapping(\"/change-password\")  \n    public JSONObject changePassword(@RequestParam String oldPassword,  \n                                     @RequestParam String newPassword) {  \n        manager.changePassword(oldPassword, encoder.encode(newPassword));  \n        JSONObject object = new JSONObject();  \n        object.put(\"success\", true);  \n        return object;  \n    }  \n  \n  ......\n}\n```\n\n最后在index.html中添加修改密码功能\n```html\n<div>\n    <label>\n        修改密码：\n        <input type=\"text\" id=\"oldPassword\" placeholder=\"旧密码\"/>\n        <input type=\"text\" id=\"newPassword\" placeholder=\"新密码\"/>\n    </label>\n    <button onclick=\"change()\">修改密码</button>\n</div>\n```\n\n```JavaScript\nfunction change() {\n    const oldPassword = document.getElementById(\"oldPassword\").value\n    const newPassword = document.getElementById(\"newPassword\").value\n    const csrf = document.getElementById(\"_csrf\").value\n    axios.post('/mvc/change-password', {\n        oldPassword: oldPassword,\n        newPassword: newPassword,\n        _csrf: csrf\n    }, {\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n    }).then(({data}) => {\n        alert(data.success ? \"密码修改成功\" : \"密码修改失败，请检查原密码是否正确\")\n    })\n}\n```\n这种方式虽然能够完成我们所需要的功能，但是太麻烦了，不适合在实际开发中使用。\n\n### 自定义校验\n\n大多数，我们并不会用SpringSecurity默认的验证来设计，而是采用自定义的表校验。\n\n首先自行在数据库中创建一个数据表，然后在项目中创建实体类\n```java\npackage com.example.entity;  \n  \nimport lombok.Data;  \n  \n@Data  \npublic class Account {  \n    int id;  \n    String username;  \n    String password;  \n}\n```\n\nService中调用数据库查询\n```java\npackage com.example.service;  \n  \nimport com.example.entity.Account;  \nimport com.example.mapper.UserMapper;  \nimport jakarta.annotation.Resource;  \nimport org.springframework.security.core.userdetails.User;  \nimport org.springframework.security.core.userdetails.UserDetails;  \nimport org.springframework.security.core.userdetails.UserDetailsService;  \nimport org.springframework.security.core.userdetails.UsernameNotFoundException;  \nimport org.springframework.stereotype.Service;  \n  \n@Service  \npublic class AuthorizeService implements UserDetailsService {  \n  \n    @Resource  \n    UserMapper mapper;  \n  \n    @Override  \n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  \n        Account account = mapper.findUserByName(username);  \n        if(account == null)  \n            throw new UsernameNotFoundException(\"用户名或密码错误\");  \n        return User  \n                .withUsername(account.getUsername())  \n                .password(account.getPassword())  \n                .build();  \n    }  \n}\n```\n\n根据用户名查询用户的Mapper接口：\n```java\npackage com.example.mapper;  \n  \nimport com.example.entity.Account;  \nimport org.apache.ibatis.annotations.Select;  \n  \npublic interface UserMapper {  \n    @Select(\"select * from springsecurity_study.user where username = #{username}\")  \n    Account findUserByName(String username);  \n}\n```\n\n别忘记在配置类WebConfiguration上添加相应的包扫描\n```java\n@Configuration  \n@EnableWebMvc  \n@ComponentScans({  \n        @ComponentScan(\"com.example.controller\"),  \n        @ComponentScan(\"com.example.service\")  \n})  \n@MapperScan(\"com.example.mapper\")\n```\n\n最后，在SecurityConfiguration里配置mybatis\n```java\n@Bean  \npublic SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){  \n    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();  \n    bean.setDataSource(dataSource);  \n    return bean;  \n}\n```\n\n**注意：如果运行失败，则降低依赖的版本\n\n## 其他配置\n\n### 自定义登录界面\n\n虽然SpringSecurity为我们提供了一个登录界面，但是很多情况下往往都是我们使用自定义的登录界面，这个时候就需要进行更多的配置了，我们还是以之前图书管理系统使用的模版为例。\n\n首先先修改Controller\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(\"/\")\n    public String index(){\n        return \"index\";\n    }\n\n    @GetMapping(\"/login\")\n    public String login(){\n        return \"login\";\n    }\n}\n```\n\n不过现在依然是默认进入到SpringSecurity默认的登录界面，现在我们来配置自定义的登录界面，将我们的前端模版中的登录页面作为SpringSecurity的默认登录界面。\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration {\n\n  \t...\n\t@Bean  \n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {  \n\t    return http  \n\t            //以下是验证请求拦截和放行配置  \n\t            .authorizeHttpRequests(auth -> {  \n\t                auth.requestMatchers(new AntPathRequestMatcher(\"/static/**\"));//静态资源放行  \n\t                auth.anyRequest().authenticated();    //将所有请求全部拦截，一律需要验证  \n\t            })  \n\t            //以下是表单登录相关配置  \n\t            .formLogin(conf -> {  \n\t                conf.loginPage(\"/login\");   //将登录页设置为我们自己的登录页面  \n\t                conf.loginProcessingUrl(\"/doLogin\"); //登录表单提交的地址，可以自定义  \n\t                conf.defaultSuccessUrl(\"/\");   //登录成功后跳转的页面  \n\t                conf.permitAll();    //将登录相关的地址放行，否则未登录的用户连登录界面都进不去  \n\t                //用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求  \n\t                conf.usernameParameter(\"username\");  \n\t                conf.passwordParameter(\"password\");  \n\t            })  \n\t            .build();  \n\t}\n\n```\n\n需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为`/login`，登陆请求地址为`/doLogin`，登陆页面我们刚刚已经自己编写Controller来实现了，登陆请求提交处理由SpringSecurity提供，只需要写路径就可以了。\n\n**如果页面加载失败没有格式，记得查看是不是没有给静态资源放行\n```java\n.authorizeHttpRequests(auth -> {\n      auth.requestMatchers(\"/static/**\").permitAll();   //将所有的静态资源放行，一定要添加在全部请求拦截之前\n      auth.anyRequest().authenticated();    //将所有请求全部拦截，一律需要验证\n})\n\n```\n\n### 登出按钮和关闭scrf\n```java\n.logout(conf -> {  \n    conf.logoutUrl(\"/doLogout\");  \n    conf.logoutSuccessUrl(\"/login\");  \n    conf.permitAll();  \n})  \n..csrf(AbstractHttpConfigurer::disable)\n```\n\n### 记住我\n\n之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦\n\nSpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。**记得修改前端页面中的表单。\n```java\n.rememberMe(conf -> {  \n    // conf.alwaysRemember(true);//无论点不点“记住我”，都记住用户  \n    // conf.rememberMeParameter(\"remember-me\");// 记住我表单字段，默认就是这个，可以不配置  \n    // conf.rememberMeCookieName(\"xxxx\");// 记住我cookie名称，默认就是这个，可以不配置  \n})\n```\n\n\n\n这个Cookie信息的过期时间并不是仅会话，而是默认保存一段时间，当然，由于记住我信息是存放在内存中的，我们需要保证服务器一直处于运行状态，如果关闭服务器的话，记住我信息会全部丢失，因此，如果我们希望记住我能够一直持久化保存，我们就需要进一步进行配置。我们需要创建一个基于JDBC的TokenRepository实现\n```java\n@Bean\npublic PersistentTokenRepository tokenRepository(DataSource dataSource){\n    JdbcTokenRepositoryImpl repository = new JdbcTokenRepositoryImpl();\n  \t//在启动时自动在数据库中创建存储记住我信息的表，仅第一次需要，后续不需要\n    repository.setCreateTableOnStartup(true);\n    repository.setDataSource(dataSource);\n    return repository;\n}\n```\n\n设置持久化存储时间\n```java\n.rememberMe(conf -> {\n     conf.rememberMeParameter(\"remember-me\");\n     conf.tokenRepository(repository);      //设置刚刚的记住我持久化存储库\n     conf.tokenValiditySeconds(60 * 60 * 24 * 7);   //设置记住我有效时间为7天\n})\n```\n\n## 授权\n\n用户登录后，可能会根据用户当前是身份进行角色划分，每个角色执行不同的功能。\n\nSpringSecurity为我们提供了两种授权方式：\n\n- 基于权限的授权：只要拥有某权限的用户，就可以访问某个路径。\n- 基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径。\n\n### 基于角色授权\n\n#### 配置开发\n\n现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。\n\n首先先修改数据库中的字段，添加一个role字段，接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：\n```java\n.authorizeHttpRequests(auth -> {\n    //静态资源依然全部可以访问\n    auth.requestMatchers(\"/static/**\").permitAll();\n    //只有具有以下角色的用户才能访问路径\"/\"\n    auth.requestMatchers(\"/\").hasAnyRole(\"user\", \"admin\");\n    //其他所有路径必须角色为admin才能访问\n    auth.anyRequest().hasRole(\"admin\");\n})\n```\n\n修改实体类：\n```java\n@Data\npublic class Account {\n    int id;\n    String username;\n    String password;\n    String role;\n}\n```\n\n修改我们之前写的获取用户信息：\n```java\n @Override\npublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n    Account account = mapper.findUserByName(username);\n    if(account == null)\n        throw new UsernameNotFoundException(\"用户名或密码错误\");\n    return User\n            .withUsername(username)\n            .password(account.getPassword())\n            .roles(account.getRole())   //添加角色，一个用户可以有一个或多个角色\n            .build();\n}\n```\n\n最后可以实验，只有admin可以访问其他页面，其他用户只能访问index\n\n### 基于权限授权\n\n基于权限的授权与角色类似，需要以`hasAnyAuthority`或`hasAuthority`进行判断：\n```java\n.authorizeHttpRequests(auth -> {\n    //静态资源依然全部可以访问\n    auth.requestMatchers(\"/static/**\").permitAll();\n    //基于权限和基于角色其实差别并不大，使用方式是相同的\n    auth.anyRequest().hasAnyAuthority(\"page:index\");\n})\n```\n\n这里是index页面运行所有用户访问\n\n### 注解开发\n\n首先需要在配置类（这里是在MVC的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由MVC配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：\n```java\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity   //开启方法安全校验\npublic class SecurityConfiguration {\n\t...\n}\n```\n\n现在就可以在想要进行权限校验的方法上添加注解了，通过添加`@PreAuthorize`注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。\n```java\n@PreAuthorize(\"hasAnyRole('user', ''admin)\")\n@GetMapping(\"/\")  \npublic String index(){  \n    return \"index\";  \n}\n```\n\n同样的还有`@PostAuthorize`注解，但是它是在方法执行之后再进行拦截：\n```java\n@PostAuthorize(\"hasRole('user')\")\n@RequestMapping(\"/\")\npublic String index(){\n    System.out.println(\"执行了\");\n    return \"index\";\n}\n```\n\n除了Controller以外，只要是被Spring托管的Bean都可以使用注解形式来控制权限，可以在任意方法上添加这个注解，只要不具备表达式中指定的访问权限，就无法执行方法并且放回403页面。\n\n# 固定模板(终)\n\nMvcConfiguration\n```java\npackage com.example.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport org.thymeleaf.spring6.SpringTemplateEngine;\nimport org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver;\nimport org.thymeleaf.spring6.view.ThymeleafViewResolver;\nimport org.thymeleaf.templateresolver.ITemplateResolver;\n\n@EnableWebMvc\n@Configuration\npublic class MvcConfiguration implements WebMvcConfigurer {\n    @Bean\n    public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine){\n        ThymeleafViewResolver resolver = new ThymeleafViewResolver();\n        resolver.setOrder(1);   //可以存在多个视图解析器，并且可以为他们设定解析顺序\n        resolver.setCharacterEncoding(\"UTF-8\");   //编码格式是重中之重\n        resolver.setTemplateEngine(springTemplateEngine);   //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎\n        return resolver;\n    }\n\n    //配置模板解析器\n    @Bean\n    public SpringResourceTemplateResolver templateResolver(){\n        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();\n        resolver.setSuffix(\".html\");   //需要解析的后缀名称\n        resolver.setPrefix(\"classpath:/templates/\");   //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀\n        resolver.setCharacterEncoding(\"UTF-8\");\n        return resolver;\n    }\n\n    //配置模板引擎Bean\n    @Bean\n    public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver){\n        SpringTemplateEngine engine = new SpringTemplateEngine();\n        engine.setTemplateResolver(resolver);   //模板解析器，默认即可\n        return engine;\n    }\n\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer){\n        configurer.enable();   //开启默认Servlet处理\n    }\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/static/**\").addResourceLocations(\"classpath:/static/\");\n    }\n}\n\n```"},{"title":"[object Object]","url":"/2024/12/20/articles/模板/123/"},{"title":"SpringFramework学习笔记","url":"/2024/12/20/articles/Spring/SpringLeaning/","content":"## 所需基本依赖\n\n```xml\n<dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>6.1.12</version>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>6.1.12</version>\n        </dependency>\n    </dependencies>\n```\n# 配置文件注册bean\n\n## 配置文件基础模板\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xmlns:context=\"http://www.springframework.org/schema/context\"  \n       xmlns:aop=\"http://www.springframework.org/schema/aop\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n       https://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n</beans>\n```\n\n- 使用配置文件注册一个bean最简单的方式，参数为 null\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\"/>  \n```\n\n- 如果 bean 需要传入参数，并且希望是通过有参构造来创建\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\">  \n    <constructor-arg name=\"message\" value=\"Hello World!\"/>\n</bean>\n```\n\n- 如果bean需要传入参数，并且希望是通过无参构造来创建\n- property 里的参数同上\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\">  \n    <property name=\"message\" value=\"Hello World!\"/>\n</bean>\n```\n\n## 关于配置文件注册bean\n- 赋值的原理是通过类中的set注入\n- id 相当于一个变量名，class 是类文件路径来源，还可以加个 name 作为 别名，注意 ==id 开头小写==\n- 有参构造和无参构造中的 name 是参数名， value 是默认传入的值\n- ==constructor-arg通过有参构造创建，创建对象的同时赋值==  \n- ==property通过无参构造创建，创建对象后，再通过set方法赋值==\n\n## 导入其他配置文件里的内容\n```xml\n<import resource=\"其他Spring配置文件.xml\"/>\n```\n导入的配置文件和本身共有注册 bean，优先用自己的\n## 赋值方法\n\n### 1、下标赋值\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\">  \n    <constructor-arg index=\"0\" value=\"Hello World!\"/>\n</bean>\n```\n\n### 2、通过类型赋值\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\">  \n    <constructor-arg type=\"java.lang.String\" value=\"Hello World!\"/></bean>\n```\n缺陷：\n### 3、通过参数名赋值\n```xml\n<bean id=\"hello\" class=\"org.example.pojo.HelloWorld\">  \n    <constructor-arg name=\"message\" value=\"Hello World!\"/>\n</bean>\n```\n\n## 获取bean\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"Spring配置文件.xml\");\n类 变量名 = context.getBean(\"beanID\", 类.class);\n```\n\n# Autowired\n\n自动装填\n@Autowired 先判断byType，再判断byName\n```java\npublic class People {  \n    // 等价于@Nullable，对象可以为null  \n    @Autowired(required = false)  \n    private Cat cat;  \n    @Autowired  \n    // @Autowired 先判断byType，再判断byName  \n    @Qualifier(value = \"dog\")  \n    // 如果自动装配的环境比较复杂，无法通过一个@Autowired完成时，就要使用@Qualifer(value = \"***\")指定bean名  \n    private Dog dog;  \n    private String name;  \n}\n```\n\n## 按照原本的配置方式\n\n```xml\n<bean id=\"people\" class=\"org.example.pojo.People\">\n        <property name=\"cat\" ref=\"cat\"/>\n        <property name=\"dog\" ref=\"dog\"/>\n        <property name=\"name\" value=\"呵帅\"/>\n    </bean>\n```\n\n## 使用Autowired自动装配\n\n### 开启注解的支持\n```xml\n<context:annotation-config/>\n```\n\n### 注册bean\n```xml\n<bean id=\"people\" class=\"org.example.pojo.People\" autowire=\"byName\">  \n    <property name=\"name\" value=\"呵帅\"/>  \n</bean>\n```\n\n我们使用完Autowired自动装配后，就可以不在配置文件里面配置参数对象\n但是有几点需要注意：\n- byName:按照属性名自动装配，和对象中set注入方法中的属性名一致  \n- byType:按照属性类型自动装配，和对象中的set方法里的属性类型一致\n- 使用byType必须保证类型全局唯一，否则会报错  \n- 使用byName必须保证属性名全局唯一，否则会报错\n\n### 修改自动装配方式\n```xml\n<bean id=\"people\" class=\"org.example.pojo.People\" autowire=\"byName\">  \n    <property name=\"name\" value=\"呵帅\"/>  \n</bean>\n```\n把 autowire 里面的参数修改成 byName 或者 byType 即可，默认为 byType\n\n# 依赖注入DI（Dependecy Injection）\n\n- **依赖注入是从应用程序的角度在描述，应用程序依赖容器创建并注入它所需要的外部资源**\n\n## 注入方式\n\n- **第一种，普通值注入，value\n```xml\n<property name=\"name\" value=\"John\"/>\n```\n\n- **第二种，引用注入，ref\n```xml\n<property name=\"address\" ref=\"address\"/>\n```\n\n- **第三种，数组注入，array\n```xml\n<property name=\"friends\" >\n     <array>\n        <value>Jane</value>\n        <value>Tom</value>\n        <value>Mary</value>\n    </array>\n</property>\n```\n\n- **第四种，键值对，map\n```xml\n<property name=\"cards\">\n    <map>\n        <entry key=\"身份证\" value=\"123456789012345678\"/>\n    <entry key=\"银行卡\" value=\"987654321098765432\"/>\n\t    <entry key=\"信用卡\" value=\"54444\"/>\n\t</map>\n</property>\n```\n\n- **第五种，list注入，list\n\n```xml\n<property name=\"courses\">\n            <list>\n                <value>Java</value>\n                <value>Python</value>\n                <value>C++</value>\n            </list>\n        </property>\n```\n\n- **第六种，set注入，set\n\n```xml\n<property name=\"interests\">\n            <set>\n                <value>篮球</value>\n                <value>足球</value>\n                <value>乒乓球</value>\n            </set>\n        </property>\n```\n\n## 命名空间\n\n### P 命名空间\n\n- **spring中的p命名空间就是为了更加方便的使用set方法注入属性内容，可以直接注入属性值，property\n- 首先我们需要引入对应这个p命名空间的xml约束\n```xml\nxmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n举个例子\n```java\npublic class User {\n    private String name;\n    private int age;\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n按照我们原来的写法应该是这么写\n\n```xml\n<bean id=\"User\" class=\"org.example.pojo.User\">\n\t<property name=\"age\" value=\"18\"/>\n\t<property name=\"name\" value=\"呵帅\">\n</bean>\n```\n\n改用P命名空间后是这样\n\n```xml\n<bean id=\"user\" class=\"org.example.pojo.User\" p:name=\"呵帅\" p:age=\"18\" scope=\"singleton\"/>\n```\n- 设置代理模式：scope，默认scope是singleton单例模式\n- 单例模式只允许创建一个实例，后续通过id获取的都是同一个实例\n- 原型模式prototype，允许创建多个实例，每次获取都是新的实例\n\n### C 命名空间\n\n- **spring中的c命名空间就是为了更加方便的使用有参构造方法注入，通过构造器注入，constructor-arg\n- c命名空间注入，通过构造器注入，constructor-arg\n- 首先我们需要引入对应这个p命名空间的xml约束\n```xml\nxmlns:c=\"http://www.springframework.org/schema/c\"\n```\n\n- **通过使用名称的方式\n```xml\n<bean id=\"user2\" class=\"org.example.pojo.User\" c:name=\"呵帅2\" c:age=\"18\" scope=\"prototype\"/>\n```\n\n- **通过使用索引的方式\n```xml\n<bean id=\"user2\" class=\"org.example.pojo.User\" c:_0=\"呵帅2\" c:_1=\"18\" scope=\"prototype\"/>\n```\n\n# mybatis\n\n\n- DataSource：使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid这是使用Spring提供的JDBC：org.springframework.jdbc.datasourceDataSource\n- 使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid这是使用Spring提供的JDBC：org.springframework.jdbc.datasource\n\n## 添加maven\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.27</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.7</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.13.RELEASE</version>\n        </dependency>\n\n        <!--Spring操作数据库还需要一个spring-jdbc的依赖-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.13.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>3.0.4</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.36</version>\n        </dependency>\n\n    </dependencies>\n```\n\n## 配置文件mybatis\n\n需要使用的文件\n![](p-1.png)\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xmlns:aop=\"http://www.springframework.org/schema/aop\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n       http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\">  \n  \n    <!--DataSource：使用Spring的数据源代替mybatis的配置 c3p0 dbcp druid    这是使用Spring提供的JDBC：org.springframework.jdbc.datasource  \n    -->    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">  \n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>  \n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis_lean\"/>  \n        <property name=\"username\" value=\"root\"/>  \n        <property name=\"password\" value=\"Abc123\"/>  \n    </bean>  \n    <!--sqlSessionFactory-->  \n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">  \n        <property name=\"dataSource\" ref=\"dataSource\"/>  \n        <!--绑定mybatis配置文件-->  \n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>  \n        <property name=\"mapperLocations\" value=\"classpath:org/example/mapper/*.xml\"/>  \n    </bean>  \n    <!--SqlSessionTemplate：就是我们之前使用的sqlSession   Template：模板-->  \n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">  \n        <!--只能使用构造器注入，这是因为没有set方法-->  \n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>  \n    </bean>  \n</beans>\n```\n\nresource/applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xmlns:aop=\"http://www.springframework.org/schema/aop\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n       http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\">  \n  \n    <import resource=\"spring-dao.xml\"/>  \n  \n    <bean id=\"userMapper\" class=\"org.example.mapper.UserMapperImpl\">  \n        <property name=\"sqlSession\" ref=\"sqlSession\"/>  \n    </bean>  \n    <bean id=\"userMapper2\" class=\"org.example.mapper.UserMapperImpl2\">  \n        <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>  \n    </bean></beans>\n```\n\norg/example/mapper/UserMapper.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE mapper  \n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"  \n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">  \n<mapper namespace=\"org.example.mapper.UserMapper\">  \n  \n    <select id=\"selectUser\" resultType=\"user\">  \n        SELECT * FROM mybatis_lean.user;  \n    </select>  \n  \n    <insert id=\"addUser\" parameterType=\"user\">  \n        insert into mybatis_lean.user (id, name, pwd) values (#{id}, #{name}, #{pwd});  \n    </insert>  \n    <delete id=\"deleteUser\" parameterType=\"int\">  \n        delete from mybatis_lean.user where id = #{id};  \n    </delete>  \n  \n</mapper>\n```\n\n## 注解开发mybatis\n\n需要使用的文件\n\n![](p-2.png)\n\n可以清晰的看出，少了很多不必要的文件\n\n用类 MyConfiguration.class 文件代替配置文件 \n```java\npackage org.example;  \n  \nimport org.apache.ibatis.datasource.pooled.PooledDataSource;  \nimport org.mybatis.spring.SqlSessionFactoryBean;  \nimport org.mybatis.spring.annotation.MapperScan;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \nimport javax.sql.DataSource;  \n  \n@Configuration  \n@ComponentScan(\"org.example.service\")  \n@MapperScan(\"org.example.mapper\")  \npublic class MyConfiguration {  \n  \n    @Bean  \n    public DataSource dataSource() {  \n        return new PooledDataSource(\"com.mysql.cj.jdbc.Driver\", \"jdbc:mysql://localhost:3306/mybatis_lean\", \"root\", \"Abc123\");  \n  \n    }  \n  \n    @Bean  \n    public SqlSessionFactoryBean sqlSessionFactoryBean() {  \n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();  \n        bean.setDataSource(dataSource());  \n        return bean;  \n    }  \n  \n}\n```\n\nmapper 层接口\n```java\npackage org.example.mapper;  \n  \nimport org.apache.ibatis.annotations.Delete;  \nimport org.apache.ibatis.annotations.Insert;  \nimport org.apache.ibatis.annotations.Select;  \nimport org.example.User;  \n  \nimport java.util.List;  \n  \npublic interface UserMapper {  \n    @Select(\"select * from user\")  \n    public List<User> selectUser();  \n    @Insert(\"insert into user(id, name, pwd) VALUES(#{id}, #{name}, #{pwd})\")  \n    public int addUser(User user);  \n    @Delete(\"delete from user where id=#{id}\")  \n    public int deleteUser(int id);  \n}\n```\n\nservice 层接口\n```java\npackage org.example.service;  \n  \nimport org.example.User;  \n  \nimport java.util.List;  \n  \npublic interface UserService {  \n    public List<User> selectUser();  \n    public int addUser(User user);  \n    public int deleteUser(int id);  \n}\n```\n\nservice 层实现类\n```java\npackage org.example.service;  \n  \nimport org.example.User;  \nimport org.example.mapper.UserMapper;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.stereotype.Service;  \n  \nimport java.util.List;  \n  \n@Service  \npublic class UserServiceImpl implements UserService{  \n  \n    @Autowired  \n    UserMapper mapper;  \n  \n    @Override  \n    public List<User> selectUser() {  \n        return mapper.selectUser();  \n    }  \n  \n    @Override  \n    public int addUser(User user) {  \n        return mapper.addUser(user);  \n    }  \n  \n    @Override  \n    public int deleteUser(int id) {  \n        return mapper.deleteUser(id);  \n    }  \n}\n```\n\n# AOP\n\n简单来说就是就是在运行期间加些事件进去\n\n## 方式一：使用原生的Spring API接口\n\n- **配置aop：需要导入aop的命名空间\n\n```xml\n<aop:config>  \n    <!--配置切入点  expression：表达式，execution(要执行的位置 修饰词 返回值，列名 方法名 参数)-->  \n    <aop:pointcut id=\"pointcut\" expression=\"execution(* org.example.service..userServiceImpl.*(..))\"/>  \n  \n    <!--执行环绕增强-->  \n    <!--相当于将log这个类切入到pointcut上-->  \n    <aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/>  \n    <aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/>  \n</aop:config>\n```\n\n实现 AfterReturningAdvice\n- 在方法执行后运行\n```java\npackage org.example.Log;  \n  \nimport org.springframework.aop.AfterReturningAdvice;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class AfterLog implements AfterReturningAdvice {  \n    @Override  \n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {  \n        System.out.println(\"执行力\" + method.getName() + \"方法后，返回值为：\" + returnValue);  \n    }  \n}\n```\n\n实现 MethodBeforeAdvice\n- 在方法执行前运行\n```java\npackage org.example.Log;  \n  \nimport org.springframework.aop.MethodBeforeAdvice;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class log implements MethodBeforeAdvice {  \n    @Override  \n    // method：要执行的目标对象的方法  \n    // args：目标对象方法的参数  \n    // target：目标对象  \n    public void before(Method method, Object[] args, Object target) throws Throwable {  \n        System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被执行了\");  \n  \n    }  \n}\n```\n\n## 方式二：自定义类\n\n```xml\n<bean id=\"diy\" class=\"org.example.diy.DiyPointCut\"/>\n<aop:config>  \n    <!--自定义切面，ref 要引用的类-->  \n    <aop:aspect ref=\"diy\">  \n        <!--切入点-->  \n        <aop:pointcut id=\"pointcut\" expression=\"execution(* org.example.service.userServiceImpl.*(..))\"/>  \n        <!--通知-->  \n        <aop:before method=\"before\" pointcut-ref=\"pointcut\"/>  \n        <aop:after method=\"after\" pointcut-ref=\"pointcut\"/>  \n  \n    </aop:aspect>  \n</aop:config>\n```\n\n自定义的类\n```java\npackage org.example.diy;  \n  \npublic class DiyPointCut {  \n  \n    public void before() {  \n        System.out.println(\"==========方法执行前===========\");  \n    }  \n  \n    public void after() {  \n        System.out.println(\"==========方法执行后===========\");  \n  \n    }  \n}\n```\n\n## 方式三：使用注解开发\n\n- 开启注解支持  JDK（默认 expose-proxy=\"false\"）  cglib（expose-proxy=\"true\"）\n\n```xml\n<aop:aspectj-autoproxy expose-proxy=\"false\"/>\n```\n\n```java\npackage org.example.diy;  \n  \nimport org.aspectj.lang.ProceedingJoinPoint;  \nimport org.aspectj.lang.annotation.After;  \nimport org.aspectj.lang.annotation.Around;  \nimport org.aspectj.lang.annotation.Aspect;  \nimport org.aspectj.lang.annotation.Before;  \n  \n//使用注解方式实现AOP  \n  \n@Aspect // 标注这个类是一个切面  \npublic class AnnotationPointCut {  \n    @Before(\"execution(* org.example.service.userServiceImpl.*(..))\")  \n    public void before() {  \n        System.out.println(\"====方法执行前====\");  \n    }  \n  \n    @After(\"execution(* org.example.service.userServiceImpl.*(..))\")  \n    public void after() {  \n        System.out.println(\"====方法执行后====\");  \n    }  \n  \n    @Around(\"execution(* org.example.service.userServiceImpl.*(..))\")  \n    public void around(ProceedingJoinPoint pj) throws Throwable {  \n        System.out.println(\"方法执行前\");  \n  \n        // 执行方法  \n        pj.proceed();  \n  \n        System.out.println(\"方法执行后\");  \n    }  \n}\n```\n\n## 调用运行\n```java\nimport org.example.service.userService;  \nimport org.example.service.userServiceImpl;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \npublic class MyTest {  \n    public static void main(String[] args) {  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");  \n        //动态代理代理的是接口  \n        userService userService = context.getBean(\"userService\", userService.class);  \n  \n        userService.add();  \n        userService.select();  \n    }  \n}\n```"},{"url":"/2024/10/19/hello-world/","content":"---\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"url":"/2024/10/06/articles/Mybatis/test2/","content":"# Mybatis的小笔记\n## association 与 collection\n### association\n用于一对一或多对一，当一个对象包含另一个对象作为其属性时，可以使用association\n例如：一个User类有一个Address类的属性，表示用户有一个地址\n\n### collection\n用于一对多，当一个对象包含多个相同类型的对象作为其属性时，可以使用collection\n例如：一个User类有一个Order列表的属性，表示一个用户可以有多个订单\n\n## javaType 与 ofType\n在MyBatis的映射文件中，javaType和ofType是两个经常与association和collection元素一起使用的属性，它们用于指定映射的目标类型，但它们的使用场景和含义有所不同。\n\njavaType：用来指定实体类（JavaBean）中属性的类型\nofType：用来指定映射容器里面实体类（JavaBean）中的类型，泛型中的约束类型\n\n"},{"title":"Mybatis学习记录","url":"/2024/09/20/articles/Mybatis/Mybatis/","content":"# Mybatis\n## 简介\nMybatis是一个持久层的框架，支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。可以使用XML或注解来配置和映射原始类型、接口和Java对象作为数据库中的记录。\n\n## 下载\n帮助文档\n```\nhttps://mybatis.org/mybatis-3/zh_CN/index.html\n```\n1、maven仓库\n```\n<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.16</version>\n</dependency>\n```\n2、GitHub\n```\nhttps://github.com/mybatis/mybatis-3/releases\n```\n\n## 搭建环境\n搭建好一个环境特别麻烦，做错一步就搭建失败报错\n跟着官方文档一步步来：https://mybatis.org/mybatis-3/zh_CN/getting-started.html\n### 1、搭建数据库\n```MySQL\ncreate database mybatis_lean;\n\nuse mybatis_lean;\n\ncreate table user(\n    id int not null primary key,\n    name varchar(20) default null,\n    pwd varchar(20) default null\n)engine=INNODB default charset=utf8;\n\ninsert into user values(1,'zhangsan','123456'),(2,'lisi','123456'),(3,'wangwu','123456');\n```\n### 2、新建一个maven项目\n![这是图片](imag\\p1.png \"Magic Gardens\")\n#### 导入依赖\n在`pom.xml`文件中导入所需要的依赖以及配置resource来防止资源导出失败\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>MybatisStudy</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>pom</packaging>\n    <modules>\n        <module>mybatisStudy-01</module>\n    </modules>\n\n    <!--    导入依赖-->\n    <dependencies>\n<!--        mysql-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n\n<!--        mybatis-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.2</version>\n        </dependency>\n\n<!--        junit-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                    <include>**/*.properties</include>\n                </includes>\n            </resource>\n\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                    <include>**/*.properties</include>\n                </includes>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n注意，在`.xml`文件中尽量不要使用中文注释\n### 3、在原项目下新建一个maven项目\n父级项目下创建一个子项目，子项目的`.xml`就不需要再配置了，方便我们以后使用\n#### 创建resource下的文件\n在子项目下的resource文件下创建一个`mybatis-config.xml`文件(叫什么无所谓，但但是尽量统一方便查看)\n配置文件：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"https://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n```\n把上面的 `${driver}、${url}、${username}、${password}` 都做修改\n```\ndriver配置驱动，一般为：com.mysql.jdbc.Driver\nurl数据库的url，在idea里面打开已经配置好的数据库查看\nusername：数据库的用户名\npassword：数据库的密码\n```\n#### 新建一个包\n新建三个包，包名分别为dao、utils、pojo\n##### utils包\n```\nhttps://mybatis.org/mybatis-3/zh_CN/getting-started.html\n原文档的话：\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。\nSqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。\n而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration\n实例来构建出 SqlSessionFactory 实例。\n```\n在包内新建一个名为 `MybatisUtils` 的java类，用来获取SqlSessionFactory\n```java\npackage org.example.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class MybatisUtils {\n    private static SqlSessionFactory sqlSessionFactory;\n        //获取sqlSessionFactory对象\n    static {\n        try {\n            // 没有解析，背就行了\n            // 死代码\n            String resource = \"mybatis-config.xml\";\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    // 获取SqlSession\n    public static SqlSession getSqlSession() {\n        return sqlSessionFactory.openSession();\n    }\n}\n```\n##### pojo包\n编写一个实体类的对象user\n```java\npackage org.example.pojo;\n\npublic class User {\n    private int id;\n    private String name;\n    private String pwd;\n\n    public User() {\n    }\n\n    public User(int id, String name, String pwd) {\n        this.id = id;\n        this.name = name;\n        this.pwd = pwd;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPwd() {\n        return pwd;\n    }\n\n    public void setPwd(String pwd) {\n        this.pwd = pwd;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", pwd='\" + pwd + '\\'' +\n                '}';\n    }\n}\n```\n##### dao包\n在dao包下新建一个接口UserDao\n```java\npackage org.example.Dao;\n\nimport org.example.pojo.User;\n\nimport java.util.List;\n\npublic interface UserDao {\n    List<User> getUserList();\n}\n```\n在dao包下新建一个`UserMapper.xml`\n配置User的Mapper\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"org.example.Dao.UserDao\">\n    <select id=\"getUserList\" resultType=\"org.example.pojo.User\">\n        select * from mybatis_lean.user\n    </select>\n</mapper>\n```\n\n## 运行\n搭建完以上步骤后，在test文件夹下新建一个 `UserDaoTest` Java类文件\n```java\npackage org.example.dao;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.example.Dao.UserDao;\nimport org.example.pojo.User;\nimport org.example.utils.MybatisUtils;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class UserDaoTest {\n\n    @Test\n    public void test() {\n\n        // 获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserDao mapper = sqlSession.getMapper(UserDao.class);\n        List<User> userList = mapper.getUserList();\n\n        for (User user : userList) {\n            System.out.println(user);\n        }\n        sqlSession.close();\n    }\n}\n```\n运行结果：\n![这是图片](imag\\p2.png \"Magic Gardens\")\ntarget文件夹是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。\n运行成功后查看左边的target文件下的`classes`文件夹，里面的内容与你项目的内容一致\n\n## 增删改查\n添加增删改查就在我们搭建的环境基础下改几个地方就行\n\n首先来看Dao下的配置文件`UserMapper.xml`\n```\n在mapper标签里面有这么几个参数:\n    namespace：指的是方法所在的接口包名\n    id：所调用的方法名\n    resultType：方法返回的类型\n    parameterType：方法参数的类型\n```\n![这是图片](imag\\p3.png \"Magic Gardens\")\n用select标签标起来的就是我们所需要的sql命令\n添加新的sql命令时，我们先需要在`UserDao`接口上新增方法，然后在配置文件里面的mapper标签里使用select标签，id换成新的方法名，resultType换成返回的参数，parameterType设置成方法参数的类型\n如果没有参数和返回值resultType和parameterType可以不写\n### 样例：查\n首先在接口文件上填上方法\n```java\nUser getUserById(int id);\n```\n然后新增配置文件\nxml可以识别数据库里面的字段名，如果有参数我们使用`#{字段名}`\n```xml\n<select id=\"getUserById\" parameterType=\"int\" resultType=\"org.example.pojo.User\">\n        select * from mybatis_lean.user where id = #{id}\n    </select>\n```\n最后就可以在Test测试了，步骤和之前一样\n先用`MybatisUtils.getSqlSession`获取SqlSession，然后在获得接口`getMapper`，在mapper里面调用方法即可\n```java\npublic void updateUser(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n        UserDao mapper = sqlSession.getMapper(UserDao.class);\n        mapper.updateUser(new User(3, \"tom\", \"123123\"));\n\n        sqlSession.commit();\n        sqlSession.close();\n    }\n```\n\n### 增删改查代码\n查：getUserById\n增：insertUser\n删：deleteUser\n改：updateUser\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"org.example.Dao.UserDao\">\n    <select id=\"getUserList\" resultType=\"org.example.pojo.User\">\n        select * from mybatis_lean.user\n    </select>\n\n    <select id=\"getUserById\" parameterType=\"int\" resultType=\"org.example.pojo.User\">\n        select * from mybatis_lean.user where id = #{id}\n    </select>\n\n    <select id=\"insertUser\" parameterType=\"org.example.pojo.User\">\n        insert into mybatis_lean.user values (#{id}, #{name}, #{pwd})\n    </select>\n\n    <select id=\"deleteUser\" parameterType=\"int\">\n        delete from mybatis_lean.user where id = #{id}\n    </select>\n\n    <select id=\"updateUser\" parameterType=\"org.example.pojo.User\">\n        update mybatis_lean.user set name = #{name}, pwd = #{pwd} where id = #{id}\n    </select>\n</mapper>\n```\n注意：配置文件里面不要用中文\n\n接口文件：\n```java\npackage org.example.Dao;\n\nimport org.example.pojo.User;\n\nimport java.util.List;\n\npublic interface UserDao {\n    List<User> getUserList();\n    User getUserById(int id);\n    void insertUser(User user);\n\n    void deleteUser(int id);\n\n    void updateUser(User user);\n}\n```\n\n## 模糊匹配\n我们使用数据库大多数指令都是查询，但有时候我们会忘记我们查询目标的全称，这时候我们就可以使用模糊比配\n首先，模糊匹配有两种常用的通配符\"`%`\"和\"`_`\"\n```\n\"%\" 百分号通配符: 表示任何字符出现0次或者多次\n例如：%李%        # 查找带有\"李\"的字符串，无论\"李\"出现在字符串的哪里\n\"_\" 下划线通配符:表示只能匹配单个字符。当然，也可以使用多个\"_\"\n例如：李__        # 查找开头是\"李\"，长度为3的字符串\n```\n使用关键字`like`即为模糊匹配\n```java\nUser getUserLikeName(String value);\n```\n```xml\n<select id=\"getUserLikeName\" parameterType=\"String\" resultType=\"org.example.pojo.User\">\n        select * from mybatis_lean.user where name like \"%\"#{value}\"%\"\n</select>\n```\n使用模糊匹配时要注意防范[SQL注入](https://blog.csdn.net/weixin_45840241/article/details/139106947)\n\n## 配置解析\n### 核心配置文件\n一般用到mybatis的配置文件官方都建议命名为`mybatis-config.xml`，当然也可以不接受这个建议\n\n配置文件里面有一下几个组成部分\n```\nconfiguration（配置）\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n```\n先后顺序是：\nproperties，settings，typeAliases，typeHandlers，objectfactory，objectwrapperfactory，\nreflectorFactory，plugins，environments，databaseldProvider，mappers\n#### 事务管理器 transactionManager\n在 MyBatis 中有两种类型的事务管理器：JDBC 和 MANAGED(基本不用)\nMybatis 默认的事务管理器是 JDBC\n\nJDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交\n\nMANAGED - 等价于 EJB (Enterprise Java Beans)， 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）\n\n#### 数据源 dataSource\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n有三种内建的数据源类型：UNPOOLED、POOLED 和 JNDI\nMybatis默认数据源是POOLED\n\nPOOLED 可以理解成数据池，可以理解成 new 了一块空间出来，用完可以回收，即使数据传输完毕，这块空间也不会解散，只有等到代码跑完了才会自动解散。\nJNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用\n\n#### 属性\n我们可以通过 `properties` 属性来实现引用配置文件\n这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\n\n我们在 `resource` 文件夹下新建一个 `dp.properties` 文件，里面写入替换的值\n例如：\n```properties\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis_lean?allowPublicKeyRetrieval=true&useSSL=false&useUnicode=true&characteEncoding=UTF8\nusername=root\npassword=123456\n```\n然后回到 `mybatis-config.xml` 文件，编写 properties 标签\n```xml\n<properties resource=\"dp.properties\"/>\n```\n然后修改 environment \n```xml\n<environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${driver}\"/>\n                <property name=\"url\" value=\"${url}\"/>\n                <property name=\"username\" value=\"${username}\"/>\n                <property name=\"password\" value=\"${password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n```\n注意：properties 标签必须在 configuration 里的最上面，先解释 properties 标签\n\n当然，我们也可以在 mybatis-config.xml 里面改变值，但如果内部文件和外部文件都有动态配置的属性值，先运行内部的，后运行的外部会覆盖内部\n```xml\n<properties resource=\"dp.properties\">\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"123456\"/>\n</properties>\n```\n\n#### 类型别名 typeAliases\n类型别名可为 Java 类型设置一个缩写名字。它仅用于 XML 配置，意在降低冗余的全限定类名书写。\n在 configuration 的书写顺序为第三位\n例如：\n```\n<typeAliases>\n        <typeAlias alias=\"User\" type=\"org.example.pojo.User\"/>\n</typeAliases>\n上面这种配置可以让 org.example.pojo.User 替换成 User\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean\n<typeAliases>\n        <package name=\"org.example.pojo\"/>\n</typeAliases>\n如果我们指定的包名 org.example.pojo 中的 JavaBean 没有注释，会使用类名的首字母小写作\n为别名\n我们也可以作注释\n@Alias(\"hhhh\")\npublic class User {\n    ...\n}\n如上， hhhh 则作为此 JavaBean的类型别名\n```\n\n#### 映射器 mappers\n```\n方式一：\n<mappers>\n    <mapper resource=\"org/example/Dao/UserMapper.xml\"/\n</mappers>\n方式二：\n<mappers>\n    <mapper class=\"org.example.Dao.UserMapper\"/>\n</mappers>\n方式三：\n<mappers>\n    <package name=\"org.example.Dao\"/>\n</mappers>\n```\n\n### 作用域和生命周期\n![这是图片](imag\\p4.png \"Magic Gardens\")\nSqlSessionFactoryBuilder\nSqlSessionFactory 创建完 SqlSessionFactory 就不再需要它了。 因此最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\nSqlSessionFactory\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。因此 SqlSessionFactory 的最佳作用域是应用作用域。可以把 SqlSessionFactory 看作一个资源池，一直都存在，只需要创建 SqlSession 和回收 SqlSession。\n\nSqlSession\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。可以看作资源池里面的资源，每次用完都要被回收，以便于下次使用。\n\n### 结果映射 resultMap\nresultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作\n\n让我们想象一个场景，多个人做一个项目，当做 JavaBean 的人与做数据库的不是同一个人，在起名上有一定的不同，我们无法做到将 JavaBean 或者数据库的字段名修改，这时我们就可以使用 resultMap\n\n例如，我们数据库上有三个字段：\"id\",\"name\",\"pwd\"；JavaBean 中有三个参数：\"id\",\"name\",\"password\"，这时我们就不能用上面的 `resultType`\n我们在 mapper 标签里面加上：\n```\n<resultMap id=\"UserMap\" type=\"org.example.pojo.User2\">\n    <result property=\"id\" column=\"id\"/>\n    <result property=\"name\" column=\"name\"/>\n    <result property=\"password\" column=\"pwd\"/>\n</resultMap>\n```\n`column` 是数据库里面的字段名，`property` 是 JavaBean 里面的参数名，如果参数名和字段名相同时可以省略不写\n然后把 resultType 修改成 resultMap\n```\n<select id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\">\n    select * from mybatis_lean.user where id = #{id}\n</select>\n```\n\n## 日志\n### 日志工厂\n日志在我们平时运维或者查找报错中非常实用，我们只需要在日志中查看是哪部分出问题\n\n在官方文档中，我们可以查看到如何开启日志，以及日志的种类\n![这是图片](imag\\p5.png \"Magic Gardens\")\nSLF4J\nLOG4J（3.5.9 起废弃）\nLOG4J2\nJDK_LOGGING\nCOMMONS_LOGGING\nSTDOUT_LOGGING\nNO_LOGGING\n\n### STDOUT_LOGGING\nSTDOUT_LOGGING 是标准日志输出，不需要再注入其他依赖，直接就能跑起来\n\n在 setting 标签里面配置（注意 setting 的位置）\n```\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n配置好后运行代码\n![这是图片](imag\\p6.png \"Magic Gardens\")\n\n### Log4j\nLog4j 在2021年12月8号被爆出堪称 __史诗级核弹__ 漏洞，学习 Log4j 的原因很简单，因为使用的人多，例如 Apache Struts2、Apache Solr、Apache Druid、Apache Flink等，都用了 Log4j 或者 Log4j2\n\nLog4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，我们可以控制每条日志的输出格式；只需要通过一个配置文件就可以灵活的配置，而不需要修改任何代码\n\n第一步，先得导入 Log4j 的依赖\nhttps://mvnrepository.com/artifact/log4j/log4j/1.2.17\n```properties\n<!-- https://mvnrepository.com/artifact/log4j/log4j -->\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n第二步，创建 Log4j 的配置文件\n```properties\nlog4j.rootLogger=DEBUG,console,file\n\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/StudyLog4j.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n```\n\n第三步，生成 日志对象Logger，参数为当前类的 class 对象\n```java\nstatic Logger logger = Logger.getLogger(UserMapperTest.class);\n```\n\n第四步，使用 Log4j\n\n三个级别，info、debug 和 error\n```java\nlogger.info(\"info:测试使用Log4j记录日志\");\nlogger.debug(\"debug:测试使用Log4j记录日志\");\nlogger.error(\"error:测试使用Log4j记录日志\");\n```\n\n结果：\n![这是图片](imag\\p7.png \"Magic Gardens\")\n\n## 分页\n### limit 实现分页\n```\n语法：\nselect * from 表名 limit startIndex,pageSize;\n```\n\n与之前的一样，在 UserMapper 接口里面声明新方法\n```java\nList<User> getUserByLimit(Map<String, Integer> map);\n```\n然后再 UserMapper.xml 里定义\n```xml\n<select id=\"getUserByLimit\" parameterType=\"map\" resultType=\"org.example.pojo.User\">\n    select * from mybatis_lean.user limit #{startIndex},#{pageSize}\n</select>\n```\n\n最后就可以测试了\n```java\nSqlSession sqlSession = MybatisUtils.getSqlSession();\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"startIndex\", 0);\nmap.put(\"pageSize\", 2);\n\nList<User> userByLimit = mapper.getUserByLimit(map);\n\nfor (User user : userByLimit) {\n    System.out.println(user);\n}\n\nsqlSession.close();\n```\n\n### RowBounds 实现分页\nlimit 分页是物理分页，Rowbounds 分页是逻辑分页，Rowbounds 因为要把全部数据都跑一遍，效率比较慢，不推荐使用。\n\nRowbounds 可以通过 java 代码来实现\n\n第一步，在接口里声明\n```java\nList<User> getUserByRowBounds();\n```\n第二部，在 xml 文件里定义\n```xml\n<select id=\"getUserByRowBounds\" resultType=\"org.example.pojo.User\">\n    select * from mybatis_lean.user\n</select>\n```\n第三步，使用\n```java\n@Test\npublic void getUserByRowBounds(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    RowBounds rowBounds = new RowBounds(1, 2);\n\n    List<User> User = sqlSession.selectList(\"org.example.Dao.UserMapper.getUserByRowBounds\",null,rowBounds);\n    for (org.example.pojo.User user : User) {\n        System.out.println(user);\n    }\n\n    sqlSession.close();\n}\n```\n创建一个 RowBounds 对象时，两个参数分别为初始索引和长度\n\n### 插件实现分页\nhttps://pagehelper.github.io/#:~:text=MyBatis%20%E5%88%86%E9%A1%B5\n我们可以使用第三方插件进行分页，例如：PageHelper，这里不做过多的介绍，用到再了解。\n\n\n## 使用注解开发\nok，前面的配置文件编写已经特别熟练了\n但是，通通白学，接下来是特别简单，步骤没有这么繁琐的注解开发\n\n我们可以把配置文件删了，只需要一个接口文件，在接口文件里面声明的方法的头上写上注解\n```java\n@Select(\"select * from user\")\nList<User> getUser();\n```\n然后在类像之前一样里面正常使用，不需要搞配置文件\n```java\n@Test\npublic void testSelect() {\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    List<User> user = mapper.getUser();\n\n    for (User user1 : user) {\n        System.out.println(user1);\n    }\n\n    sqlSession.close();\n}\n```\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n\n### 用注解开发做增删改查\n只需要变动接口文件 UserMapper ，配置文件 `UserMapper.xml` 可以删去\n```java\n@Select(\"select * from user\")\nList<User> getUser();\n\n@Select(\"insert into user values(#{id},#{name},#{pwd})\")\nvoid insertUser(User user);\n\n@Select(\"delete from user where id=#{id}\")\nvoid deleteUser(@Param(\"id\") int id);\n\n@Select(\"update user set name=#{name},pwd=#{pwd} where id=#{id}\")\nvoid updateUser(User user);\n\n@Select(\"select * from user where id=#{id}\")\nUser getUserById(int id);\n```\n我们在删除方法 deleteUser 的参数框里写了一个 @Param(\"id\") ，当我们使用注解开发时，如果有基本类型参数，尽量在每一个参数前加上 @Param(\"\")\n\n以 deleteUser(@Param(\"id\") int id) 为例，如果我们把后面的 id 改成其他比如 id2 ，代码正常运行，但如果我们改 @Param(\"id\") 改成 为  @Param(\"id2\") 则会报错，这时因为我们在SQL中引用的就是 @Param(\"\") 中定义的属性名，外面的 id 变成一个形参，形参叫什么都无所谓\n\n如果把 @Select 改成其他，例如 @Update 代码，则需要手动提交\n或者我们在 MybatisUtils 类里面把\n```java\nopenSession里的参数填 true\nreturn sqlSessionFactory.openSession(true)\n\npublic static SqlSession getSqlSession() {\n        return sqlSessionFactory.openSession();\n}\n```\n\n## 联合查询\n### 多对一\n假设环境，我们希望查询所有学生的信息，包括学生元素下的老师信息（学生的老师）\n1、创建表\n```SQL\nCREATE TABLE `teacher` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师'); \n\nCREATE TABLE `student` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  `tid` INT(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fktid` (`tid`),\n  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); \nINSERT INTO student VALUES ('2', '小红', '1'); \nINSERT INTO student VALUES ('3', '小张', '1'); \nINSERT INTO student VALUES ('4', '小李', '1'); \nINSERT INTO student VALUES ('5', '小王', '1');\n```\n2、创建接口\n在 Dao 包下创建接口文件\n```java\npackage org.example.Dao;\n\nimport org.example.pojo.Student;\n\nimport java.util.List;\n\npublic interface StudentMapper {\n    List<Student> getStudent();\n}\n```\n\n\n3、配置文件\n在 resource 下创建一个文件，路径与接口文件路径一致\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"org.example.Dao.StudentMapper\">\n\n    <select id=\"getStudent\" resultMap=\"StudentTeacher\">\n        select * from mybatis_lean.student\n    </select>\n    \n    <resultMap id=\"StudentTeacher\" type=\"org.example.pojo.Student\">\n        <result property=\"id\" column=\"id\"/>\n        <result property=\"name\" column=\"name\"/>\n\n        <association property=\"teacher\" column=\"tid\" javaType=\"org.example.pojo.Teacher\" select=\"getTeacher\"/>\n    </resultMap>\n    \n    <select id=\"getTeacher\" resultType=\"org.example.pojo.Teacher\">\n        select * from mybatis_lean.teacher where id = #{tid}\n    </select>\n</mapper>\n```\nresultMap 是用来定义数据库查询结果到Java对象的映射关系\n如上：\n在 resultMap 里`association`的作用是通过 getTeacher 来筛选出老师，然后进行匹配\n\n运行结果：\n![这是图片](imag\\p8.png \"Magic Gardens\")\n\n### 一对多\n假设环境，我们希望查询所老师的信息，包括老师元素下的学生信息\n#### 按照结果嵌套\n```java\nList<Teacher> getTeachers(@Param(\"tid\") int id);\n```\n```xml\n<select id=\"getTeachers\" resultMap=\"TeacherStudent\">\n    select s.id sid, s.name sname, t.name tname, t.id tid\n    from mybatis_lean.student s, mybatis_lean.teacher t\n    where s.tid = t.id\n    and t.id = #{tid}\n</select>\n\n<resultMap id=\"TeacherStudent\" type=\"org.example.pojo.Teacher\">\n    <result property=\"id\" column=\"tid\"/>\n    <result property=\"name\" column=\"tname\"/>\n\n    <collection property=\"students\" ofType=\"org.example.pojo.Student\">\n        <result property=\"id\" column=\"sid\"/>\n        <result property=\"name\" column=\"sname\"/>\n        <result property=\"tid\" column=\"tid\"/>\n    </collection>\n</resultMap>\n```\n\n#### 按照查询嵌套\n```xml\n<select id=\"getTeachers\" resultMap=\"TeacherStudent\">\n    select * from mybatis_lean.teacher where id = #{tid}\n</select>\n\n<resultMap id=\"TeacherStudent\" type=\"org.example.pojo.Teacher\">\n    <collection property=\"students\" javaType=\"ArrayList\"\n     ofType=\"org.example.pojo.Student\" select=\"getStudentByTId\" column=\"id\"/>\n</resultMap>\n\n<select id=\"getStudentByTId\" resultType=\"org.example.pojo.Student\">\n    select * from mybatis_lean.student where id = #{tid}\n</select>\n```\n\n## 动态SQL\n动态SQL是指根据不同条件生成不同的SQL语句\n### 创建环境\n这里主要展示表格和 JavaBean 实体类\n```sql\nCREATE TABLE `blog`(\n`id` VARCHAR(50) NOT NULL COMMENT '博客id',\n`title` VARCHAR(100) NOT NULL COMMENT '博客标题',\n`author` VARCHAR(30) NOT NULL COMMENT '博客作者',\n`create_time` DATETIME NOT NULL COMMENT '创建时间',\n`views` INT(30) NOT NULL COMMENT '浏览量'\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n```\n```java\npublic Blog(String id, String title, String author, Date createTime, int views) {\n    this.id = id;\n    this.title = title;\n    this.author = author;\n    this.createTime = createTime;\n    this.views = views;\n}\n```\n### IF\n假设条件，以上面为例，我们需要用一条 SQL 语句来实现，如果我们传的参数有 title 或者 author ，则返回含有参数的数据，如果参数没有，则返回全部数据\n\n这时候，就体现到动态规划的好处了\n首先，我们先编写接口方法，我们需要拿一个 map 来装数据\n```java\nList<Blog> queryBlog(Map map);\n```\n然后就是最重要的配置文件了\n```xml\n<select id=\"queryBlog\" resultType=\"org.example.pojo.Blog\" parameterType=\"map\" >\n    select * from mybatis_lean.blog where 1=1\n    <if test=\"title != null\">\n        and title = #{title}\n    </if>\n    <if test=\"author != null\">\n        and author = #{author}\n    </if>\n</select>\n```\n如上所示，想要完成开头提到的需求，那我们必不可少的需要判断来处理 `<if test=\"\">` 这个当成固定格式就行了，因为那你每次使用 IF 的时候都少不了 `test=\"\"`\ntest 里面装的就是我们的判断条件了，当然，我们也可以嵌套判断\n\n为什么 where 后面要跟一个 `1=1` 呢，其实不跟也可以，但是我们需要在每一个 IF 判断里面的开头写上 where 那就显得太麻烦了，加上一个 `1=1` 也丝毫不会影响原来的语句\n\n### where\n或者，我们也可以使用 `<where>` 标签， `<where>` 标签可以自动检查后面跟随的子语句前有没有 AND 或者 OR，例如： \n```xml\n<select id=\"queryBlog\" resultType=\"org.example.pojo.Blog\" parameterType=\"map\" >\n    select * from mybatis_lean.blog where \n    <where>\n        <if test=\"title != null\">\n            title = #{title}\n        </if>\n        <if test=\"author != null\">\n            and author = #{author}\n        </if>\n    </where>\n</select>\n```\n如上，最理想的情况是第一个和第二个都满足，程序继续运行，但是，如果只满足第二个而不满足第一个，我们会发现 where 后面直接跟 and ，这怎么看都是错的，我们的 `<where>` 标签就可以判断后面的子语句前是否有 AND 或 OR ，如果发现及删去，如果 IF 一个都不满足，后面没有跟子语句了， `<where>` 标签就会把 where 删去\n\n### set\n`set` 标签和 `where` 标签差不多，但是可以每一个条件都满足， `set` 标签是用于 `update` 语句里面的，例如：\n```xml\n<update id=\"updateBlog\" parameterType=\"map\">\n    update mybatis_lean.blog\n    <set>\n        <if test=\"title != null\">\n            title = #{title},\n        </if>\n        <if test=\"author != null\">\n                author = #{author},\n        </if>\n    </set>\n    where id = #{id}\n</update>\n```\n我们需要更新当 `id` 等于我们所传的 `id` ，这时我们唯一一个需要确定的条件，标签里面的两个条件 `title` 和 `author` 不输入也不会报错\n`set` 标签主要的功能是如果有子语句，那么将会在最前面加上（或删除） `set` ，然后在每一个需要子语句加逗号的子语句后面加上（或删除）逗号\n\n\n### choose\nchoose 的选择是互斥的，满足了第一个就不会去看后面的判断\n\nchoose 与 when 和 otherwise 搭配\n当 when 条件满足时进入 when 里的子语句，如果有多个 when 都满足条件，只进入第一个，otherwise 是当所有 when 条件都没有满足时则进入，相当于是 Java 里 if 的 else\n\n假设，我们现在需要一个方法，当我们传的参数有 title 并且不为空，则从表格里查找出所在一行；如果没有传 title 而是传了 author ，我们也需要找出 author ；如果都没有传，我们需要把表格所有内容返回\n```xml\n<select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"org.example.pojo.Blog\">\n    select * from mybatis_lean.blog where\n    <choose>\n        <when test=\"title != null\">\n            title = #{title}\n        </when>\n        <when test=\"author != null\">\n            author = #{author}\n        </when>\n        <otherwise>\n            1=1\n        </otherwise>\n    </choose>\n</select>\n```\n\n### sql\n上面的配置文件里面，我们会发现有很多地方的有杂糅，每个标签里面都有相同的地方，为了减少代码杂糅，我们可以使用 `sql` 标签，把相同的地方提出来\n以上面为例，我们会发现 `if` 标签里面的 `title` 和 `author` ，我们使用的频率很大，那么我们就可以使用 `sql` 标签提出来 \n```xml\n<sql id=\"if-title-author\">\n    <if test=\"title != null\">\n        title = #{title}\n    </if>\n    <if test=\"author != null\">\n        and author = #{author}\n    </if>\n</sql>\n```\n提取后需要用 `include` 标签来使用\n```xml\n<select id=\"queryBlog\" resultType=\"org.example.pojo.Blog\" parameterType=\"map\" >\n    select * from mybatis_lean.blog\n    <where>\n        <include refid=\"if-title-author\"/>\n    </where>\n</select>\n```\n\n### foreach\n动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）\n![替代文字](\\imag\\p10.png \"可选的标题\")\n\n案例：我们现在需要一个方法，需要返回我们传的 ID 所对应的信息\n```xml\n<select id=\"queryBlogById\" resultType=\"org.example.pojo.Blog\" parameterType=\"map\">\n    select * from mybatis_lean.blog\n    <where>\n        <foreach collection=\"ids\" item=\"id\" open=\"(\" close=\")\" separator=\"or\">\n            id = #{id}\n        </foreach>\n    </where>\n</select>\n```\n\n## 缓存\nmybatis 为了提高数据库性能和减少数据压力提供一级缓存和二级缓存\n\n### 一级缓存\n一级缓存是 SqlSession 级别的缓存，作用域是同一个 SqlSession ，在同一个 sqlSession 中连续两次执行相同的sql语句，第一次执行完毕会将数据写到缓存，第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。\n\nMybatis默认开启一级缓存\n\n一级缓存只是相对于同一个 SqlSession 而言。所以在参数和 SQL 完全一样的情况下，我们使用同一个 SqlSession 对象调用一个 Mapper 方法，往往只执行一次 SQL ，因为使用 SelSession 第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。\n\n例如：\n```java\n// 通过ID来查询\nUser selectById(@Param(\"id\") int id);\n// 更新数据\nint updateUser(User user);\n```\n```java\nSqlSession sqlSession = MybatisUtils.getSqlSession();\n\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\nUser user = mapper.selectById(1);\nSystem.out.println(user);\n\nSystem.out.println(\"==============================\");\n\nUser user2 = mapper.selectById(1);\nSystem.out.println(user2);\n\nsqlSession.close();\n```\n![替代文字](\\imag\\p11.png \"可选的标题\")\n我们会发现，明明查询语句跑了两遍，但日志里面却只跑了一边，第二次进行查询语句的时候并没有想第一次一样在数据库中查找，而是第一次跑完的记录存在缓存里面，第二次直接在缓存里面读取\n\n样例二：\n我们在两次查询语句中插入一条修改语句，缓存是否还能够使用\n```java\nSqlSession sqlSession = MybatisUtils.getSqlSession();\n\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\nUser user = mapper.selectById(1);\nSystem.out.println(user);\n\nSystem.out.println(\"==============================\");\n\nmapper.updateUser(new User(5, \"Lily\", \"202020\"));\n\nSystem.out.println(\"==============================\");\n\nUser user2 = mapper.selectById(1);\nSystem.out.println(user2);\n\nsqlSession.close();\n```\n运行结果：\n![替代文字](\\imag\\p12.png \"可选的标题\")\n\n通过日志我们可得知，三条语句都进入了数据库中查找\n\n### 二级缓存\n二级缓存也叫全局缓存，二级缓存是基于 namespace ，一个命名空间对应着一个二级缓存\n开启二级缓存后，释放完一个 sqlsession 后，一级缓存将会存入二级缓存内，重新开启一个相同 mapper 将会读取二级缓存 \n\n1、开启全局缓存\n\n在 mybatis-config.xml 下的 setting 标签内加入\n```xml\n<setting name=\"cacheEnabled\" value=\"true\"/>\n```\n\n2、在 Mapper 文件里面开启\n```xml\n<cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/>\n```\n注：FIFO (first in first out)\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2024/09/14/articles/JavaScript/text/","content":"# JavaScript\n### 概述\n\nJavaScript是一门世界上流行的脚本编程语言，用来实现网页上的交互，实时更新内容等。\n\nJavaScript的创建者因不喜欢Java，只想应付公司的任务，因此只花了十天时间就把JavaScript创建出来了。\n\n## Hello World\n每个语言都有其独特之处，身边人也经常会开玩笑的说“我们精通各种语言的Hello World”。\n\nJavaScript和CSS一样，都可以直接在HTML文件里面搭个标签，在标签里面写语言。\n\n__方法一：内标签写__\n![这是一张图片](img\\p1.png \"可选的标题\")\n与Java相同，在写JavaScript时不要忘记每一行命令后的分号。\n注释也和Java中使用的一样。\n\n__方法二：外部引用__\n首先，先创建一个JavaScript文件，里面只需写需要的JavaScript语句，然后再在HTML文件中引入进来即可。\n注意，使用script标签必须成对出现，尽量不要用自闭合。\n![这是一张图片](img\\p3.png \"可选的标题\")\n\n运行结果：\n![这是一张图片](img\\p2.png \"可选的标题\")\n\n## 基础语法\nJavaScript和一门弱类型语言，跟python或者其他解释型语言一样，无需强调其变量类型。\n\n![这是一张图片](img\\p4.png \"可选的标题\")\n\nJavaScript语法与Java基本吻合，也是严格区分大小写，但JavaScript不强制限定语句末一定要使用分号，如果有两条语句，其中没有分号，则视为一条语句，一般使用上省略一两个分号对代码没有太大影响，但依然建议写上分号。\n\n#### 浏览器调试\n在浏览器上打开文件后，可以点击F12打开审查元素，在源代码那里可以看到自己的代码并进行调试。\n\n![这是一张图片](img\\p5.png \"可选的标题\")\n\n## 简单数据类型\n#### 变量\nJS和Java的命名规则一样，用字母数字下划线和``$``组成的变量名，不可以用数字开头，可以用中文。\n```\nvar 变量名 = 值\n```\n\n#### number\njs不区分整数和小数\n```\n123      //整数\n123.4    //小数\n-1.234   //负数\n1.23e4   //科学计数法\n除此之外还有\nNaN      //Not a number\nInfinity //表示无穷大，数据太大JavaScript处理不来\n```\n#### 比较运算符\n```\n=      //赋值\n==     //等于(类型不一样，值一样，判断为true)\n===    //绝对等于(类型一样，值一样，判断为true)\n一般情况下尽量使用绝对等于\n```\n上面提到的NaN与所有数值都不相等，包括自己，只能通过``isNaN``来判断NaN才为true\n![这是一张图片](img\\p6.png \"可选的标题\")\n\n尽量避免使用浮点数进行运算，存在精度丢失问题\n```\nconsole.log((1/3) === (1-2/3))\n答案为false\n但我们可以使用绝对值来比较\nMath.abs(1/3 - (1-2/3)) < 0.000000000001\n```\n\n#### Null和undefined\n```\nnull     //空\nundefined//未定义\n```\n\n#### 数组\n一般在Java中数组每个元素的类型必须一致，但在JS中可以不用\n```\nvar a = [1,2,3,4,'Hello',null,false];\n```\n数组越界会显示undefined\n\n#### 对象\n在Java中对象是new出来的，但在JS中生成或定义基本上都是使用var，每个属性之间使用逗号隔开，最后一个属性后不需要加逗号。\n\n对象是大括号，数组是中括号。\n\n![这是一张图片](img\\p7.png \"可选的标题\")\n![这是一张图片](img\\p8.png \"可选的标题\")\n\n## 严格检查模式\n在我们书写代码时，会发现有时候不严谨的写法依然不会报错而导致无法运行。\n\n例如在代码中直接写上 ``i = 1`` 如同python一样，但这时候i定义成是全局变量，以至于在其他JS文件中依然可以调用到这个变量，因此我们得想办法约束一下自己代码书写的严谨性。\n\n我们在第一行写上 ``\"use strict\"`` (引号不能丢) __严格检查模式__，开启后如果出现以上 ``i = 1`` 的写法会直接报错，提升了代码的严谨性。\n\n__严格检查模式__ 一般写在JS文件 (或者标签内) 的第一行写上，在其他地方写上在运行文件的时发现错误会报错，但在浏览器里调试中不会发生报错。\n\n## 字符串\nJS字符串可以用 __单引号__ 或者 __双引号__ 包裹，如果想输出引号，我们可以使用 ' __\\\\__ ' 转义符来进行转义引号。\n```\n常用的转义符:\n\\'\n\\\"\n\\t      # 等效于tab键\n\\u4e2d  # '中'，Unicode字符，一般为\\u####\n\\x41    # 'A'，ASCLL字符\n```\n\n#### 多行字符串编写\n如果希望进行多行字符串编写，我们可以使用两个 `` ` ``  包裹起来\n```\nvar 变量名 = `\n        内容\n        内容\n        .....\n`\n```\n或者我们在希望换行的位置打上换行符 `` \\n `` 进行换行\n\n#### 字符串拼接\n在JS里，字符串拼接最常见有两种方式\n```\nvar a = \"abc\";\nvar b = \"cba\";\n方式一：\n    用加号来拼接字符串\n    console.log(\"abc\"+\"cba\");    # abccba\n    console.log(a+b);            # abccba\n方式二：\n    在字符串中穿插 '${变量名}'\n    console.log(`早上好！${a}`)   # 早上好！abc \n                                 # 注意，括号内使用的是 ` 号\n```\n\n#### 字符串长度\n```\nvar a = \"abc\";\nconsole.log(abc.length);   # 3\n```\n\n#### 字符串的可变性\n```JavaScript\nvar a = \"abcdef\";\nconsole.log(a[1]);         # b\na[1] = 'b';                # 这里尝试把'b'赋值给a[1]\n                           # 没有显示报错，赋值完成\nconsole.log(a[1])          # a\n                           # 发现虽然赋值完成，但值没有改变，赋值失败\n```\n![这是一张图片](img\\p9.png \"可选的标题\")\n\n#### 字符串截取\n```\nvar a = \"abcdef\";\nconsole.log(a.subString(1))      # bcdef   从下标1开始一直到最后\nconsole.log(a.subString(1,3))    # bc      从下标1开始，到下标3结束(不包括下标3)\n字符串截取是'[)'包左不包右\n注意，当 '.'后面有括号说明是方法而不是属性\n```\n\n## 数组\n数组Array可以包含任意的数据类型\n```JavaScript\nvar arr01 = [1,2,3,4,5,6,7,8,9]; # 可以通过数组下标进行取值和赋值 \nconsole.log(arr01);              # [1, 2, 3, 4, 5, 6, 7, 8, 9]\narr01[0] = 0;\nconsole.log(arr01);              # 0, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n#### 长度\n```\narr01.length\n```\n注意，我们可以给``arr01.length``进行赋值，赋值后会改变数组的长度，如果赋的值大于原来，则以``empty``补全，如果赋的值小于原来，则超过的下标元素丢失，一般不建议去修改数组长度。\n\n#### indexof()\n我们可以用indexof()通过元素获得第一个元素出现的下标\n```\narr01.indexof(1)\n```\n注意：字符串1和数字1是不一样的\n\n#### slice()\nslice()用来截取数组的一部分，返回一个新的数组\n```\n数组名.slice(3)     # 从下标3开始到最后\n数组名.slice(1,3)   # 从下表1开始到下标3结束，不包括下标3，类似于String中的subString()\n```\n\n#### push()、pop()尾部\n```\npush()   压入到尾部\npop()    从尾部弹出一个元素\n```\n\n#### unshift()、shift()头部\n```\nunshift()   压入到头部\n、shift()    从头部弹出一个元素\n```\n\n#### 排序sort()\n```\n['B','A','C'];\narr.sort();\n['A','B','C']\n```\n\n#### 元素反转reverse()\n```\n['A','B','C'];\narr.reverse();\n['C','B','A']\n```\n\n#### 数组拼接concat()\n```\n# ['A','B','C'];\narr.concat([1,2,3]);\n# ['A','B','C',1,2,3];\nconsole.log(arr);\n# ['A','B','C']\n```\n注意：concat()并没有修改数组，而是返回一个新的数组\n\n#### 连接符join()\n```\n['A','B','C'];\narr.join('-');\n\"A-B-C\"\n```\n\n## 对象\n#### 定义对象\n在JS中，对象就是由若干个键值对组成的\nJS中所有的键都是字符串，值可以是任意类型！\n```\nvar 类名 = {\n    属性名:值,\n    属性名:值,\n    属性名:值,\n    属性名:值\n}\n```\n定义对象中每个属性用逗号隔开，最后一个属性不加逗号\n\n#### 对象赋值\n```\n对象名.属性名 = 值;\n```\n注意，使用一个不存在的属性不会报错\n\n#### 动态的删减属性\n通过delete删除对象的属性\n```\ndelete 对象名.属性名\n```\n![这是一张图片](img\\p10.png \"可选的标题\")\n\n#### 动态的添加属性\n直接给想要添加的属性名赋值即可\n```\n对象名.属性名 = 值\n```\n![这是一张图片](img\\p11.png \"可选的标题\")\n\n#### 判断属性值是否在这个对象中\n```\n属性名 in 对象名\n```\n注意：JS中属性名都为字符串，判断时要加上引号\n![这是一张图片](img\\p12.png \"可选的标题\")\n\n我们在Java中对象一般都会设一个toString方法，在JS检查属性值时会发现，toString也在本对象中，这是因为继承性，JS和Java一样，对象都是默认继承object，属性也会一同继承下来。\n![这是一张图片](img\\p13.png \"可选的标题\")\n\n#### hasOwnProperty()\n如果我们只想看本对象中，不想看到继承下来的属性，我们可以使用hasOwnProperty()\n```\n对象名.hasOwnProperty(属性名)\n```\n\n## 流程控制\n个人认为本质上和Java的流程判断没区别\n#### if判断\n```JavaScript\nvar age = 18;\nif(age > 18){\n    console.log(\"成年了\");\n}else if(age === 18){\n    console.log(\"刚成年\");\n}else {\n    console.log(\"未成年\");\n}\n```\n\n#### while判断\n```JavaScript\nvar a = 0;\nwhile(a < 100){\n    a = a + 1;\n    console.log(a);\n}\nvar b = 0;\ndo{\n    b = b + 1;\n    console.log(b);\n}while(b < 100)\n```\n\n#### for循环\n```JavaScript\nfor(let i = 0; i < 100; i++){\n    console.log(i);\n}\n```\n\n#### for in 循环\n```JavaScript\nvar arr = [1,2,3,4,5,6,7,8,9];\n\n# for(var 下标 in 容器)\n\nfor(var num in arr){\n    console.log(arr[num]);\n}\n```\n\n#### for of 循环\nfor of和上面的for in 相似，for in产生的变量是下标，for of产生的变量是数值\n但是for of不会遍历出手动添加的值，但for in会\n```\nfor(var num of arr){\n    console.log(num);\n}\n```\n\n#### forEach循环\n```\nvar age = [1,23,4,5,6,7,8];\nage.forEach(function (value){\n    console.log(value);\n})\n```\n\n## Map 和 Set\n#### Map\nJS里和Java里Map使用方法一样，键是唯一的，值不是唯一的\n```JavaScript\nvar map = new Map([[\"tom\",99],[\"jerry\",98],[\"alice\",95],[\"bob\",96]]);\n// get方法通过键来找到值\nconsole.log(map.get(\"tom\"));\n// set方法添加或者修改键值对\nmap.set(\"hhhhh\",100);\n// delete方法删除键值对\nmap.delete(\"tom\");\n```\n个人感觉JS里面Map和上面提到的对象很相似，都是多对键值对，但不同处在于对象的键只能是字符串，而Map的键可以是任意类型\n\n可以通过for of来遍历\n```JavaScript\nvar map = new Map([[\"tom\",99],[\"jerry\",98],[\"alice\",95],[\"bob\",96]]);\nfor(var x of map){\n    console.log(x);\n}\n```\n#### Set\nSet：无序不重复的集合\n无序并不是说没有顺序，而是说没有像数组一样的索引\n```JavaScript\nvar set = new Set([1,2,3,3,3,3,3,3]) \nset.add(2);                          //添加元素\nset.delete(1);                       //删除元素\nset.has(3);                          //判断是否包含\n```\nSet也可以通过for of来遍历\n```\nvar set = new Set([1,2,3,3,3,3,3,3]) \nfor(var x of set){\n    console.log(x);\n}\n```\n\n## 函数\n#### 函数的定义\n__方式__：\n```JavaScript\nfunction MyAbs(x){\n    if(x >= 0){\n        return x;\n    }else{\n        return -x;\n    }\n}\n```\n跟其他语言一样，执行到 ``return`` 即代表函数结束，无法运行 ``return`` 后面的代码\n如果没有执行 ``return`` ，函数执行完也会返回结果 ``undefined``\n\n__方式二__：\n```\nvar MyAdd = function(a,b){\n    return a+b;\n}\n```\nfunction(a,b){...}是一个匿名函数。可以把结果赋值，通过被赋值名来调用函数\n\n__方式一和方式二等价__\n\n#### 调用函数\n```\n函数名(参数1,参数2,参数3....)\n```\n在调用函数的时候会发现一件事，你可以传任意多个参数，不会报错\n\n如果我们只想接收一个参数，传多个参数就是非法调用，这种情况我们可以使用 `arguments` \n\n例如：\n```JavaScript\nvar MyAdd = function(a,b){\n    if(arguments.length !== 2){\n        throw \"Not a Number\"\n    }\n    return a+b;\n}\n```\n![这是一张图片](img\\p14.png \"可选的标题\")\n``arguments`` 是参数接收值的数组，每个方法内都有，用来存储每个方法的接收值\n\n#### 可变参数\n`rest`\n用数组来接收函数体已经定义的参数之外的参数\n例如：\n```JavaScript\nfunction abbb(a,b,...rest){\n    函数体.....\n}\nabbb(1,2,3,4,5,6,7,8)       # 调用函数，传参\n                         # a === 1\n                         # b === 2\n                         rest = [3,4,5,6,7,8]\n```\nrest参数只能写在参数最后，前面必须要有`...`表示\n\n## 变量的作用域\n#### this\nJS里，如果我们在函数外和函数内都定义了一个同名的变量，我们将如何区分\n\n首先，JS和Java一样，遇到相同的变量名时会优先调用最近的(最近原则)，在函数里面调用，则会优先调用到函数里面的变量，如果希望调用函数外的，我们可以用关键字this\n```JavaScript\nvar a = 10;\nfunction test() {\n    var a = 20;\n    console.log(this.a);\n    console.log(a);\n    console.log(\"====================\");\n}\nconsole.log(a);\ntest();\na = 30;\nconsole.log(a);\ntest();\n```\n![这是一张图片](img\\p15.png \"可选的标题\")\n\n#### var和let\n在之前写代码时会发现，我们无论在变量或者是函数前，都会加一个var或者let，var和let有什么区别呢？\n\n一开始我也分不清楚，后来查资料也懵懵懂懂，后来多写几行代码就有更深一点的领悟。\n\nvar 一般是用在全局作用域，而let用在局部作用域，什么是作用域，个人见解，每一个 `{}` 花括号括起来就是一个作用域\n比如上面的this中的代码，我们在函数外部和函数内部都定义一个全局变量a，我们在函数内是能通过this或者window来调用到函数外的a\n注：window只能调用全局变量，无法调用局部变量\n但是如果我们用的是let定义的局部变量，我们会发现在函数内也无法调用到函数外的a\n```JavaScript\nlet a = 10;\nfunction test() {\n    let a = 20;\n    console.log(window.a);\n    console.log(a);\n    console.log(\"====================\");\n}\nconsole.log(a);\ntest();\na = 30;\nconsole.log(a);\ntest();\n```\n![这是一张图片](img\\p17.png \"可选的标题\")\n\n#### 常量const\n有变量肯定也有常量，我们在编写代码的时候也希望有些值不允许被改变\n```\nconst 变量名 = 值\n```\n用const修饰后的变量名是不允许被修改的\n\n## 方法\n函数定义在对象外就是函数，定义在对象内就是方法\n```JavaScript\nvar hh = {\n       name : \"hs\",\n       ahe : 18,\n       birth : 2005,\n       // 方法\n       age : function(){\n           return new Date().getFullYear() - this.birth;\n       }\n}\n// 属性\nhh.name;\n// 方法\nhh.age();\n```\n\n#### apply\napply感觉像是Java里的反射，在JS中任何方法都用apply的属性\n```\n方法名.apply(对象名,参数)      # 参数用数组装，没有参数就传[]\n```\n例如\n```JavaScript\nfunction getAge(){\n    return new Date().getFullYear() - this.birth;\n}\nvar hh = {\n    name : \"hs\",\n    ahe : 18,\n    birth : 2005,\n    age : getAge\n}\n```\n我们可以用 hh.age()，也可以用 getAge.apply(hh,[])\n\n## JSON\n#### JSON是什么\nJSON（JavaScript Object Notation，JavaScript对象表示法）\nJSON是一种常用的数据格式，在电子数据交换中有多种用途，包括与服务器之间的Web应用程序的数据交换。其简洁和清晰的层次结构有效地提升了网络传输效率，使其成为理想的数据交换语言。其文件通常使用扩展名.json。\n\n#### JSON字符串和JS对象的转换\n格式：\n```\n对象和方法用  {}\n数组用       []\n键值对用     key:value\n```\n```JavaScript\nvar person = {\n            name: \"John\",\n            age: 30,\n            city: \"New York\"\n        }\n        // 对象转换为JSON字符串\n        var json = JSON.stringify(person);\n        console.log(json)\n        // JSON字符串转换为对象\n        var obj =JSON.parse(json);\n        console.log(obj)\n        // 也可以用 JSON.parse('{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}')\n```\n![这是一张图片](img\\p18.png \"可选的标题\")\n\n## 面向对象\n在其他语言中，说起对象就想起类，类是模板，对象是实体，继承等等\n在之前JS里还没有继承，但是有这个概念，于是出现了原型\n```\nA对象.__proto__ = B对象\nA对象的原型是B对象\n于是乎A对象就能使用B对象里面的属性\n```\n\n#### class\n在ES6版本后，加入了一个新的关键字`class`\n跟Java的区别在于构造器，在JS的class里，构造器是 `constructor` \n```JavaScript\nclass person01 {\n    constructor(name, age){\n    this.name = name;\n    this.age = age;\n    }\n    run() {\n        console.log(this.name + \" is running\");\n    }\n}\nvar xiaoming = new person01(\"xiaoming\", 25);\nvar xiaohong = new person01(\"xiaohong\", 20);\n```\n而且，在类里面构建的方法不需要在方法名前面加var\n#### 继承\n```JavaScript\nclass 子类名 extend 父类名{\n    constructor(参数){\n        super()\n    }\n}\n```\n例如：\n```JavaScript\nclass person02 extends person01 {\n    constructor(name, age, sex) {\n        super(name, age);\n        this.sex = sex;\n    }\n    sayHello() {\n        console.log(\"Hello, my name is \" + this.name + \" and I am a \" + this.sex);\n    }\n}\n```\n我们可以在浏览器调试中看到其实所谓的继承还是原型，我们能看到原型链，原型的尽头还是object\n![这是一张图片](img\\p19.png \"可选的标题\")\n\n## 操作BOM对象\nBOM：Browser Object Model（浏览器对象模型）\n类似的还有一个叫 `DOM` : 是将HTML文档中的各个元素封装成一个对象，而 `BOM` 则是将一个浏览器的各个组成部分封装成对象供调用使用。\n\nJavaScript诞生的目的就是为了能够在浏览器上运行\n\n#### window\nwindow对象代表着浏览器窗口\n```JavaScript\nwindow.alert(1)\nundefined\nwindow.innerHeight\n358\nwindow.innerWidth\n1659\nwindow.outerWidth\n1707\nwindow.outerWidth\n1707\n```\n\n#### navigator\nnavigator对象代表浏览器的信息\n```JavaScript\nappName    # 浏览器的官方名称。通常是\"Netscape\"，\n           # 这是因为Netscape是第一个支持JavaScript的浏览器。\nappVersion # 提供了浏览器版本信息\nuserAgent  # 浏览器的用户代理字符串\nplatform   # 运行浏览器的操作系统平台\n```\n一般不建议使用 `navigator` 对象，因为里面的信息会被人为修改\n\n#### screen\nscreen代表屏幕尺寸\n```JavaScript\nscreen.width\n1707 px\nscreen.height\n960 px\n```\n\n#### location\nlocation代表当前网页的URL信息\n```JavaScript\nhost: \"ntp.msn.cn\"\nprotocol: \"https:\"\nreload: ƒ reload()    // 刷新网页\n```\n\n#### document\ndocument代表当前的页面，HTML，DOC文档树\n```JavaScript\ndocument.title\n'新建标签页'\ndocument.title = '呵帅'\n'呵帅'\n```\ncookie劫持原理，引了一个含有获取cookie的文件\n```\n// 获取cookie\ndocument.cookie\n```\n\n#### history\nhistory代表浏览器的历史记录\n```JavaScript\n// 后退\nhistory.back()\n// 前进\nhistory.forward()\n```\n\n## 操作DOM对象\nDOM：文档对象模型\n\n浏览器网页就是一个DOM树形结构，我们只需要做\n1、更新：更新DOM节点\n2、遍历：遍历每个DOM节点\n3、删除：删除DOM节点\n4、增加：增加DOM节点\n\n乍一看像前端版的增删改查\n\n#### 获取DOM节点\n```JavaScript\n<div id=\"father\">\n    <h1>标题</h1>\n    <p id=\"p1\">段落</p>\n    <p class=\"p2\">段落</p>\n</div>\n<script>\n    //对应CSS选择器\n    var h1 =document.getElementsByName('h1');\n    var p = document.getElementsByName('p');\n    var div = document.getElementsByName('div');\n    var father = document.getElementById('father');\n    var p2 = document.getElementsByClassName('p2');\n    var p1 =document.getElementsByTagName('p1')\n</script>\n```\n可以用 `getElementsByName` 通过属性名，或者 `getElementById` 通过选择器\n\n#### 更新节点\n```\n<div id = 'id1'>\n\n</div>\n<script>\n    var id1 = documents.getElementById('id1');\n</script>\n```\n操作文本\n```\nid1.innerText='123456';\nid1.innerHTML='<strong>123</strong>'\n\ninnerText和innerHTML的区别：\ninnerText修改文本的值\ninnerHTML可以解析HTML语句\n```\n操作JS\n```\nid1.style.color = 'red'\n'red'\nid1.style.fontSize = '20px'\n'20px'\nid1.style.padding = '30px'\n'30px'\n```\n\n#### 删除节点\n删除节点得先获取父节点，然后通过父节点删除\n\n方法一\n```JavaScript\n<div id=\"father\">\n    <h1>标题</h1>\n    <p id=\"p1\">段落</p>\n    <p class=\"p2\">段落</p>\n</div>\n<script>\n    var p1 = documents.getElementById('p1');\n    var father = p1.parentElement;\n    father.removeChild(p1)\n</script>\n```\n方法二\n```JavaScript\n<div id=\"father\">\n    <h1>标题</h1>\n    <p id=\"p1\">段落</p>\n    <p class=\"p2\">段落</p>\n</div>\n<script>\n    father.removeChild(father.children[0]);\n    father.removeChild(father.children[0]);\n    father.removeChild(father.children[0]);\n</script>\n```\n注意：每次删除的时候，children都是在变化的\n\n## 表单\n#### 获取表单的值\n表单有很多种：\n文本框、下拉框、选项框、密码框、隐藏框等等\n```JavaScript\n<p>\n    <span>输入内容:</span> <input type=\"text\" id=\"input\">\n</p>\n<p>\n    <span>性别:</span>\n    <input type=\"radio\" value=\"man\" name=\"sex\" id=\"boy\"> 男\n    <input type=\"radio\" value=\"woman\" name=\"sex\" id=\"girl\"> 女\n</p>\n\n<script>\n    var input_text = document.getElementById('input');\n    var boy_radio = document.getElementById('boy');\n    var girl_radio = document.getElementById('girl');\n</script>\n```\n文本框我们会取其`document`然后用`.value`获得值\n如果是选项框一般则会用 `.check`来判断是否被选择\n```\ninput_text.value\n'123456'\ninput_text.value = 456789\n456789\nboy_radio.value\n'man'\ngirl_radio.value\n'woman'\nboy_radio.checked\ntrue\ngirl_radio.checked\nfalse\n```\n\n#### 表单提交验证及加密\n在`button`中我们可以自定义按下按钮的触发效果\n```JavaScript\n<p>\n    请输入用户名：<input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\">\n</p>\n<p>\n    请输入密码 ：<input type=\"password\" id=\"password\" name=\"password\" placeholder=\"请输入密码\">\n</p>\n<!--绑定事件 onclick-->\n<button type=\"button\" onclick=\"submit()\">提交</button>\n<script>\n    function submit() {\n        var username = document.getElementById(\"username\");\n        var password = document.getElementById(\"password\");\n        console.log(username.value);\n        console.log(password.value);\n    }\n</script>\n```\n在平时使用的时候都是输入完按下提交按钮，数据就会被提交到数据库上面，但这样还是有一点隐患，非常容易被抓包，导致数据都被明文曝光，我们可以使用MD5加密\n```\ndocument名.value = md5(document名.value)\n```\n世上没有不透风的强，再怎么加密依然有曝光的风险，平时项目中建议在后端进行加密，不要在前端做加密\n\n\n## jQuery\n#### jQuery下载\n目前jQuery官网直接打开不是文件而是原码\n我们在官网上点开 `download`\n![这是一张图片](img\\p20.png \"可选的标题\")\n点击 `download jQuery` \n![这是一张图片](img\\p21.png \"可选的标题\")\n然后我们会发现一整个网页都是字符，不要怀疑自己，这就是官网\n![这是一张图片](img\\p22.png \"可选的标题\")\n方法一：\n我们在项目的位置新建一个 `.txt` 文件，把网页的内容 `Ctrl+a` 全部复制到txt文件内，修改后缀为 `.js` 然后倒入进项目里\n\n\n方法二：\n右键另存为，就是一个 `.js` 文件了\n\n或者，我们在网上查找jQuery的CDN，直接搜索就行，引入在线CND，就不需要去官网下载了\n\n#### 导入\n```\n<script scr=\"lib/jquery-3.5.1.min.js\"></script>\n```\n![这是一张图片](img\\p23.png \"可选的标题\")\n直接在`head`最下面插入导入语句\n\n#### 实践\n在网页上画一个小块，当鼠标在块中时可以显示鼠标在块内的坐标\n```JavaScript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"></script>\n    <style>\n        #div1 {\n            width: 500px;\n            height:500px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n<body>\n    <span id=\"span1\"></span>\n    <div id=\"div1\">\n        移动区域\n    </div>\n    <script>\n        $(document).ready(function (){\n            $(\"#div1\").mousemove(function (e){\n                $(\"#span1\").text(\"x\"+e.pageX+\"y\"+e.pageY);\n            })\n        })\n    </script>\n</body>\n</html>\n```\n效果：\n![这是一张图片](img\\p24.png \"可选的标题\")\n"},{"url":"/2024/09/11/articles/MySQL/MySQL/"},{"title":"JDBC学习笔记","url":"/2024/09/05/articles/JDBC/JDBC/","content":"# 了解一下JDBC\nJDBC（Java Database Connectivity）是Java语言中用来规范客户端程序如何访问数据库的应用程序接口，它定义了一系列的接口，为各种数据库的访问提供了统一的操作方式。\n\n## 为什么我们会用到JDBC？\n一般来说，数据库与应用程序无法直接链接，我们需要一个驱动，作为应用和数据库直接的桥梁，但是每个厂商之间的驱动是不相同的，MySQL有MySQL的驱动，Oracle有Oracle的驱动，我们不可能每使用一种数据库就去安装他的驱动，太过麻烦。\n![p1](JDBC/p1.png \"\")\nJDBC是让Java应用程序连接到不同的数据库管理系统(如MySQL、Oracle等)，执行SQL查询和更新，以及处理结果集。\n驱动的安装就不需要我们亲自去做了，我们只需要掌握JDBC的语法，即可在Java中使用数据库了。\n![p1](p2.png \"\")\n\n## 使用JDBC之前的工作\n首先，在使用JDBC之前，我们需要先去下载jar包，我是去Maven仓库下载的\nMaven仓库下载地址：https://mvnrepository.com/artifact/mysql/mysql-connector-java\n下载后，我们需要导入驱动jar包\n我们在项目内新建一个文件夹，用来存放jar包，后面需要添加的jar包也可以存放在内，把下载的jar包复制进文件内，打开IntelliJ IDEA\n![p1](p3.png \"\")\n我们在项目内可以看到我们复制进来的jar包，但此时不算导入成功，我们需要右键，点击``Add as Library``，点击ok，可以展开的话就是导入成功了\n\n## 第一个JDBC程序\n### 查询数据库\nJDBC有六个步骤，我们随后在Java程序里写编程的时候按照这六步来写即可\n```\n1、加载驱动\n2、用户信息和url\n3、创造链接\n4、执行sql语句的对象\n5、执行sql语句，并查看返回的结果\n6、释放链接\n```\n我们先准备一份有内容的数据库\n```\nCREATE DATABASE jdbcStudy;\n\nUSE jdbcStudy;\n\nCREATE TABLE `users`(\n\tid INT PRIMARY KEY,\n\tNAME VARCHAR(40),\n\tPASSWORD VARCHAR(40),\n\temail VARCHAR(60),\n\tbirthday DATE\n);\n\nINSERT INTO `users`(id,NAME,PASSWORD,email,birthday)\nVALUES(1,'zhansan','123456','zs@qq.com','2000-1-1'),\n(2,'lisi','123456','lisi@qq.com','2001-1-1'),\n(3,'wangwu','123456','wangwu@qq.com','2002-1-1')\n```\n然后，我们再打开IntelliJ IDEA，新建一个Java程序\n![p1](p4.png \"\")\n代码如下\n```\npackage JDBC;\n\nimport java.sql.*;\n\npublic class JDBCtest {\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //JDBC\n\n        //1、加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\"); //模板格式\n\n        //2、用户信息和url\n        String url = \"jdbc:mysql://localhost:3306/jdbcstudy;\n        String user = \"root\";\n        String password = \"123456\";\n\n        //3、创造链接\n        Connection connection = DriverManager.getConnection(url, user, password);//这里返回的connection对象代表数据库\n\n        //4、执行sql语句的对象\n        Statement statement = connection.createStatement();\n\n        //5、执行sql语句，并查看返回的结果\n        String sql = \"SELECT * FROM users\";\n        ResultSet resultSet = statement.executeQuery(sql);//返回的结果集\n        while (resultSet.next()){\n            System.out.print(\"id=\"+resultSet.getObject(\"id\"));\n            System.out.print(\" name=\"+resultSet.getObject(\"NAME\"));\n            System.out.print(\" password=\"+resultSet.getObject(\"PASSWORD\"));\n            System.out.print(\" email=\"+resultSet.getObject(\"email\"));\n            System.out.println(\" birth=\"+resultSet.getObject(\"birthday\"));\n        }\n        \n        //6、释放链接\n        resultSet.close();\n        statement.close();\n        connection.close();\n    }\n}\n```\n运行结果如下，虽然有红色小字，但不影响程序的运行\n![p](p5.png \"\")\n\n### 修改信息|增加信息|删除信息\n我们使用executeUpdate(String sql)来完成添加|删除信息\n添加信息\n```\nStatement statement = connection.createStatement();\nString sql = \"insert into user(...)values(...)\";\nint num = statement.executeUpdate(sql);\nif (num > 0){\n    System.out.println(\"插入成功！\");\n}\n```\n删除信息\n```\nStatement statement = connection.createStatement();\nString sql = \"delete from user where ...\";\nint num = statement.executeUpdate(sql);\nif (num > 0){\n    System.out.println(\"删除成功！\");\n}\n```\n修改信息同上，只需要改变sql里面的语句即可\n\n## 简化步骤\n上面的方法看着很简便，但如果数据一多就特别麻烦，所以我们需要把方法提取出来\n首先，我们构建一个文件``db.properties``用来保留登录信息，在文件中写入\n```\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/jdbcstudy\nusername=root\npassword=123456\n```\n然后再构建一个java文件，用来存放方法\n```\npackage JDBCtest2;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class test2 {\n\n    private static String driver = null;\n    private static String url = null;\n    private static String user = null;\n    private static String password = null;\nstatic {\n\n\n    try {\n        InputStream in = test2.class.getClassLoader().getResourceAsStream(\"db.properties\");\n        Properties properties = new Properties();\n        properties.load(in);\n        driver = properties.getProperty(\"driver\");\n        url = properties.getProperty(\"url\");\n        user = properties.getProperty(\"username\");\n        password = properties.getProperty(\"password\");\n\n        //1、驱动只需要加载一次\n        Class.forName(driver);\n\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n//获取链接\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, user, password);\n}\n//释放资源\npublic static void release(Connection conn, Statement st, ResultSet rs) {\n    if (rs!= null) {\n        try {\n            rs.close();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    if (st!= null) {\n        try {\n            st.close();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    if (conn != null) {\n        try {\n            conn.close();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n\n}\n```\n方法就提取出来了，我们实验一下\n![p](JDBC/p6.png \"\")\n运行结果，成功插入\n![p](p7.png \"\")\n![p](p8.png \"\")\n\n## PreparedStatement对象\nPreparedStatement对象可以有效防止[SQL注入](https://baike.baidu.com/item/sql%E6%B3%A8%E5%85%A5/150289?fr=ge_ala \"百度搜索\")，并且运行时效率更高。\n防止SQL注入的原理：把转递进来的参数当作字符，假设其中存在转义字符，会被直接转义，比如说``\"``会被认为是引号，而不是其他。\n![p](p9.png \"\")\n代码如下\n```\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Date;\n\npublic class insertTest {\n    public static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement pst = null;\n\n        try {\n            conn = test2.getConnection();\n            // 与之前的区别：\n            // 使用？占位符来代替参数\n            String sql = \"insert into users(id, NAME, PASSWORD, email, birthday) values(?, ?, ?, ?, ?)\";\n\n            pst = conn.prepareStatement(sql);//预编译sql语句，但不执行\n\n            //手动给参数赋值，\n            // 第一个参数代表着第几个问号，第二个参数代表着参数值\n            pst.setInt(1, 5);\n            pst.setString(2, \"John\");\n            pst.setString(3, \"123456\");\n            pst.setString(4, \"john@qq.com\");\n            // java.sql.Date是数据库的日期类型，需要用java.util.Date转换\n            //         new Date().getTime()获取时间戳\n            pst.setDate(5, new java.sql.Date(new Date().getTime()));\n\n            int i = pst.executeUpdate();\n\n            if (i > 0) {\n                System.out.println(\"Insert success!\");\n            }\n\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n成功插入\n![p](p10.png \"\")\n其余删改查和这个差不多，删和改只需要把sql语句和参数变一下，查就把sql语句和``executeUpdate``变成``executeQuery``即可\n\n\n\n\n"},{"title":"docker学习记录","url":"/2024/03/16/articles/docker/docker/","content":"# Docker学习记录\n因为在学习MySQL的时候需要用到多台客户端，如果使用VMware来一个个创建就太过于麻烦，因此我在网上冲浪的时候发现了Docker，Docker是一个 __基于go语言__ 的开源应用引擎，通过利用Docker的方法来快速交付，测试和部署代码，可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n## Docker的安装\n因为我用的是centOS，所以我在这里展示的也是centOS的安装方法\n注：如果没给权限记得在命令前加sudo\n<br>\n首先，如果之前有安装过docker，无论有没有成功，都先删除一遍：\n> yum remove docker \\\n>>> docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n>\n安装依赖，下载 repo 文件：\n> yum install -y yum-utils\n>\n设置软件仓库地址（默认是国外的，不建议）：\n> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n>\n建议使用阿里云的仓库地址，因为比较快:\n> yum-config-manager --add-repo https://mirrors.aliyum.com/docker-ce/linux/centos/docker-ce.repo\n>\n在安装前建议更新一下yum软件包\n> yum makecache fast\n> \n\n最后在安装docker-ce(ce指的是社区版，免费，也有ee版是企业版，需要付费)：\n> yum install docker-ce docker-ce-cli containerd.io \n docker-buildx-plugin docker-compose-plugin\n>\nDocker的安装就可以了\n\n## Docker的信息\n首先，我们先要启动docker\n> systemctl start docker \n>\n我们可以通过 ``docker version`` 来查询docker的一些版本信息\n或者可以用 ``docker info`` 来查看docker的一些系统级的信息，比如内核，镜像数，容器数等\n\n## hello-world\n一切语言或者其他都有hello world，docker也不例外，真就是精通各种hello world了\n首先，我们先来查看一下目前已有的镜像\n> docker images\n>\n不出意外，显示的是下面几个列标题，没有值\n![这是一张本地图片](./images.png \"图片标题\")\n然后，我们来执行命令\n> docker run hello-world\n>\n![这是一张本地图片](./p2.png \"图片标题\")\n运行完后会显示一长串的东西，简单来说就是没有找到这个镜像，然后就去pull，去远程拉取一个镜像，如果输出有 ``Hello from Docker!`` 则表示成功\n<br>\n但是，如果没有显示上图那一长串的信息，或者是显示 ``Redirecting to /bin/systemctl stop docker.servic``之类的信息，说明拉取镜像失败了，这时候要考虑设备或者网络的问题。\n我在做这一步的时候也发生了两次错误，一次是把 ``docker run hello-world`` 打错成 ``docker run hello-word``了，另一次是因为原来配置的镜像问题，建议使用阿里云的镜像加速器.\n> sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://wosslmsh.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n>\n\n完成以上步骤后，再使用 ``docker images`` 来查看已有的镜像\n![这是一张本地图片](./p3.png \"图片标题\")\n会发现，多一个\"hello-world\"镜像，这就是我们刚刚执行 ``docker run hello-world``所拉下来的镜像。\n如果你想卸载某个镜像，你需要执行：\n> 1、卸载依赖\nyum remove docker-ce docker-ce-cli containerd.io\n2、删除资源\nrm -rf /var/lib/docker\n/var/lib/docker 是docker的默认工作路径\n\n# Docker的常用命令\n## 帮助命令\n\n> docker version  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看客户端和服务端的详细版本信息\ndocker info &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查看docker的系统信息\ndocker --help &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#帮助查询docker的命令\n>\ndocker images&nbsp;查看所有本地的主机上的镜像\n> <pre>REPOSITORY      TAG       IMAGE ID       CREATED       SIZE\n>hello-world   latest    feb5d9fea6a5   2 years ago   13.3kB</pre>\n__解释__\n```\nREPOSITORY  镜像的仓库源\nTAG         镜像的标签\nIMAGE ID    镜像的ID\nCREATED     镜像的创建时间\nSIZE&nbsp   镜像的大小\n``` \n__可选项__\n> -a, --all             #列出所有的可选项  \n  -q, --quiet           #只显示镜像的ID\n\n## 镜像命令\n\n__搜索镜像__\n> docker search 镜像名\n![这是一张本地图片](./p4.png \"图片标题\")\n\n__可选项__，通过收藏来过滤\n> --filter=STARS=1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#搜索出来的镜像就是STARS大于1234的\n![这是一张本地图片](./p5.png \"\")\n\n__下载镜像__\n> docker pull 镜像名[:tag(版本)]不加默认最新版\n![这是一张本地图片](./p6.png \"\")\n采用的是分层下载，是docker images的核心，联合文件系统，感兴趣可以去搜索了解\n最后一行是镜像的真实地址docker pull mysql = docker pull docker.io/library/mysql:latest\n__指定版本下载__\n例如：\n![这是一张本地图片](./p8.png \"\")\n我们可以看到，其实我们并没有完完全全的重新下载一份，有重复的文件会直接拿过来用，避免了不必要的麻烦，这就是分层下载的好处之一\n\n下载完后我我们可以用``docker images```来查看下载的镜像\n![这是一张本地图片](./p9.png \"\")\n\n```\n一般我们下载的流程是：\n1、搜索镜像  search\n2、下载镜像  pull\n3、运行测试  run\n4、进入容器  exec -it\n```\n\n__删除镜像__\n> 删除镜像：``docker rmi``\nrm我们都知道，Linux里删除东西也是用rm，rmi里的i指的是images镜像，删除镜像时我们可以通过ID来删，也可以通过名称来删\n![这是一张本地图片](./p10.png \"\")\n我们也可以加上参数-f来表示完全删除\n\n如果想要删除多个镜像只需要用空格隔开即可\n``docker rmi -f 镜像ID 镜像ID 镜像ID``\n如果像全部删除\n``docker rmi -f $(docker images -aq)``\n\n## 容器命令\n__新建容器并启动__\n> 我们有了镜像才可以创建容器，所有学习之前先得下载一个centos的镜像\n``docker pull centos``\n![这是一张本地图片](./p11.png \"\")\n\n```\ndocker run [可选参数] image\n# 参数说明\n--name=\"Name\"    容器的名字，用来区分容器\n-d               以后台方式运行\n-i/-t            使用交互方式运行，进入容器查看内容\n-p               指定容器的端口，主机映射\n        -p ip:主机窗口:容器窗口\n        -p 主机窗口:容器窗口 （常用）\n        -p 容器端口\n        (省略-p)容器端口\n-P               随机指定端口\n```\n__启动并进入容器__\n> ![这是一张本地图片](./p12.png \"\")\n从原来的主机名变成容器ID\n\n```\n[root@fe9b4298a7e9 /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root\nrun  sbin  srv  sys  tmp  usr  var\n展开后我们会发现是不是跟外面的centOS一样，这就是一个小型的服务器，但是是基础版本，很多命令都还不完善\n```\n\n__查看运行的容器__\n```\n通过docker ps来查看运行的容器\n参数：\n什么都不加 #列出正在运行的容器\n-a        #列出正在运行的容器，带出历史运行过的容器\n-n        #显示最近创建的容器\n-q        #只显示容器的编号\n\n```\n![这是一张本地图片](./p14.png \"\")\n\n__退出容器__\n```\nexit                # 直接停止容器并退出，从容器中退到主机\n快捷键Ctrl + P + Q   # 容器不停止退出\n```\n![这是一张本地图片](./p13.png \"\")\n\n__删除容器__\n```\ndocker rm 容器ID                 #删除指定的容器，不能删除正在运行的容器，如果需要强制删除 rm -f\ndocker rm -f $(docker ps -aq)   #删除所有的容器\ndocker ps -a -q|xargs docker rm #删除所有容器\n```\n\n__启动和停止容器__\n```\ndocker start 容器ID       #启动容器\ndocker restart 容器ID     #重启容器\ndocker stop 容器ID        #停止当前运行的容器\ndocker kill 容器ID        #强制停止当前运行的容器\n```\n\n## 其他常用命令\n__后台启动容器__\n``docker run -d 镜像名``\n> ![这是一张本地图片](./p15.png \"\")\n&nbsp;&nbsp;我们使用后台运行命令启动centOS后，再使用``docker ps``发现，centOS停止了。\n<dr>\n这是因为docker容器使用后台运行时，就必须要有一个前台进程，如果docker没有发现有前台进程就会自动停止\n\n__查看日志__\n``docker logs -f -t --tail 容器``\n这里我没有成功，我输出的日志是空白的，所以就不做展示了\n<br>\n\n__查看容器中的进程__\n``docker top 容器ID``\n> ![这是一张本地图片](./p16.png \"\")\n<dr>\n\n__查看镜像的元数据__\n``docker inspect 容器ID``\n> 输入后显示很长一串的内容，我这里只截取一部分，但是所截取的内容也分丰富\n![这是一张本地图片](./p17.png \"\")\n<dr>\n\n__进入当前正在运行的容器__\n一般来说，通常容器都是使用后台方式运行，因此我们需要进入当前正在运行的容器的命令\n方法一：``docker exec -it 容器ID bashshell``\n> 这里的-it和上面一样，也是交互模式执行\n![这是一张本地图片](./p18.png \"\")\n\n方法二：``docker attach 容器ID``\n执行当前的代码\n<dr>\n```\n两者的区别\ndocker exec      # 进入容器后开启一个新的终端，可以在里面操作命令\ndocker attach    # 进入容器正在执行的终端，不会开启新的进程\n```\n\n__从容器内拷贝内容到主机上__\n``docker cp 容器ID:容器内路径 目的的主机路径``\n> ![这是一张本地图片](./p19.png \"\")\n\n## commit镜像\n``docker commit``命令用于创建一个新的镜像，基于正在运行的容器的当前状态。它允许你捕捉容器所做的更改并将其保存为一个新的镜像，以便以后可以使用该镜像创建相同的容器或与之共享状态\n<dr>\n命令和git原理类似\n``docker commit -m=\"提交信息描述\" -a=\"作者\" 容器ID 目标镜像名:[TAG(版本标签)]``\n案例：\n> 上文有提到，我们下载的镜像一般都是为删减版，功能不全，这时，我们想要用到tomcat较为完整的功能该怎么办\n1、先启动一个默认的tomcat\n2、进入后我们cd到webapps里，发现文件为空\n3、把文件拷贝进去\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时我们需要运行代码``cp -r webapps.dist/* webapps``把webapps.dist里的全部内容拷贝进webapps里即可。\n> ![这是一张本地图片](./p20.png \"\")\n4、通过\"docker commit\"来提交为一个镜像，这就是我们自己修改过的镜像\n> ![这是一张本地图片](./p21.png \"\")\n\n\n\n# 关于Docker的一些理论知识\n## 关于镜像\n__镜像是什么__\n```\n镜像是一种轻量级、可执行的独立软件包，某种意义上你可以把它理解成我们常用的压缩包，这个压缩包里包含着软件\n所需要的内容，例如代码、运行时的环境变量、配置文件等，一打开就是一个软件。\n```\n__如何可以得到镜像__\n```\n1、从远程仓库下载\n2、朋友拷贝给你\n3、自己手动做一个镜像DockerFile\n```\n\n__镜像加载原理__\n1、UnionFS（联合文件系统）\n```\n    UnionFS联合文件系统是一个分层、轻量且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的\n叠加，我们可以想象的到，我们的电脑上现在有了centOS，然后我们在centOS里安装了docker，我们再从docker里安\n装了jdk，一直套娃，联合文件系统就会把每一层都记录下来，所以我们上文提到的下载镜像时的分层，就是因为这个。\n```\n\n2、分层\n```\n  我们在下载镜像的时候能够发现，它不像我们平时在其他地方下载一个软件就是一个包，在docker里，一个软件分了\n很多层，这提高了使用性和可重复性。\n  然而一个软件可以分成两个大层，一个是镜像层，一个是容器层，镜像层和容器层之间有什么关系呢，我们做到命令\n都是在容器层上所操作的，无法改变镜像层内，我的理解是，镜像是一个压缩包，而容器是解压后的软件，我们可以改\n变软件里的内容，但是无法改变压缩包里的内容。\n```\n\n# 容器数据卷\n## 容器数据卷的作用\n我们在docker运行时产生的数据，如果不是通过``docker commit``来提交的话，等容器删除时数据也会跟着删除，为了能保存数据在Docker中我们使用卷。\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n卷就是目录或文件，存在于一个或多个容器中，由Docker挂载到容器，但卷不属于联合文件系统（Union FileSystem），因此能够绕过联合文件系统提供一些用于持续存储或共享数据的特性:。\n## 使用数据卷\n> 方式一：直接使用命令来挂载 -v\n```docker run -it -v 主机目录:容器目录```\n> ![这是一张本地图片](./p22.png \"\")\n> ![这是一张本地图片](./p23.png \"\")\n现在，容器内和容器外的地址都相连起来了，会发现，两个地方的内容是一致的。\n<br>\n\n如何去验证是否连接到，是否连接对：``docker inspect``\n> ![这是一张本地图片](./p24.png \"\")\n如果inspect后没有看到Mounts，说明挂载失败了\n\n在容器内部生成的文件也会映射在外面，同理，外面生成的内容也会映射到里面，停止容器后，外面文件再做修改，也是会映射到里面\n> ![这是一张本地图片](./p25.png \"\")\n> ![这是一张本地图片](./p26.png \"\")\n\n`\n<dr>\n<dr>\n__小案例__：MySQL同步数据\n```\n1、下载MySQL：docker pull mysql\n2、运行容器，做数据挂载：\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/\nmysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 容器ID\n注解：\n      -d 后台运行\n      -p 端口映射\n      -v 卷挂载\n      -e 环境配置\n      --name 容器命名\n```\n> 让我们来检查一下同步到了吗\n这是默认data文件里的内容：\n![这是一张本地图片](./p27.png \"\")\n此时，我们在外部连接上MySQL后，新建一个text数据库，再来看看data里的内容有没有做改变\n![这是一张本地图片](./p28.png \"\")\n我们能清楚的看到，多了一个text，说明，同步数据成功，就算把容器删除，我们已经存储到本地的数据依然还在，不会丢失，这就实现了容器数据持久化。\n\n## 具名和匿名挂载\n> \\# 匿名挂载\n-v 容器内路径\n``docker run -v /容器内需挂载的路径 容器ID``\n例如：``docker run -P -v /ect/nginx nginx``\n<dr>\n\\# 查看所有的volume\n``docker volume ls``\n![这是一张本地图片](./p29.png \"\")\n这种就是匿名挂载，没有指出卷名是什么\n<dr>\n我们平时也可以用具名挂载\n例如：``docker run -v hhhhhh-nginx:/etc/nginx 605c77e624dd``\n-v 卷名:容器内的路径\n![这是一张本地图片](./p30.png \"\")\n<dr>\n然后，我们可以用\"``docker volume inspect 卷名``\"来查看卷在主机内所挂载的位置\n![这是一张本地图片](./p31.png \"\")\n可以看出，所有的docker容器内的卷，没有指定目录的情况下都是在：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/var/lib/docker/volume/卷名/_data\n我们可以在主机上进入路径查看文件\n![这是一张本地图片](./p32.png \"\")\n<dr>\n还有一种是指定路径挂载\n``-v /主机路径:容器内路径``\n感兴趣的可以去试试，这里就不作展示了\n\n```\n总结：\n一般来说，我们的挂载方式最常用的有三种：\n1、 -v 容器内的路径           # 匿名挂载\n2、 -v 卷名:容器内的路径      # 具名挂载\n3、 -v /主机地址:容器内的地址 # 指定路径挂载\n```\n扩展：\n```\n我们可以通过 -v 容器内路径:ro或者rw 来改变读写权限\nro      # read only  只读\nrw      # read write 可读可写\n默认是rw\n例如：docker run -v hhsqdmz:/容器地址 容器ID\n\n# 一旦设置了容器权限，容器对我们挂载出来的内容就有了限定\n比如你看到有个ro，说明这个路径无法从容器内部做出操作，只能从主机来操作\n```\n\n## Dockerfile\nDockerfile用来构建docker镜像的构建文件，是一种命令脚本，通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层\n```\n1、创建一个Dockerfile文件，名字任取\n2、编写文件的内容，一个命令对着一层  指令(大写)  参数：\n   FROM centos\n   VOLUME [\"volume1\",\"volume2\"]\n   CMD echo \"succeed\"\n   CMD /bin/bash\n3、构造镜像\n   \"docker build -f 主机路径(编写Dockerfile的路径) -t 镜像名字(任取):TAG(版本号) .(别漏了这里的点)\"\n```\n![这是一张本地图片](./p33.png \"\")\n\n> 这个容器构建出来后也是可以启动的，启动命令和之前一样\n![这是一张本地图片](./p34.png \"\")\n这两个卷算是匿名挂载，在外部一定有一个同步的目录，我们可以通过inspect来查看地址\n![这是一张本地图片](./p35.png \"\")\n\ndockerfile是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件\n```\nDockerFile：构建文件，定义一切的步骤，源代码\n            相当于软件包\nDockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品\n            相当于软件\nDocker容器：容器就是镜像运行起来提供的服务器\n            相当于打开软件后，软件的后台\n```\n<dr>\n\n注意事项\n```\n1、每个保留关键字（指令）都必须是大写字母\n2、执行从上到下顺序执行\n3、'#'表示注释\n4、每一个指令都会创建提交一个新的镜像层\n```\n\n### DockerFile的指令\n```\nFROM        # 指定基础镜像，一切从这里开始构建\n              DockerHub中99%的镜像都是从FROM seach过来的，然后配置所需要的软件来进行构建\nMAINTAINER  # 作者是谁：姓名+邮箱\nRUN         # 镜像构建的时候需要运行的命令\nADD         # 添加内容，可以理解成加个软件包\nCOPY        # 类似ADD，将文件拷贝到镜像中\nWORKDIR     # 镜像的工作目录\nVOLUME      # 挂载卷的目录\nENV         # 构建时设置环境变量\nCMD         # 指定容器运行时要运行的命令，只有最后一个生成，可被替代\nENTRYPOINT  # 指定容器运行时要运行的命令，可以追加命令\nEXPOSE      # 暴露端口配置，跟上面的-p一样\nONBULID     # 是一个触发指令，当构建一个被继承 DockerFile 时，会运行 ONBULID 指令\n```\n\n## 数据卷容器\n我们同时启动三个我们上面自己构建的容器centos1、centos2、centos3\n> centos1为父容器，centos2是os1的子容器，os3是os2的子容器 \n1、\"docker run -it --name centos01 容器ID\"\n2、docker run -it --name centos02 --volumes-from centos01 容器ID\n3、docker run -it --name centos03 --volumes-from centos02 容器ID\n我们能在里面找到我们自己构建的两个文件\"volume01\"和\"volume02\"\n![这是一张本地图片](./p34.png \"\")\n我们在centos01里面，进入volume01，touch一个新的文件docker1；然后在centos03里，也是在volume01里，touch一个docker3。\n然后我们无论在三个容器之间的任意一个容器，都能看见新构建出来的文件\n![这是一张本地图片](./p36.png \"\")\n我们把centos01给exit退出，或者是删除rm都可以，但是，在其他两个容器里面依然能够看到docker1和docker2两个文件，只要其中有一个容器存活，数据就不会丢失\n\n这种容器之间配置信息的传递，数据卷容器的生命周期一直持续到所有共享的容器都停止为止\n\n\n# Docker网络\n## 查看网络配置\n> 我们每次启动一个docker容器，docker都会给docker容器分配一个ip地址，只要我们安装了docker，就会有一个网卡 docker0，这种叫桥接模式，使用的是evth-pair技术，只要一删除容器ip地址也会跟着消失\n\\# evth-pair技术就是一对虚拟设备接口，都是成对出现的，一端连着协议，一端互相连接，OpenStac也是运用这个技术\n查看网络配置命令 \"``ip addr``\"\n"}]
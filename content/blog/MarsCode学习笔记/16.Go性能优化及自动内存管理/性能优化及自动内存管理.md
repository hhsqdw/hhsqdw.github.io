---
title: 性能优化及自动内存管理
date: 2025-02-20
tags:
---

==这里主要讲的是Go语言==，太概念了，这知识根本不入脑

# 性能优化

提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力

## 性能优化的作用

- 用户体验：带来用户体验的提升 - 让刷抖音更丝滑，让双十一购物不再卡顿
- 资源高效利用：降低成本，提高效率 - 很小的优化乘以海量机器会是显著的性能提升和成本节约

## 性能优化的层面

- 业务层优化
	- 针对特定场景，具体问题，具体分析
	- 容易获得较大性能收益
- 语言运行时优化
	- 解决更通用的性能问题
	- 考虑更多场景
	- Tradeoffs
- 数据驱动
	- 自动化性能分析工具 -- pprof
	- 依靠数据而非猜测
	- 首先优化最大瓶颈

## 软件质量

- 软件质量至关重要
- 在保证接口稳定的前提下改进具体实现
- 测试用例:覆盖尽可能多的场景，方便回归
- 文档：做了什么，没做什么，能达到怎样的效果
- 隔离：通过选项控制是否开启优化
- 可观测:必要的日志输出

# 自动内存管理

- 动态内存
	- 程序在运行时根据需求动态分配的内存：malloc()
- 自动内存管理(垃圾回收):由程序语言的运行时系统管理动态内存
	- 避免手动内存管理，专注于实现业务逻辑
	- 保证内存使用的正确性和安全性: double-free problem, use-after-free problem


## 相关概念

- Mutator:业务线程，分配新对象，修改对象指向关系
- Collector: GC 线程，找到存活对象，回收死亡对象的内存空间
- Serial Gc: 只有一个 collector
- Parallel Gc: 支持多个 collectors 同时回收的 GC 算法
- Concurrent GC: mutator(s)和 collector(s)可以**同时执行**
	- Collectors 必须感知对象指向关系的改变

## 追踪垃圾回收

- 对象被回收的条件：指针指向关系不可达的对象
- 标记根对象
	- 静态变量、全局变量、常量、线程栈等
- 标记：找到可达对象
	- 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
- 清理：所有不可达对象
	- 将存活对象复制到另外的内存空间(Copying GC)
	- 将死亡对象的内存标记为“可分配”(Mark-sweep GC)
	- 移动并整理存活对象(Mark-compact GC)
- 根据对象的生命周期，使用不同的标记和清理策略
















